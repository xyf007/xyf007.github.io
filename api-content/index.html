{"posts":[{"title":"【学习笔记】单位根反演","content":"[n∣k]=1n∑i=0n−1ωnik[n\\mid k]=\\frac{1}{n}\\sum_{i=0}^{n-1}\\omega_n^{ik} [n∣k]=n1​i=0∑n−1​ωnik​ 这里 ωn\\omega_nωn​ 是 nnn 次单位根。证明是容易的，如果 ωnk\\omega_n^kωnk​ 不为 111，等比数列求和就是 000，否则就是 1n×n=1\\dfrac{1}{n}\\times n=1n1​×n=1。 通常模数都是质数 ppp，因此 nnn 次单位根在模 ppp 意义下可以用原根来计算。由于 gp−1≡1(modp)g^{p-1}\\equiv1\\pmod pgp−1≡1(modp)，所以 ωn≡gp−1n(modp)\\omega_n\\equiv g^{\\frac{p-1}{n}}\\pmod pωn​≡gnp−1​(modp)，所以题目通常保证 n∣p−1n\\mid p-1n∣p−1。而且通常是用来把组合数用二项式定理变成一个幂。 LOJ6485 LJJ 学二项式定理 给出 n,s,a0,a1,a2,a3n,s,a_0,a_1,a_2,a_3n,s,a0​,a1​,a2​,a3​，求 ∑i=0n(ni)siai mod 4\\sum_{i=0}^n\\binom{n}{i}s^ia_{i\\bmod4} i=0∑n​(in​)siaimod4​ 对 998244353998244353998244353 取模的结果。多组测试数据。1≤T≤1051\\le T\\le10^51≤T≤105，1≤n≤10181\\le n\\le10^{18}1≤n≤1018，1≤s,a0,a1,a2,a3≤1081\\le s,a_0,a_1,a_2,a_3\\le10^81≤s,a0​,a1​,a2​,a3​≤108。 题解 ∑i=0n(ni)siai mod 4=∑j=03aj∑i=0n(ni)si[i mod 4=j]=∑j=03aj∑i=0n(ni)si⋅14∑k=03ω4k(i−j)=14∑j=03aj∑k=03ω4−jk∑i=0n(ni)siω4ki=14∑j=03aj∑k=03ω4−jk(sω4k+1)n\\begin{aligned}&amp;\\sum_{i=0}^n\\binom{n}{i}s^ia_{i\\bmod4}\\\\=&amp;\\sum_{j=0}^3a_j\\sum_{i=0}^n\\binom{n}{i}s^i[i\\bmod4=j]\\\\=&amp;\\sum_{j=0}^3a_j\\sum_{i=0}^n\\binom{n}{i}s^i\\cdot\\frac{1}{4}\\sum_{k=0}^3\\omega_4^{k(i-j)}\\\\=&amp;\\frac{1}{4}\\sum_{j=0}^3a_j\\sum_{k=0}^3\\omega_4^{-jk}\\sum_{i=0}^n\\binom{n}{i}s^i\\omega_4^{ki}\\\\=&amp;\\frac{1}{4}\\sum_{j=0}^3a_j\\sum_{k=0}^3\\omega_4^{-jk}(s\\omega_4^k+1)^n\\end{aligned} ====​i=0∑n​(in​)siaimod4​j=0∑3​aj​i=0∑n​(in​)si[imod4=j]j=0∑3​aj​i=0∑n​(in​)si⋅41​k=0∑3​ω4k(i−j)​41​j=0∑3​aj​k=0∑3​ω4−jk​i=0∑n​(in​)siω4ki​41​j=0∑3​aj​k=0∑3​ω4−jk​(sω4k​+1)n​ 时间复杂度 O(Tlog⁡n)O(T\\log n)O(Tlogn)。 BZOJ3328 PYXFIB 给出 n,kn,kn,k，令 FiF_iFi​ 表示斐波那契数列第 iii 项，求 ∑i=0⌊nk⌋(nik)Fik\\sum_{i=0}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\binom{n}{ik}F_{ik} i=0∑⌊kn​⌋​(ikn​)Fik​ 对质数 ppp 取模的结果。保证 k∣p−1k\\mid p-1k∣p−1。多组测试数据。1≤T≤201\\le T\\le201≤T≤20，1≤n≤10181\\le n\\le10^{18}1≤n≤1018，1≤k≤200001\\le k\\le200001≤k≤20000，1≤p≤1091\\le p\\le10^91≤p≤109。 题解 就是求 kkk 的倍数的答案。 ∑i=0⌊nk⌋(nik)Fik=∑i=0n(ni)Fi[k∣i]=∑i=0n(ni)Fi∑j=0k−1ωkji=∑j=0k−1∑i=0n(ni)Fiωkji\\begin{aligned}&amp;\\sum_{i=0}^{\\left\\lfloor\\frac{n}{k}\\right\\rfloor}\\binom{n}{ik}F_{ik}\\\\=&amp;\\sum_{i=0}^n\\binom{n}{i}F_i[k\\mid i]\\\\=&amp;\\sum_{i=0}^n\\binom{n}{i}F_i\\sum_{j=0}^{k-1}\\omega_k^{ji}\\\\=&amp;\\sum_{j=0}^{k-1}\\sum_{i=0}^n\\binom{n}{i}F_i\\omega_k^{ji}\\end{aligned} ===​i=0∑⌊kn​⌋​(ikn​)Fik​i=0∑n​(in​)Fi​[k∣i]i=0∑n​(in​)Fi​j=0∑k−1​ωkji​j=0∑k−1​i=0∑n​(in​)Fi​ωkji​​ 而二项式定理对任意定义了加法和乘法的运算都成立，而 Fi=[0111]1,1iF_i=\\begin{bmatrix}0&amp;1\\\\1&amp;1\\end{bmatrix}^i_{1,1}Fi​=[01​11​]1,1i​。令 M=[0111]M=\\begin{bmatrix}0&amp;1\\\\1&amp;1\\end{bmatrix}M=[01​11​]，III 为单位矩阵，那么 ∑j=0k−1∑i=0n(ni)Fiωkji=∑j=0k−1((ωkjM+I)n)1,1\\begin{aligned}&amp;\\sum_{j=0}^{k-1}\\sum_{i=0}^n\\binom{n}{i}F_i\\omega_k^{ji}\\\\=&amp;\\sum_{j=0}^{k-1}((\\omega_k^jM+I)^n)_{1,1}\\end{aligned} =​j=0∑k−1​i=0∑n​(in​)Fi​ωkji​j=0∑k−1​((ωkj​M+I)n)1,1​​ 时间复杂度 O(T(p+klog⁡n))O(T(\\sqrt{p}+k\\log n))O(T(p​+klogn))。 ","link":"http://xyf007.ml/post/xue-xi-bi-ji-dan-wei-gen-fan-yan/"},{"title":"【模板】二分图最大权匹配","content":"匈牙利算法（KM 算法），时间复杂度 O(n3)O(n^3)O(n3)。 #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;queue&gt; template &lt;typename T1, typename T2&gt; void checkmax(T1 &amp;x, T2 y) { if (x &lt; y) x = y; } template &lt;typename T1, typename T2&gt; void checkmin(T1 &amp;x, T2 y) { if (x &gt; y) x = y; } int n, m, pre[501], ml[501], mr[501]; long long lx[501], rx[501], w[501][501], slack[501]; bool vl[501], vr[501]; void Aug(int v) { while (v) { int p = ml[pre[v]]; ml[pre[v]] = v, mr[v] = pre[v]; v = p; } } void Bfs(int s) { std::memset(vl + 1, 0, n), std::memset(vr + 1, 0, n); std::memset(slack + 1, 0x2a, 8 * n); std::queue&lt;int&gt; q; q.emplace(s); while (true) { while (!q.empty()) { int u = q.front(); q.pop(); vl[u] = true; for (int v = 1; v &lt;= n; v++) if (!vr[v]) { if (lx[u] + rx[v] - w[u][v] &lt; slack[v]) { slack[v] = lx[u] + rx[v] - w[u][v], pre[v] = u; if (!slack[v]) { vr[v] = true; if (!mr[v]) return Aug(v); q.emplace(mr[v]); } } } } long long d = 0x2a2a2a2a2a2a2a2aLL; for (int i = 1; i &lt;= n; i++) if (!vr[i]) checkmin(d, slack[i]); for (int i = 1; i &lt;= n; i++) if (vl[i]) lx[i] -= d; for (int i = 1; i &lt;= n; i++) if (vr[i]) rx[i] += d; else slack[i] -= d; for (int i = 1; i &lt;= n; i++) if (!vr[i] &amp;&amp; slack[i] == 0) { vr[i] = true; if (!mr[i]) return Aug(i); q.emplace(mr[i]); } } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m; std::memset(w, 213, sizeof(w)); for (int i = 1; i &lt;= m; i++) { int x, y; std::cin &gt;&gt; x &gt;&gt; y, std::cin &gt;&gt; w[x][y]; } for (int i = 1; i &lt;= n; i++) lx[i] = *std::max_element(w[i] + 1, w[i] + n + 1); for (int i = 1; i &lt;= n; i++) Bfs(i); long long ans = std::accumulate(lx + 1, lx + n + 1, 0LL) + std::accumulate(rx + 1, rx + n + 1, 0LL); std::cout &lt;&lt; ans &lt;&lt; '\\n'; for (int i = 1; i &lt;= n; i++) std::cout &lt;&lt; mr[i] &lt;&lt; ' '; return 0; } ","link":"http://xyf007.ml/post/mu-ban-er-fen-tu-zui-da-quan-pi-pei/"},{"title":"【模板】Powerful Number 筛","content":"Powerful Number 筛 另一种求积性函数前缀和的方式。 定义 定义 Powerful Number 为分解质因数后每个质因子的次数均 ≥2\\ge2≥2 的数。1∼n1\\sim n1∼n 中只有 O(n)O(\\sqrt{n})O(n​) 个 Powerful Number。 目标：求积性函数 fff 的前缀和 F(n)=∑i=1nf(i)F(n)=\\sum_{i=1}^nf(i)F(n)=∑i=1n​f(i)。 要求 存在一个积性函数 ggg 满足在质数 ppp 处 g(p)=f(p)g(p)=f(p)g(p)=f(p) 且 g(p)g(p)g(p) 易求前缀和。 筛法 令 h=f/gh=f/gh=f/g，这里 /// 表示狄利克雷除法，因此 hhh 也是积性函数。G(n)=∑i=1ng(i)G(n)=\\sum_{i=1}^ng(i)G(n)=∑i=1n​g(i)。那么有 F(n)=∑i=1nf(i)=∑i=1n∑d∣ih(d)g(id)=∑d=1nh(d)G(⌊nd⌋)\\begin{aligned}F(n)&amp;=\\sum_{i=1}^nf(i)\\\\&amp;=\\sum_{i=1}^n\\sum_{d\\mid i}h(d)g\\left(\\frac{i}{d}\\right)\\\\&amp;=\\sum_{d=1}^nh(d)G\\left(\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\right)\\end{aligned} F(n)​=i=1∑n​f(i)=i=1∑n​d∣i∑​h(d)g(di​)=d=1∑n​h(d)G(⌊dn​⌋)​ 对于质数 ppp，f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)，而 f(p)=g(p)f(p)=g(p)f(p)=g(p)，因此 h(p)=0h(p)=0h(p)=0。又因为 hhh 是积性函数，因此 hhh 只有在 Powerful Number 处有值。所以 DFS 枚举每一个 Powerful Number 计算答案即可。时间复杂度 O(n)O(\\sqrt{n})O(n​)。 ","link":"http://xyf007.ml/post/mu-ban-powerful-number-shai/"},{"title":"自然数等幂和","content":"自然数等幂和 求下式的值 ∑i=1nim\\sum_{i=1}^ni^m i=1∑n​im 拉格朗日插值 答案关于 nnn 是一个 (m+1)(m+1)(m+1) 次多项式，因此代入前 (m+2)(m+2)(m+2) 个自然数插值即可。由于取值连续可以做到 O(m)O(m)O(m)。 自然数幂求和公式 中国古代数学家李善兰提出的公式。 ∑i=1nim+1=∑k=0m(n+k+1m+2)∑r=0k(−1)r(m+2r)(k+1−r)m+1\\sum_{i=1}^ni^{m+1}=\\sum_{k=0}^m\\binom{n+k+1}{m+2}\\sum_{r=0}^k(-1)^r\\binom{m+2}{r}(k+1-r)^{m+1} i=1∑n​im+1=k=0∑m​(m+2n+k+1​)r=0∑k​(−1)r(rm+2​)(k+1−r)m+1 时间复杂度 O(m2)O(m^2)O(m2)，不知道有什么用。 第二类斯特林数 ∑i=1nim=∑i=1n∑j=0m{mj}ij‾=∑j=0m{mj}∑i=0nij‾=∑j=0m{mj}j!∑i=0n(ij)=∑j=0m{mj}j!(n+1j+1)=∑j=0m{mj}(n+1)j+1‾j+1\\begin{aligned}\\sum_{i=1}^ni^m&amp;=\\sum_{i=1}^n\\sum_{j=0}^m\\begin{Bmatrix}m\\\\j\\end{Bmatrix}i^{\\underline{j}}\\\\&amp;=\\sum_{j=0}^m\\begin{Bmatrix}m\\\\j\\end{Bmatrix}\\sum_{i=0}^ni^{\\underline{j}}\\\\&amp;=\\sum_{j=0}^m\\begin{Bmatrix}m\\\\j\\end{Bmatrix}j!\\sum_{i=0}^n\\binom{i}{j}\\\\&amp;=\\sum_{j=0}^m\\begin{Bmatrix}m\\\\j\\end{Bmatrix}j!\\binom{n+1}{j+1}\\\\&amp;=\\sum_{j=0}^m\\begin{Bmatrix}m\\\\j\\end{Bmatrix}\\frac{(n+1)^{\\underline{j+1}}}{j+1}\\end{aligned} i=1∑n​im​=i=1∑n​j=0∑m​{mj​}ij​=j=0∑m​{mj​}i=0∑n​ij​=j=0∑m​{mj​}j!i=0∑n​(ji​)=j=0∑m​{mj​}j!(j+1n+1​)=j=0∑m​{mj​}j+1(n+1)j+1​​​ O(m2)O(m^2)O(m2) 或 O(mlog⁡m)O(m\\log m)O(mlogm) 处理第二类斯特林数即可 O(m)O(m)O(m) 求答案。 递推 设 fm=∑i=1nimf_m=\\sum_{i=1}^ni^mfm​=∑i=1n​im。 考虑裂项 (n+1)m+1−1=∑i=1n((i+1)m+1−im+1)=∑i=1n((∑j=0m+1(m+1j)ij)−im+1)=∑j=0m(m+1j)fj\\begin{aligned}(n+1)^{m+1}-1&amp;=\\sum_{i=1}^n((i+1)^{m+1}-i^{m+1})\\\\&amp;=\\sum_{i=1}^n\\left(\\left(\\sum_{j=0}^{m+1}\\binom{m+1}{j}i^j\\right)-i^{m+1}\\right)\\\\&amp;=\\sum_{j=0}^m\\binom{m+1}{j}f_j\\end{aligned} (n+1)m+1−1​=i=1∑n​((i+1)m+1−im+1)=i=1∑n​((j=0∑m+1​(jm+1​)ij)−im+1)=j=0∑m​(jm+1​)fj​​ 因此 fm=1m+1((n+1)m+1−1−∑i&lt;m(m+1i)fi)f_m=\\dfrac{1}{m+1}\\left((n+1)^{m+1}-1-\\sum\\limits_{i&lt;m}\\dbinom{m+1}{i}f_i\\right)fm​=m+11​((n+1)m+1−1−i&lt;m∑​(im+1​)fi​)。时间复杂度 O(m2)O(m^2)O(m2) 但是可以求出前 mmm 项。 伯努利数 先预处理伯努利数 BiB_iBi​。B0=1B_0=1B0​=1，∑i=0m(m+1i)Bi=0\\sum\\limits_{i=0}^m\\dbinom{m+1}{i}B_i=0i=0∑m​(im+1​)Bi​=0。 结论是 ∑i=1nim=1m+1∑i=0m(m+1i)Binm+1−i\\sum_{i=1}^ni^m=\\dfrac{1}{m+1}\\sum_{i=0}^m\\binom{m+1}{i}B_in^{m+1-i} i=1∑n​im=m+11​i=0∑m​(im+1​)Bi​nm+1−i 暴力计算伯努利数是 O(m2)O(m^2)O(m2) 的，但是伯努利数的 EGF 是 xex−1\\dfrac{x}{e^x-1}ex−1x​，可以通过多项式求逆做到 O(mlog⁡m)O(m\\log m)O(mlogm)。 ","link":"http://xyf007.ml/post/zi-ran-shu-deng-mi-he/"},{"title":"【学习笔记】计数问题总结","content":"主要是对 DEGwer 的《数え上げテクニック集》进行学习。传送门 设计状态 问题的核心在于找到整个搜索过程中的等价状态。设计状态的时候有三个重要的条件： 转移的目标状态相同。 转移时的系数相同。 每个状态表示的所有状态要么都符合问题陈述，要么不符合问题陈述。 下面是两个例题。 ARC059F Unhappy Hacking 对于一个字符串，每次你可以进行以下三种操作之一： 在末尾添加一个 0； 在末尾添加一个 1； 删除末尾的字符，如果为空串则不变。 求有多少种方式使得进行 nnn 次操作后得到字符串 sss，对 109+710^9+7109+7 取模。1≤∣s∣≤n≤50001\\le|s|\\le n\\le50001≤∣s∣≤n≤5000。 题解 一个朴素的想法就是设 fi,j,kf_{i,j,k}fi,j,k​ 表示进行 iii 次操作之后，当前长度为 jjj，和 sss 匹配的长度为 kkk 的方案数。但是有一个很重要的性质：所有长度相等的字符串都是本质相同的，因为每次添加 0 还是 1 没有区别。所以只要求出进行 nnn 次操作之后长度为 ∣s∣|s|∣s∣ 的字符串总数，除以 2∣s∣2^{|s|}2∣s∣ 即可。时间复杂度 O(n2)O(n^2)O(n2)。 Code Festival 2016 Final F. Road of the King 有 nnn 个结点，一个人从 111 号结点出发走 mmm 步。每次走路的方式如下： 假设当前所在结点为 uuu，选择一个点 vvv，走到 vvv 并连一条 u→vu\\to vu→v 的有向边。允许留在原地。 求最后形成一张强连通图的方案数。1≤n,m≤3001\\le n,m\\le3001≤n,m≤300。 题解 整个过程中，如果时刻缩点，那么这张图的形态一定是一条链和若干个还未访问过的点，且人始终在链的尾部。然后我试图考虑记录这条链的形态，然后每次枚举缩了多少个点，但是这样就会导致要记录所有强连通分量的大小，不可行。但是最终答案并不关心这条链，只关心每个点能否到达 111。也就是说所有链上的点被缩起来的时间是没有意义的，因而只需要知道链上点的数量。设 fi,j,kf_{i,j,k}fi,j,k​ 表示走了 iii 步，还有 jjj 个未访问的点，111 所在的强连通分量大小为 kkk 的方案数，转移的时候枚举走到哪里即可。时间复杂度 O(n2m)O(n^2m)O(n2m)。 像下面这个问题一样，半强迫式设计状态的情况也时有发生。如果满足上面列举的 3 个条件，「非直觉性」的状态也是可以的。 Aizu2439 Hakone 有 nnn 支队伍参加接力赛。对于当前排名为 iii 的队伍，已知其相对于上一棒的排名 aia_iai​ 是变大、不变还是变小。求有多少个排列 aaa 满足条件。1≤n≤2001\\le n\\le2001≤n≤200。 题解 首先排名不变的对答案不造成影响，可以直接删去。然后从小到大枚举 iii 和 aia_iai​，让 iii 来匹配 aia_iai​。对于 aia_iai​，如果 i&lt;aii&lt;a_ii&lt;ai​，那么就是选择一个还没有用过的 iii 来匹配；否则就是留出一个空位，等之后的一个 iii 来匹配。对于 iii，让其匹配之前或者之后的空位。因此可以设计出这样一个状态：fi,j,kf_{i,j,k}fi,j,k​ 表示枚举前 iii 位，有 jjj 个数没有匹配，有 kkk 个空位需要匹配。转移的时候枚举 iii 向上/下匹配即可（aia_iai​ 被上/下匹配是确定的不用枚举）。显然 j=kj=kj=k，因此不需要开两维，只要 fi,jf_{i,j}fi,j​ 即可。时间复杂度 O(n2)O(n^2)O(n2)。 改变顺序 正如上一节提到的，在设计 DP 状态的时候，改变考虑事情的顺序往往是很有效的。此外，在决策顺序任意的情况下，例如在计算满足条件的子集时，「任意」确定决策顺序是很重要的。 下面是三个典型的顺序。 按照大小顺序 按照大小顺序是最简单的一种，但是很多情况下很有效。 Aizu2333 My friends are small 有 nnn 个物品和一个容量为 mmm 的背包，每个物品重量为 wiw_iwi​。求有多少种不同的放置物品的方式，使得剩下所有物品均不能放进背包。1≤n≤2001\\le n\\le2001≤n≤200，1≤wi,m≤100001\\le w_i,m\\le100001≤wi​,m≤10000。 题解 将所有物品排序，这样只要最小的不能放进背包即可。枚举这个物品 xxx，那么 1∼(x−1)1\\sim(x-1)1∼(x−1) 的物品都要放入，(x+1)∼n(x+1)\\sim n(x+1)∼n 的物品要使得剩下容量 &lt;wx&lt;w_x&lt;wx​，直接做背包即可。时间复杂度 O(n2m)O(n^2m)O(n2m)。 排列插入 DP 一些题目的形式是「有多少种排列满足给定条件？」，如果我们用 DP 来处理，通常需要状压已经用过的数，这很不妙。 插入 DP 是一种用来处理这种问题的方式。假定给出条件只和元素之间的大小关系有关，这时候 DP 可以用来帮助你排序你要的元素，然后把数字升序/降序插入到需要的位置，而不是从前往后确定每一个数。 现在让我们考虑一下为什么插入 DP 在很多情况下有效？ 假如你按照升序插入，你会得到这样的信息：已经插入的数都比当前的数大，还未插入的数都比当前的数小。这样的重排在「大于」关系与当前填的数不是特别相关的时候很有用。 有 nnn 座房子排成一行，高度分别为 1,2,…,n1,2,\\ldots,n1,2,…,n。有多少种排列房子的方式，使得从左边看可以看到 xxx 座房子，从右边看可以看到 yyy 座房子？一座房子可以从左（右）边看到当且仅当它左（右）边没有比它高的房子。 题解 从高往低插入房子，只有插入在最左边/最右边才会导致可以看到的房子数量增加。于是设 fi,x,yf_{i,x,y}fi,x,y​ 表示插入了 iii 座房子，左边可以看到 xxx 座，右边可以看到 yyy 座的方案数。时间复杂度 O(n3)O(n^3)O(n3)。 区间端点排序 给出一些区间，一些问题的形式是「有多少种方式选择若干个区间，使它们满足一个特定的覆盖条件？」，这时候给区间端点排序是一个有效的方法。同时给区间端点排序也是经典贪心问题《任务安排》的做法。 给出 nnn 个区间 [li,ri][l_i,r_i][li​,ri​]，求有多少种方式选择若干个区间，使得它们的并是 [0,X][0,X][0,X]。n≤105n\\le10^5n≤105。 题解 将所有区间按照右端点排序，设 fi,jf_{i,j}fi,j​ 表示 iii 考虑完前 iii 个区间，第一个未覆盖的位置是 jjj 的方案数。可以用数据结构优化至 O(nlog⁡n)O(n\\log n)O(nlogn)。不止这题，其他很多有关选择区间的题目也可以用数据结构优化。 条件的转化 有些时候题目给出的操作不适合做题，这时候有必要把给出的条件转化为「可以计数」的条件。 和设计状态一样，条件转化的时候同样需要 ad-hoc 的思考。有些时候这种转化很困难。但是要避免这样一种错误的认知：自己第一次想到的转化就是正确的。当你想到一种转化的时候，建议证明一下；如果不能证明，至少确保反例很难出现。有些时候，猜想「如果没有这个结论这道题看起来完全不可做」会有帮助。 当你想到一个必要条件的时候，应该去看看是不是充分条件。 AGC015D A or...or B Problem 求使用 [L,R][L,R][L,R] 中若干整数按位或能得到的数的数量。1≤L≤R&lt;2601\\le L\\le R&lt;2^{60}1≤L≤R&lt;260。 题解 特判 L=RL=RL=R 的情况。接下来找到 LLL 和 RRR 不同的最高位 ttt。将区间分成 [L,2t)[L,2^t)[L,2t) 和 [2t,R][2^t,R][2t,R]。 如果只使用 [L,2t)[L,2^t)[L,2t) 中的数，能表示 [L,2t)[L,2^t)[L,2t)，且根据按位或的性质 &lt;2t&lt;2^t&lt;2t 的数中只有 [L,2t)[L,2^t)[L,2t) 能被表示出来。 如果只使用 [2t,R][2^t,R][2t,R] 中的数，设 ppp 为 RRR 在 ttt 之后第一个为 111 的位置，那么 [2t,2t+2p+1−1][2^t,2^t+2^{p+1}-1][2t,2t+2p+1−1] 都能表示出来（使用 2t,2t+20,2t+21,…,2t+2p2^t,2^t+2^0,2^t+2^1,\\ldots,2^t+2^p2t,2t+20,2t+21,…,2t+2p），且只能表示这些。 如果使用两个区间都使用，那么下界是 2t+L2^t+L2t+L，上界是 2t+1−12^{t+1}-12t+1−1。 三个区间取并即可，为 [L,2t+2p+1−1]∪[2t+L,2t+1−1][L,2^t+2^{p+1}-1]\\cup[2^t+L,2^{t+1}-1][L,2t+2p+1−1]∪[2t+L,2t+1−1]。时间复杂度 O(log⁡R)O(\\log R)O(logR)。 AGC009E Eternal Average 黑板上有 nnn 个 000 和 mmm 个 111，每次选择 kkk 个数擦除，然后把它们的平均数写上去，这样一直操作直到只剩下一个数，求剩下的这个数有多少种可能的值。1≤n,m≤20001\\le n,m\\le20001≤n,m≤2000，2≤k≤20002\\le k\\le20002≤k≤2000。保证 (k−1)∣(n+m−1)(k-1)\\mid(n+m-1)(k−1)∣(n+m−1)。 题解 对于擦除写平均数的一个经典套路是将其看作 kkk 叉树，每个结点要么是叶子，要么有 kkk 个儿子，其值为所有儿子的平均值。这样剩下的数 zzz 就是根结点的值。 设 000 的深度分别为 xix_ixi​，111 的深度分别为 yiy_iyi​，那么 z=∑k−yiz=\\sum k^{-y_i}z=∑k−yi​。注意到剩下的位置如果也是 111，z=1z=1z=1，所以 1−z=∑k−xi1-z=\\sum k^{-x_i}1−z=∑k−xi​。这样所有合法的 x,yx,yx,y 序列都能对应 zzz。用 kkk 进制小数来表示，z=0.a1a2⋯alz=0.a_1a_2\\cdots a_lz=0.a1​a2​⋯al​。假设没有进位，有 ∑ai=m\\sum a_i=m∑ai​=m。每进位一次，∑ai\\sum a_i∑ai​ 减少 (k−1)(k-1)(k−1)。因此 ∑ai≡m(modk−1)\\sum a_i\\equiv m\\pmod{k-1}∑ai​≡m(modk−1)。对于 1−z1-z1−z，有 1+∑(k−1−ai)≡n(modk−1)1+\\sum(k-1-a_i)\\equiv n\\pmod{k-1}1+∑(k−1−ai​)≡n(modk−1) 且 1+∑(k−1−ai)≤n1+\\sum(k-1-a_i)\\le n1+∑(k−1−ai​)≤n。所有条件整合如下： 0≤ai≤k−10\\le a_i\\le k-10≤ai​≤k−1； al&gt;0a_l&gt;0al​&gt;0； ∑ai≡m(modk−1)\\sum a_i\\equiv m\\pmod{k-1}∑ai​≡m(modk−1) 且 ∑ai≤m\\sum a_i\\le m∑ai​≤m； 1+∑(k−1−ai)≡n(modk−1)1+\\sum(k-1-a_i)\\equiv n\\pmod{k-1}1+∑(k−1−ai​)≡n(modk−1) 且 1+∑(k−1−ai)≤n1+\\sum(k-1-a_i)\\le n1+∑(k−1−ai​)≤n。 因此对 ∑ai\\sum a_i∑ai​ 进行 DP 即可。设 fi,j,0/1f_{i,j,0/1}fi,j,0/1​ 表示填了 iii 个数，当前 ∑ai=j\\sum a_i=j∑ai​=j，结尾是否为 000 的方案数，前缀和优化转移即可。由后两个不等式可知 (k−1)l≤n+m−1(k-1)l\\le n+m-1(k−1)l≤n+m−1，即 iii 的上限为 lim=n+m−1k−1\\textit{lim}=\\dfrac{n+m-1}{k-1}lim=k−1n+m−1​。时间复杂度 O(lim×m)O(\\textit{lim}\\times m)O(lim×m)。 利用贪心 有一些题目让我们求「通过某种操作可以得到的状态数量」，其难点在于不同的操作序列可以得到相同的状态导致算重。但是，如果存在将最终状态唯一对应一种操作序列的方式，我们就可以直接对满足条件的操作序列计数。这种唯一对应的方式通常使用贪心。 考虑判断最终状态的合法性。假如可以通过维护 O(1)O(1)O(1) 个变量并从前向后看来解决，那么我们可以通过把这个变量作为 DP 的一维来机械化地将其转化成计数问题。 求有多少个长度为 nnn 的排列可以划分成两个上升子序列。 题解 首先考虑判定。设这两个子序列分别为 a,ba,ba,b，从前往后扫整个排列，不妨让 aaa 的末尾始终是前缀最大值，则此时 bbb 的末尾越小越好。因此如果新的数是最大值，加在 aaa 后面；否则如果比 bbb 的末尾大，加在 bbb 的末尾；否则不合法。因此我们只需要维护 bbb 的末尾这一个信息。将其转化成 DP，设 fi,jf_{i,j}fi,j​ 表示填了前 iii 个数，bbb 的末尾是前 iii 个里面的第 jjj 小的数的方案数。转移的时候枚举新加入的数在前 (i+1)(i+1)(i+1) 个数中的排名即可。可以前缀和优化，时间复杂度 O(n2)O(n^2)O(n2)。 如果打表可以发现答案就是卡特兰数，具体考虑这个转移过程和走网格类似。 XVIII Open Cup GP of Romania I. Salaj 初始有一张含有 nnn 个孤立点的有向图，你可以不断向其中加边（不允许加入重边或者自环）。定义一个长度为 kkk 的序列 aaa 为一个 SCC 序列，当且仅当存在一种加边方案，使得加入 iii 条边后图中恰好存在 aia_iai​ 个强连通分量。对 k∈[1,m]k\\in[1,m]k∈[1,m]，求出有多少种长度为 kkk 的 SCC 序列。1≤n≤501\\le n\\le501≤n≤50，1≤m≤n(n−1)1\\le m\\le n(n-1)1≤m≤n(n−1)。 题解 首先要明确一点：我们的目标是建立一个 SCC 序列与连边序列的对应关系。 有一个暴力的 DP：fi,Sf_{i,S}fi,S​ 表示当前加入了 iii 条边，形成 SCC 的大小构成的集合为 SSS 时的方案数（SSS 事实上是个 nnn 的划分数）。考虑转移：如果当前这条边被加在某个 SCC 内部，那么集合不会变；如果被加在外部，可以暴力枚举缩起来了哪几个 SCC，然后转移。注意转移的条件。设 xxx 表示形成 SSS 中 SCC 至少需要的边（因为当前状态下形成 SSS 至少需要的边不一定就是 SSS 中的环数，可能有某个 SCC 是通过若干个更小的 SCC 连接而来的）。对于加在 SCC 内部的情况，你需要让当前存在边的空位，即 i&lt;x+limi&lt;x+\\textit{lim}i&lt;x+lim，这里 lim\\textit{lim}lim 表示在保持 SSS 不变的情况下最多能加入的边的数量。对于加在外部的情况，假设缩起了 kkk 个 SCC，就需要 i+1≥k+xi+1\\ge k+xi+1≥k+x。 尝试把 SSS 去掉，会发现少了一维状态 xxx。而我们会发现，第二种转移和 SSS 无关，只和 SCC 的个数有关。要让第一种转移合法，需要让 lim\\textit{lim}lim 尽可能大，那么利用贪心，这样的方案是让一个 SCC 的大小为 (n−∣S∣+1)(n-|S|+1)(n−∣S∣+1)，剩下 (∣S∣−1)(|S|-1)(∣S∣−1) 个 SCC 的大小都是 111。 于是我们找到了 SCC 序列与加边序列的对应关系，可以设计更简单的转移：fi,j,kf_{i,j,k}fi,j,k​ 表示加入了 iii 条边，形成当前状态的 SCC 至少需要 jjj 条边，有一个大小为 kkk 和 (n−k)(n-k)(n−k) 个大小为 111 的 SCC 的方案数。注意到第二维是 O(n)O(n)O(n) 的，因此总状态数是 O(n2m)O(n^2m)O(n2m) 的。暴力转移可能需要枚举当前缩起来了多少个 SCC，但是可以前缀和优化。时间复杂度 O(n2m)O(n^2m)O(n2m)。 钦定情况 在计数中，通过某些参数的值来计算情况往往是很诱人的。在这种情况下，你需要确保所有的情况都是不相交的（除非可以容斥）。换句话说，这个参数必须被这种情况唯一确定。（顺便提一下，对于最优化的问题，重复计算是可以的。这一点往往很重要，是计数和优化的主要区别之一。） 给出 nnn 个不同的整数，两个人分别选择若干个数，要求第一个人选的所有数都小于第二个人选的，且两人选择的数之和相等。求方案数。1≤n≤1001\\le n\\le1001≤n≤100，1≤ai≤1001\\le a_i\\le1001≤ai​≤100。 题解 如果只是枚举界线 xxx，要求第一个人选择的数 ≤x\\le x≤x，第二个人选择的数 &gt;x&gt;x&gt;x，会导致算重，比如界线选择在 aia_iai​ 和 ai+1a_{i+1}ai+1​ 之间的时候。实际上应该钦定第一个人选择的最大值，这样就不会算重了。然后存下前缀和后缀的背包状况，时间复杂度 O(n∑∣ai∣)O(n\\sum|a_i|)O(n∑∣ai​∣)。 AGC013D Piling Up 一开始有黑球和白球共 nnn 个，但不知道分别有多少。你要进行 mmm 次操作，每次先拿出一个球，再放入黑白球各一个，再拿出一个球。求拿出的球形成的颜色序列可能有多少种。1≤n,m≤30001\\le n,m\\le30001≤n,m≤3000。 题解 任何时候如果白球有 xxx 个，则黑球有 (n−x)(n-x)(n−x) 个。因此设 fi,jf_{i,j}fi,j​ 表示进行 iii 次操作后还有 jjj 个白球的方案数。将白球的数量变化画成折线，则每一种类型的折线都对应一个颜色序列。可以发现一条折线上下平移会被计算多次，为了不算重，我们只计算碰到坐标轴的折线。因此多记录一维这条折线是否碰到过坐标轴。时间复杂度 O(nm)O(nm)O(nm)。 计算贡献 在一些计数问题中会出现「计算所有 XX 的 △ 的值，并找出 △ 的总和」这种问题，另一个例子是「求 XX 的期望值」。在这种情况下，把你想求的东西写成贡献之和的形式往往有用。 给出 nnn 个数 aia_iai​ 和一个偶数 kkk，从中任意选择 kkk 个数，求所有选择方案的中位数之和。1≤n≤1051\\le n\\le10^51≤n≤105。 题解 中位数是 ak/2+ak/2+12\\dfrac{a_{k/2}+a_{k/2+1}}{2}2ak/2​+ak/2+1​​，分别计算每个数作为 ak/2a_{k/2}ak/2​ 和 ak/2+1a_{k/2+1}ak/2+1​ 的贡献即可，都是组合数相乘的形式。时间复杂度 O(n)O(n)O(n)。 在有关位运算的题目中，逐位考虑是很有用的。 求下式的值 ∑i=0n∑j=0mx⊕y\\sum_{i=0}^n\\sum_{j=0}^mx\\oplus y i=0∑n​j=0∑m​x⊕y 这里 ⊕\\oplus⊕ 表示按位异或。n,m≤109n,m\\le10^9n,m≤109。 题解 对于每一位分开计算贡献。设 f(n,k)f(n,k)f(n,k) 表示 0∼n0\\sim n0∼n 中二进制第 kkk 位为 111 的数的数量，那么第 kkk 位的贡献就是 2k(f(n,k)(m+1−f(m,k))+(n+1−f(n,k))f(m,k))2^k(f(n,k)(m+1-f(m,k))+(n+1-f(n,k))f(m,k))2k(f(n,k)(m+1−f(m,k))+(n+1−f(n,k))f(m,k))。时间复杂度 O(log⁡n)O(\\log n)O(logn)。 AGC005F Many Easy Problems（简单版） 给定一棵无根树，定义 f(i)f(i)f(i) 为，对所有大小为 iii 的点集，能够包含它的最小连通块大小之和。求 f(k)f(k)f(k)，对 924844033924844033924844033 取模。2≤n≤2×1052\\le n\\le2\\times10^52≤n≤2×105，1≤k≤n1\\le k\\le n1≤k≤n。 题解 显然不可能真的去算所有点集，考虑计算每一个点的贡献。单独算贡献也不好算，但是正难则反，一个点没有贡献的情况比较好算，当且仅当以这个点为根时，所有选择的点都在一个子树内部。因此可以得到以下式子： ansk=n(nk)−∑i=1n∑v∈son⁡(i)(szvk)\\textit{ans}_k=n\\binom{n}{k}-\\sum_{i=1}^n\\sum_{v\\in\\operatorname{son}(i)}\\binom{\\textit{sz}_v}{k} ansk​=n(kn​)−i=1∑n​v∈son(i)∑​(kszv​​) 子群的技巧 有很多问题的形式是「通过某种操作可以达到多少个状态？」如果这种操作是全局的，即能否操作与当前状态无关，那么下面这个定理很有用。 拉格朗日定理：设 HHH 是有限群 GGG 的子群，则 ∣H∣|H|∣H∣ 是 ∣G∣|G|∣G∣ 的因子。 考虑一个魔方，设 GGG 为将一个魔方拆开后重组可以得到的所有状态，HHH 为通过正常的旋转方式得到的所有状态。HHH 是 GGG 的子集，∣H∣|H|∣H∣ 是 ∣G∣|G|∣G∣ 的一个因子。 要解决这类问题，通常从小的情况开始考虑。∣G∣|G|∣G∣ 通常比较好计算，并且数据规模小的时候 ∣H∣|H|∣H∣ 可以通过搜索来得到。假如 ∣G∣/∣H∣=k|G|/|H|=k∣G∣/∣H∣=k，我们可以预测区分这些状态的变量的乘积为 kkk。这个预测在寻找过程中的不变量很有用。如果 kkk 是偶数，我们可以猜想求和和置换等可能有用。 Code Festival 2016 Final I. Reverse Grid 给出一个 n×mn\\times mn×m 的字符矩阵，每次可以翻转任意一行/列。可以进行任意多次操作，求能生成的字符矩阵数量。1≤n,m≤2001\\le n,m\\le2001≤n,m≤200。 题解 把所有矩阵看作 GGG，能生成的看作 HHH。注意 (i,j)(i,j)(i,j) 只能到 (n−i+1,j),(i,m−j+1),(n−i+1,m−j+1)(n-i+1,j),(i,m-j+1),(n-i+1,m-j+1)(n−i+1,j),(i,m−j+1),(n−i+1,m−j+1)。经过搜索，这题的性质就很显然了。——作者 这个性质似乎并不显然，于是我们想一个普通做法。 首先 nnn 是奇数的时候，中间那一行不会受到列翻转的影响，只有不是回文的时候可以使答案乘 222。mmm 是奇数的时候同理。因此只需要考虑 n,mn,mn,m 都是偶数的情况。 把所有互相可达的四个位置看成一组，取左上角那一个作为代表。考虑这样一种操作：翻转第一列、第一行、第一列、第一行。这时候一组内形成一个三轮换，剩下均不变。这就意味着如果四个数互不相同，可以形成所有偶排列，不能形成奇排列；如果有相同的数，那么可以形成这四个数的所有排列。 只翻转某一行/列，可以形成奇排列，但是，这一行/列上剩下的组也只能形成奇排列。于是建出一张二分图，对于一个只能生成偶排列的组，将其所在行和列连边。行列是否翻转对应点权为 0/10/10/1，一条边两个端点之和奇偶性表示这个组最终排列的奇偶性。 于是转化为对边权序列计数。分别处理每一个连通块，设其大小为 sss，任取一个生成树，则每一条树边都可以任意选取，非树边都被这种状态唯一确定，方案数为 2s−12^{s-1}2s−1。 具体过程总结如下： 处理奇数的情况，转化为偶数。 计算每一个组内部的方法数。 计算通过改变奇偶性能乘上的系数 2n/2+m/2−c2^{n/2+m/2-c}2n/2+m/2−c，ccc 表示二分图连通块数量。 时间复杂度 O(nm)O(nm)O(nm)。 这个技巧可以用来做下面这题，尽管它不是计数。 AGC006E Rotate 3x3 有一个 333 行 NNN 列的初始矩阵，(i,j)(i,j)(i,j) 位置的数为 i+3(j−1)i+3(j-1)i+3(j−1)。 每次可以进行这样的操作：选择一个 3×33\\times33×3 的子矩阵，将这个子矩阵旋转 180°180\\degree180°，如图。 现在给出一个 333 行 NNN 列的矩阵，问能否通过若干次上述操作将初始矩阵变为给定的矩阵。5≤n≤1055\\le n\\le10^55≤n≤105。 题解 显然三个数都是绑定的，先判掉一些明显不合法的状态。注意到奇偶独立，这时候 GGG 就是所有奇偶分开后是否颠倒的所有排列，HHH 是可以生成的排列，可以发现 k=4k=4k=4。因此猜想是两个 01 变量影响答案，与初始颠倒数量和逆序对数量奇偶性有关。 具体证明：可以通过一些操作使得不改变其他状态时任意相隔一列的两列上下颠倒。也就是说只要奇数列和偶数列颠倒数量都是偶数就合法。而每旋转一次，中间那一列也会颠倒。因此奇数列的颠倒数量就是初始颠倒数量加上偶数列逆序对数量，偶数列同理。时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 递归定义的运用 有时我们会遇到一些分形之类的题目，要对一个递归定义的东西计数。你可以像它定义的那样进行 DP。 这时候我们要找到需要的状态。比如一个 kkk 层的分形是 (k−1)(k-1)(k−1) 层的分形经过一些操作得来的。这时候，为了找到我们需要在第 kkk 层中需要的信息，我们需要考虑在第 (k−1)(k-1)(k−1) 层需要记录哪些信息。此外，我们需要选择可以通过不同方式找到的「额外价值」。 ARC037D Chaotic Polygons 谢尔宾斯基三角形定义如下图。 求第 nnn 个谢尔宾斯基三角形中简单回路的数量。这里简单回路的要求是一笔画且不能经过相同的点。1≤n≤1051\\le n\\le10^51≤n≤105。 题解 设第 iii 个的答案是 ansi\\textit{ans}_iansi​，如果一个回路不是在一个 (i−1)(i-1)(i−1) 层三角形的内部，那么必然同时经过了这三个小三角形。于是记 hih_ihi​ 表示从第 iii 层三角形一个顶点进入，另一个顶点离开的方案数，则 ansi=3ansi−1+hi−13\\textit{ans}_i=3\\textit{ans}_{i-1}+h_{i-1}^3ansi​=3ansi−1​+hi−13​。问题转化成计算 hih_ihi​。 以左下角进入，右下角离开为例。如果不经过上面那个小三角形，方案数是 hi−12h_{i-1}^2hi−12​；否则，方案数就是左下角、上方、右下角三个方案数的乘积。但是有一个问题：底边中点只能经过一次。因此还要设 fif_ifi​ 和 gig_igi​ 分别表示从一个顶点进入，一个顶点离开，经过/不经过剩下那个顶点的方案数，计算的时候减去两边都经过底边中点的方案数。即 fi=fi−1(hi−12−fi−12)gi=hi−12+gi−1(hi−12−fi−12)hi=fi+gi\\begin{aligned}f_i&amp;=f_{i-1}(h_{i-1}^2-f_{i-1}^2)\\\\g_i&amp;=h_{i-1}^2+g_{i-1}(h_{i-1}^2-f_{i-1}^2)\\\\h_i&amp;=f_i+g_i\\end{aligned} fi​gi​hi​​=fi−1​(hi−12​−fi−12​)=hi−12​+gi−1​(hi−12​−fi−12​)=fi​+gi​​ 时间复杂度 O(n)O(n)O(n)。 数位 DP Aizu0570 Zig-Zag Numbers 求 [L,R][L,R][L,R] 间有多少个数是 mmm 的倍数，且相邻两个数字之间的大小关系是大于、小于交错的。1≤L≤R≤105001\\le L\\le R\\le10^{500}1≤L≤R≤10500，1≤m≤5001\\le m\\le5001≤m≤500。 题解 数位 DP，设 fi,j,k,0/1/2,0/1f_{i,j,k,0/1/2,0/1}fi,j,k,0/1/2,0/1​ 表示填了 iii 位，上次填的是 jjj，当前形成的数模 mmm 余 kkk，前两个数字的大小关系是小于/大于/只有一个数，前缀是否和 xxx 相等，转移枚举新填的数。时间复杂度 O(102mlog⁡10R)O(10^2m\\log_{10}R)O(102mlog10​R)。 有 nnn 种硬币，价值分别为 aia_iai​，数量无限。求支付恰好 XXX 元的方案数。n≤20n\\le20n≤20，ai≤30a_i\\le30ai​≤30，X≤1018X\\le10^{18}X≤1018。 题解 将 XXX 和每种硬币使用的数量都写成二进制。从低到高考虑，假设当前是第 kkk 位，那么选择一种硬币，就是用 2k2^k2k 个这种硬币。第 kkk 位的选择只需要满足已经选择的总和与 XXX 的第 kkk 位相等就是合法的。注意到选择的值很大会有进位，因此还要记录进位的大小。于是设 fi,jf_{i,j}fi,j​ 表示考虑了 iii 位，进位为 jjj 的方案数。注意到虽然有 2n2^n2n 种选择方案，但是值域只有 ∑ai\\sum a_i∑ai​。所以预处理每种方案之后转移和第二维的大小都是 O(∑ai)O(\\sum a_i)O(∑ai​) 的。时间复杂度 O(2n+(∑ai)2log⁡X)O(2^n+(\\sum a_i)^2\\log X)O(2n+(∑ai​)2logX)。 优化的技巧 计数问题的优化并不多，因为其具有「必须覆盖所有情况」的特点。在最优化问题中，我们可以通过某种条件进行剪枝，但是计数问题中减少状态和转移数量比较困难。 下面的一些技巧不止可以用在计数中。 前缀和 经典优化。 数据结构 计数问题中维护的信息很多和区间之和有关。大部分时候树状数组就够了，不过有些时候也需要线段树。在写数据结构之前，你应该想清楚这个 DP 的转移。 滚动数组 设 fi,jf_{i,j}fi,j​ 表示处理完前 iii 个，最后一个满足某个条件的是 jjj，这种 DP 可以通过滚动数组来加速。特别是对于从一组区间中选择一些这类问题，通常可以用这种方法加速。 AGC009C Division into Two 给定 nnn 个不同的整数 aia_iai​，求将它们分成两个集合 X,YX,YX,Y，并且 XXX 集合中任意两个数的差 ≥A\\ge A≥A，YYY 集合中任意两个数的差 ≥B\\ge B≥B 的方案数。1≤n≤1051\\le n\\le10^51≤n≤105，1≤A,B≤10181\\le A,B\\le10^{18}1≤A,B≤1018，0≤ai≤10180\\le a_i\\le10^{18}0≤ai​≤1018，ai&lt;ai+1a_i&lt;a_{i+1}ai​&lt;ai+1​。 题解 不妨 A&gt;BA&gt;BA&gt;B。设 fi,jf_{i,j}fi,j​ 表示处理完前 iii 个数，XXX 中最后一个数是第 jjj 个的方案数。考虑转移，假设从 jjj 转移而来，那么 ai−aj≥Aa_i-a_j\\ge Aai​−aj​≥A，且对于 k∈[j+1,i−2]k\\in[j+1,i-2]k∈[j+1,i−2]，ak+1−ak≥Ba_{k+1}-a_k\\ge Bak+1​−ak​≥B。因此 jjj 的范围是一个区间，把第一维压掉，前缀和优化即可。时间复杂度 O(n)O(n)O(n)。 FFT/NTT AGC005F Many Easy Problems 给定一棵无根树，定义 f(i)f(i)f(i) 为，对所有大小为 iii 的点集，能够包含它的最小连通块大小之和。对于 k∈[1,n]k\\in[1,n]k∈[1,n]，求 f(k)f(k)f(k)，对 924844033924844033924844033 取模。2≤n≤2×1052\\le n\\le2\\times10^52≤n≤2×105。 题解 之前得到了这样一个式子 ansk=n(nk)−∑i=1n∑v∈son⁡(i)(szvk)\\textit{ans}_k=n\\binom{n}{k}-\\sum_{i=1}^n\\sum_{v\\in\\operatorname{son}(i)}\\binom{\\textit{sz}_v}{k} ansk​=n(kn​)−i=1∑n​v∈son(i)∑​(kszv​​) 记 cnti\\textit{cnt}_icnti​ 表示 szv=i\\textit{sz}_v=iszv​=i 数量，对于每一种值分别计算，即 ansk=n(nk)−∑i=1ncnti(ik)=n(nk)−∑i=1ncntii!(i−k)!k!=n(nk)−1k!∑i=1ncntii!(i−k)!\\begin{aligned}\\textit{ans}_k&amp;=n\\binom{n}{k}-\\sum_{i=1}^n\\textit{cnt}_i\\binom{i}{k}\\\\&amp;=n\\binom{n}{k}-\\sum_{i=1}^n\\textit{cnt}_i\\frac{i!}{(i-k)!k!}\\\\&amp;=n\\binom{n}{k}-\\frac{1}{k!}\\sum_{i=1}^n\\frac{cnt_ii!}{(i-k)!}\\end{aligned} ansk​​=n(kn​)−i=1∑n​cnti​(ki​)=n(kn​)−i=1∑n​cnti​(i−k)!k!i!​=n(kn​)−k!1​i=1∑n​(i−k)!cnti​i!​​ 设 fi=cntii!f_i=\\textit{cnt}_ii!fi​=cnti​i!，gi=1(n−i)!g_i=\\dfrac{1}{(n-i)!}gi​=(n−i)!1​，则有 ansk=n(nk)−1k!∑i=1nfign−i+k\\textit{ans}_k=n\\binom{n}{k}-\\frac{1}{k!}\\sum_{i=1}^nf_ig_{n-i+k} ansk​=n(kn​)−k!1​i=1∑n​fi​gn−i+k​ 因此直接 NTT 计算卷积即可，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 快速 Zeta 变换（高维前缀和） 字面意思。 FMT/FWT 字面意思。 简单剪枝 主要用来减小常数。如果当前状态的数量是 000，可以直接不转移，这个在多维 DP 很有用。枚举状态的时候可以利用其他几个参数的值少枚举一些范围。 矩阵的技巧 有些计数问题可能和矩阵有关。 矩阵快速幂 如果有两个变量，一个是 10910^9109 级别，另一个是 100100100 级别，且大的那个表示「步数」，第 iii 步的信息可以由第 (i−1)(i-1)(i−1) 步的信息线性组合得到，那么可以考虑矩阵快速幂。 构造矩阵 矩阵快速幂的简单题通常只是用来加速 DP 的转移，但是有些情况构造矩阵很困难。 AGC013E Placing Squares 给出一个长度为 nnn 的木板，木板上有 mmm 个标记点，距离木板左端点的距离分别为 XiX_iXi​，现在你需要在木板上放置一些不相交的正方形，满足以下条件： 正方形的边长为整数。 正方形底面需要紧贴木板。 正方形不能超出木板，正方形要将所有的木板覆盖。 标记点的位置不能是两个正方形的交界处。 一种合法的正方形放置方案的贡献为所有正方形面积的乘积，即 ∏ai2\\prod a_i^2∏ai2​，其中 aia_iai​ 为正方形的边长。求出所有合法方案的贡献之和，答案对 109+710^9+7109+7 取模。1≤n≤1091\\le n\\le10^91≤n≤109，0≤m≤1050\\le m\\le10^50≤m≤105，1≤X1&lt;X2&lt;⋯&lt;Xm≤n−11\\le X_1&lt;X_2&lt;\\cdots&lt;X_m\\le n-11≤X1​&lt;X2​&lt;⋯&lt;Xm​≤n−1。 题解 考虑一个朴素的 DP，设 dpi\\textit{dp}_idpi​ 表示到第 iii 个位置的答案。如果第 iii 个位置是标记点，那么 dpi=0\\textit{dp}_i=0dpi​=0；否则，dpi=∑j&lt;idpj(i−j)2\\textit{dp}_i=\\sum_{j&lt;i}\\textit{dp}_j(i-j)^2dpi​=∑j&lt;i​dpj​(i−j)2。即使前缀和优化仍然是 O(n)O(n)O(n) 的，无法通过。 看到这个数据范围，考虑矩阵快速幂。显然有 dpi+1=∑j≤idpj(i+1−j)2=(∑j&lt;idpj(i+1−j)2)+dpi=(∑j&lt;idpj(i−j)2)+2(∑j&lt;idpj(i−j))+(∑j&lt;idpj)+dpi\\begin{aligned}\\textit{dp}_{i+1}&amp;=\\sum_{j\\le i}\\textit{dp}_j(i+1-j)^2\\\\&amp;=\\left(\\sum_{j&lt;i}\\textit{dp}_j(i+1-j)^2\\right)+\\textit{dp}_i\\\\&amp;=\\left(\\sum_{j&lt;i}\\textit{dp}_j(i-j)^2\\right)+2\\left(\\sum_{j&lt;i}\\textit{dp}_j(i-j)\\right)+\\left(\\sum_{j&lt;i}\\textit{dp}_j\\right)+\\textit{dp}_i\\end{aligned} dpi+1​​=j≤i∑​dpj​(i+1−j)2=(j&lt;i∑​dpj​(i+1−j)2)+dpi​=(j&lt;i∑​dpj​(i−j)2)+2(j&lt;i∑​dpj​(i−j))+(j&lt;i∑​dpj​)+dpi​​ 记三项分别为 fif_ifi​、gig_igi​ 和 hih_ihi​。 如果 iii 不是标记点，那么 dpi=fi\\textit{dp}_i=f_idpi​=fi​，因此 dpi+1=2fi+2gi+hi\\textit{dp}_{i+1}=2f_i+2g_i+h_idpi+1​=2fi​+2gi​+hi​，否则 dpi+1=fi+2gi+hi\\textit{dp}_{i+1}=f_i+2g_i+h_idpi+1​=fi​+2gi​+hi​。对于 g,hg,hg,h 的转移类似，可以发现都是线性组合，这里直接给出方程。 当 iii 不是标记点的时候，[figihi]×[211210111]=[fi+1gi+1hi+1]\\begin{bmatrix}f_i&amp;g_i&amp;h_i\\end{bmatrix}\\times\\begin{bmatrix}2&amp;1&amp;1\\\\2&amp;1&amp;0\\\\1&amp;1&amp;1\\end{bmatrix}=\\begin{bmatrix}f_{i+1}&amp;g_{i+1}&amp;h_{i+1}\\end{bmatrix}[fi​​gi​​hi​​]×⎣⎡​221​111​101​⎦⎤​=[fi+1​​gi+1​​hi+1​​]；否则 [figihi]×[100210111]=[fi+1gi+1hi+1]\\begin{bmatrix}f_i&amp;g_i&amp;h_i\\end{bmatrix}\\times\\begin{bmatrix}1&amp;0&amp;0\\\\2&amp;1&amp;0\\\\1&amp;1&amp;1\\end{bmatrix}=\\begin{bmatrix}f_{i+1}&amp;g_{i+1}&amp;h_{i+1}\\end{bmatrix}[fi​​gi​​hi​​]×⎣⎡​121​011​001​⎦⎤​=[fi+1​​gi+1​​hi+1​​]。处理一下初始状态即可。时间复杂度 O(mlog⁡n)O(m\\log n)O(mlogn)。 常系数齐次线性递推 如果转移可以表示成线性递推的形式，即 Ai=∑i=1kciAn−iA_i=\\sum_{i=1}^kc_iA_{n-i}Ai​=∑i=1k​ci​An−i​，暴力计算矩阵快速幂的复杂度是 O(k3log⁡n)O(k^3\\log n)O(k3logn) 的，但是可以降到 O(k2log⁡n)O(k^2\\log n)O(k2logn)，如果用 FFT 则可以做到 O(klog⁡klog⁡n)O(k\\log k\\log n)O(klogklogn)。具体实现方法可以看【模板】常系数齐次线性递推 题解。 多项式的幂 这一部分会在前面的基础上描述进一步的加速方法。 假设 DP 的转移可以被看作乘上一个多项式，即存在一个序列 AAA 满足 fn,k=∑i=0kAk−ifn−1,if_{n,k}=\\sum_{i=0}^kA_{k-i}f_{n-1,i}fn,k​=∑i=0k​Ak−i​fn−1,i​，那么可以使用 FFT。 重复执行这个操作无非是找到多项式 ∑Aixi\\sum A_ix^i∑Ai​xi 的幂。如果你 FFT 之后对于每个点值直接求幂，是错误的，因为转移的时候你需要「截断」，否则循环卷积会造成错误，所以要每次计算卷积之后清空后面一段。共需 O(log⁡n)O(\\log n)O(logn) 次 FFT。 行列式的技巧 很少有计数问题可以通过行列式来解决，大多数这类问题都是基于定理的。所以只需要记住矩阵树定理和 LGV 引理。 忽略小概率 当计算概率期望的时候，如果出题人让你输出实数，你可以直接忽略概率非常小的情况。 Aizu1056 Ben Toh 求进行以下操作 nnn 次后的期望得分： 当你现在连续得分为 kkk 时，你有 2−k2^{-k}2−k 的概率得到 111 分，1−2−k1-2^{-k}1−2−k 的概率不得分。 1≤n≤1051\\le n\\le10^51≤n≤105。允许精度误差 10−210^{-2}10−2。 题解 设 fi,jf_{i,j}fi,j​ 表示 iii 次操作，连续得分为 jjj 的期望得分，然后发现 jjj 比较大的时候概率几乎为 000，所以取一个上限 lim\\textit{lim}lim 就行了，时间复杂度 O(n×lim)O(n\\times\\textit{lim})O(n×lim)。 组合数的技巧 常见公式 通常一些组合数的和/积可以用更简洁的形式来表示。下面列出了一些典型的组合恒等式。 ∑i=0n(ni)=2n\\sum_{i=0}^n\\dbinom{n}{i}=2^n∑i=0n​(in​)=2n ∑i=0⌊n/2⌋(n2i)=2n−1\\sum_{i=0}^{\\lfloor{n/2}\\rfloor}\\dbinom{n}{2i}=2^{n-1}∑i=0⌊n/2⌋​(2in​)=2n−1 ∑i=0k(n+ii)=(n+k+1k)\\sum_{i=0}^k\\dbinom{n+i}{i}=\\dbinom{n+k+1}{k}∑i=0k​(in+i​)=(kn+k+1​) ∑i=0k∑j=0l(i+jj)=(k+l+2k+1)\\sum_{i=0}^k\\sum_{j=0}^l\\dbinom{i+j}{j}=\\dbinom{k+l+2}{k+1}∑i=0k​∑j=0l​(ji+j​)=(k+1k+l+2​) ∑i=0k(ni)(mk−i)=(n+mk)\\sum_{i=0}^k\\dbinom{n}{i}\\dbinom{m}{k-i}=\\dbinom{n+m}{k}∑i=0k​(in​)(k−im​)=(kn+m​) ∑i=0k(n+ii)(m−ik−i)=(n+m+1k)\\sum_{i=0}^k\\dbinom{n+i}{i}\\dbinom{m-i}{k-i}=\\dbinom{n+m+1}{k}∑i=0k​(in+i​)(k−im−i​)=(kn+m+1​) 回归路径计数 通过使用杨辉三角和网格图路径数进行推导，上一节中描述的转换变得更容易了。通常，通过定义公式来变换组合数并不是一个好主意。 为了避免复杂的公式转换，在推导时最好考虑减少路径的数量，因为它的计算量很大。下一节将讨论这种特殊情况。 AGC001E BBQ Hard 给出 nnn 个二元组 (ai,bi)(a_i,b_i)(ai​,bi​)，求 ∑i=1n∑j=i+1n(ai+bi+aj+bjai+aj)\\sum_{i=1}^n\\sum_{j=i+1}^n\\binom{a_i+b_i+a_j+b_j}{a_i+a_j} i=1∑n​j=i+1∑n​(ai​+aj​ai​+bi​+aj​+bj​​) 答案对 109+710^9+7109+7 取模，2≤n≤2×1052\\le n\\le2\\times10^52≤n≤2×105，1≤ai,bi≤20001\\le a_i,b_i\\le20001≤ai​,bi​≤2000。 题解 注意到 nnn 很大而值域很小，因此考虑将组合数变到值域上去。利用网格图的数量，问题转化成对所有点对之间路径计数。但是计算还是很困难，因为我们需要对于每一对 i,ji,ji,j 求 f(ai+aj,bi+bj)f(a_i+a_j,b_i+b_j)f(ai​+aj​,bi​+bj​)。考虑将其分离，变成 (−ai,−bi)(-a_i,-b_i)(−ai​,−bi​) 走到 (aj,bj)(a_j,b_j)(aj​,bj​) 的方案数，这样预处理的时候直接将所有 (−ai,−bi)(-a_i,-b_i)(−ai​,−bi​) 赋值成 111 然后转移。此时 f(x,y)f(x,y)f(x,y) 的定义变成了所有 (−ai,−bi)(-a_i,-b_i)(−ai​,−bi​) 走到 (x,y)(x,y)(x,y) 的方案数之和。最后减去 (−ai,−bi)(-a_i,-b_i)(−ai​,−bi​) 到 (ai,bi)(a_i,b_i)(ai​,bi​) 的方案数然后除以 222 即可。时间复杂度 O(((max⁡ai)+(max⁡bi))2+n)O(((\\max a_i)+(\\max b_i))^2+n)O(((maxai​)+(maxbi​))2+n)。 旋转坐标系 在网格中上下左右移动是常见的题目，在这种情况下，将坐标轴旋转 45°45\\degree45° 可以把两维分开处理。 ARC012D Don't worry. Be Together 有 nnn 个人在一个二维平面上，第 iii 个人在 (xi,yi)(x_i,y_i)(xi​,yi​)。每一轮，所有人向上下左右之一移动一步。求 TTT 轮后所有人都在原点的方案数，对给出的模数 mod\\textit{mod}mod 取模。1≤n,T≤1051\\le n,T\\le10^51≤n,T≤105，1≤mod≤109+71\\le\\textit{mod}\\le10^9+71≤mod≤109+7，−106≤xi,yi≤106-10^6\\le x_i,y_i\\le10^6−106≤xi​,yi​≤106。不保证 mod\\textit{mod}mod 是质数。 题解 将坐标轴旋转 45°45\\degree45° 后，走一步相当于两维分别选择加一/减一，这样就互相独立。转化成一个数，每次加一或减一，求 TTT 次之后变成 000 的方案数。对于一个人，方案数显然是 (Tx+T2)(Ty+T2)\\dbinom{T}{\\frac{x+T}{2}}\\dbinom{T}{\\frac{y+T}{2}}(2x+T​T​)(2y+T​T​)。但是你需要对一个不是质数的数取模，因此需要对每一个 pkp^kpk 次做一遍然后中国剩余定理合并。 卡特兰数 有很多题目的答案就是卡特兰数，或者可以用卡特兰数表示。 从 (0,0)(0,0)(0,0) 走到 (n,n)(n,n)(n,n)，每次只能往右或往上走，不越过直线 y=xy=xy=x 的方案数。 长度为 2n2n2n 的合法括号序列数量。 多边形的三角划分数量。 nnn 个结点的二叉树数量。 表达式为 (2nn)−(2nn−1)=1n+1(2nn)\\dbinom{2n}{n}-\\dbinom{2n}{n-1}=\\dfrac{1}{n+1}\\dbinom{2n}{n}(n2n​)−(n−12n​)=n+11​(n2n​)。 容斥原理 如果无法将给出的条件分成几个部分分别计算答案，那么可以考虑容斥原理。 使用对称性 如果满足 nnn 个条件中任意 kkk 个的情况数是相同的，那么可以用 O(n)O(n)O(n) 时间对每一个 kkk 分别计算。 AGC005D ~K Perm Counting 求有多少个排列 ppp 满足 ∣pi−i∣≠k|p_i-i|\\ne k∣pi​−i∣​=k。2≤n≤20002\\le n\\le20002≤n≤2000，1≤k≤n−11\\le k\\le n-11≤k≤n−1。 题解 考虑容斥，设 fif_ifi​ 表示钦定 iii 个位置满足 ∣pi−i∣=k|p_i-i|=k∣pi​−i∣=k 的方案数，那么答案就是 ∑i=0n(−1)ifi\\sum_{i=0}^n(-1)^if_i∑i=0n​(−1)ifi​。建一个二分图，把 iii 往 pi+kp_{i+k}pi+k​ 和 pi−kp_{i-k}pi−k​ 连边，这样会形成若干条链。如果链上一条边被选，表示将一个点赋值为这个值。因此对每一条链进行 DP，然后做背包即可求出 fif_ifi​。时间复杂度 O(n2)O(n^2)O(n2)，可以进一步优化到 O(nlog⁡n)O(n\\log n)O(nlogn)。 使用 DP n×mn\\times mn×m 的网格上有 kkk 个障碍 (xi,yi)(x_i,y_i)(xi​,yi​)，每次只能往右或往下走，求有多少种方案从 (1,1)(1,1)(1,1) 走到 (n,m)(n,m)(n,m) 且不经过障碍。n,m≤105n,m\\le10^5n,m≤105，k≤2000k\\le2000k≤2000。 题解 把最后一个格子也看作障碍。将所有障碍按照 xxx 坐标排序。根据容斥，答案就是钦定经过偶数个障碍的方案数减去经过奇数个的方案数。设 fi,0/1f_{i,0/1}fi,0/1​ 表示在第 iii 个障碍，钦定经过障碍数量为偶数/奇数个的方案数。转移的时候枚举前一个障碍即可。时间复杂度 O(k2)O(k^2)O(k2)。 因子容斥 假如我们要求的内容是某个变量是 kkk 的倍数或某个变量是 kkk 的因子的方案数，那么也可以容斥。 先考虑前一个问题。 给出 nnn 个数 aia_iai​，求 aaa 的 (2n−1)(2^n-1)(2n−1) 个子集的最大公因数之和。1≤n,ai≤1051\\le n,a_i\\le10^51≤n,ai​≤105。 题解 对于给出的 xxx，很容易求出最大公因数是 xxx 的倍数的集合数量。然后枚举 xxx 的倍数，减掉这些情况即可。时间复杂度 O(mln⁡m)O(m\\ln m)O(mlnm)，其中 m=max⁡aim=\\max a_im=maxai​。 考虑第二个问题。 ARC064F Rotated Palindromes 高桥和青木想要一起造一个数列。首先，高桥会造出一个长度为 nnn，每个元素值域为 [1,k][1,k][1,k] 的回文数列 aaa。然后，青木会进行任意多次以下操作：把 aaa 中的第一个元素移到最后。求一共可以得到多少种本质不同的数列。1≤n,k≤1091\\le n,k\\le10^91≤n,k≤109。 题解 如果对最后得到的数列计数，没有办法很好得判断一个序列能否由回文序列变化而来，因此考虑容斥使原序列的贡献不重复。对于一个序列，设其最小循环节长度为 kkk。如果 kkk 为奇数，那么可以生成 kkk 种不同的序列，否则可以生成 k/2k/2k/2 种不同的序列。并且这个循环节肯定也是回文的。于是对 nnn 的每一个因子 did_idi​ 求答案，减去 did_idi​ 所有因子的情况即可。时间复杂度 O(n+d(n)2)O(\\sqrt{n}+d(n)^2)O(n​+d(n)2)。 识别「不可做题」 思考题目的过程有时会把我们引向一个更普遍的计数问题。如果你最终得到了一个（被认为）无法计数的问题，你应该避免在上面浪费时间。因此，知道哪些问题不可计数是很重要的。 以下问题不能在多项式时间内解决： 2-SAT 的合法解数量。 二分图匹配和一般图匹配数量。 矩阵的积和式。 图的拓扑排序数量。 欧拉回路数量。 当然有些特殊情况下是可以计数的，取决于题目给出的特殊性质。 ","link":"http://xyf007.ml/post/xue-xi-bi-ji-ji-shu-wen-ti-zong-jie/"},{"title":"NOIP2021 游记","content":"小丑之王 Day0 复习各种板子和之前做过的题目，晚上写了一下最小表示法，恰逢洛谷日爆，连交 45 发没过，rp++（确信）。然后在 21:00 之前上床睡觉以获得充足睡眠。 Day1 由于上次 CSP 只有两瓶水不够喝，于是我带了 四 瓶水。一进场发现自己的电脑是 Windows 系统，心 肺 停 止。旁边还有几个同学也是 Linux 分到 Windows 考场，赶紧去找老师。到楼上办公室，陆陆续续来了大概 10 个同学都是变成了 Windows 系统。工作人员说备用机位有，但是我们都是 XJ 的，必须间隔坐，这样就坐不下。于是 devin 先问哪些人一定要用 Linux 的，我想了一下 Windows 下有 vscode 就没说，后面点了几个有冲省队水平的用 Linux，剩下的就 Windows，导致又我回 Windows 考场。这时候是 8:29，离比赛开始还有 1 分钟。 结果比赛开始了我还没有解压题目。开始两三分钟大脑相当混乱，于是喝水来冷静。看完 T1 发现 n=107n=10^7n=107，只能想到 O(nlog⁡10n+nln⁡n+Tlog⁡T)O(n\\log_{10}n+n\\ln n+T\\log T)O(nlog10​n+nlnn+TlogT) 的做法，感觉有点危，但是巨大跑不满，打算先写个试看看。刚开始写就意识到可以 O(n)O(n)O(n) 预处理包含 7 的数，写完一测，发现自己 不会在 Windows 下计时，也完全忘记可以用 Dev，肉眼计时大概不会超。看了一眼大样例很强，边界都在里面就扔了。一看才 9:00，差不多冷静下来了。于是狂暴喝水并去 WC。 然后开 T2，读完题感觉差不多就会了，直接 DP 每一个 2i2^i2i 的数量就行，一算复杂度巨大正确，草稿纸上写了一下状态和转移就开始写，写完修一个 typo 就过样例了。这时候是 9:30，感觉这场巨大简单，怕不是人均阿克（flag1）。继续狂暴喝水并去 WC。 看完 T3 意识到大概是差分前缀和有关，尝试了一下意识到是随意交换差分数组，把方差式子拆出来，然后不会了。于是去研究了一下 T4 的题意，读懂之后知道是大数据结构，什么勾八玩意，显然回去搞 T3。尝试猜差分数组的性质，使劲感受了一下，类似邻项交换的方式，应该是让中间一大堆数都差不多，两边的数差别大一点，也就是说差分数组可能是单谷的。于是试图写一个退火来证明，然而退火不熟，写完发现小样例都能错。研究了一下发现把大于号小于号打反了，温度越低越容易接受错解。改完就能稳定过掉第二个样例，但是第三个样例大概率退不出来。狂暴调参并且让它初始获得一个比较优的状态，终于可以大概率跑出第三个样例了。中途继续狂暴喝水并去 WC。 这时候就猜到正解应该是 DP，然而我不会设计状态。突然意识到 n=20n=20n=20 的时候可以直接 O(2nn)O(2^nn)O(2nn) 从大到小枚举每个放在左边还是右边，再拼上退火大概是 60 分。又想了一下退火太蠢了，应该直接随机每个放在左边还是右边，一测可以稳定通过第三个样例，但是这样还是只有 60 分。突然我意识到值域很小，也就是说 差分数组有巨大多数量相同的数字！这样直接枚举每一种数在左边和右边的数量就行了，大概是关于值域亚指数级别的，这样就有 84。赶紧码，然后把最后一次枚举最小的数删掉，发现稳定通过 100100100 和 100001000010000 的包，400400400 完全跑不动。然后观察一下差分数组发现每种数左右差不多，于是直接从 cnt2−3\\dfrac{\\textit{cnt}}{2}-32cnt​−3 枚举到 cnt2+3\\dfrac{\\textit{cnt}}{2}+32cnt​+3，信仰 CCF 数据不可能把我卡成 WA。这时候大样例大概 0.9 s0.9\\mathrm{\\,s}0.9s，又随机了几组发现有的飞快有的跑不出来，放弃挣扎。这时候是 11:45，还有 1 h 15 min1\\mathrm{\\,h\\,}15\\mathrm{\\,min}1h15min。当前估分 284∼300284\\sim300284∼300。这时候快要喝完两瓶多水了，继续去 WC。 先检查了一下前两题，再看 T4，嘴巴了一个离线倒序处理，并查集+线段树合并维护的做法。想到前两题无比简单，大概人均 200；T3 差分和拆方差很套路，性质也很显然，大概人均会 DP，只有我写乱搞拿不到满分，于是决定去冲正解（flag2）。显然没有写完，最后 10 分钟试图写 8 分结果读进来就 RE 了。有兴趣的可以看看我 150 行的注释。 估分 100+100+[84,100]+0=[284,300]100+100+[84,100]+0=[284,300]100+100+[84,100]+0=[284,300]，出来一问发现人均写了 T4 暴力，巨大多人没有看出 T3 的单谷，顿感血亏，小丑之王属于是了。之后在各个地方民间数据都是 284，ZJ 排名 50 左右。大概是退役了 吗？ 感谢 zjc 造出了比随机数据更弱的数据直接把我送到 300，然而队线 332，就差 T4 暴力 /fn，可能还能苟一段时间。还是对比赛把握不准确，没能打到最完美的分数。 后来意识到可能是场上机子大概比真实情况慢 3~5 倍，所以可能确实能过 T3。 进场前同学奶我喝一瓶水切一道题，场上喝完了三瓶，过了前三题（ ","link":"http://xyf007.ml/post/noip2021-you-ji/"},{"title":"【模板】最小表示法","content":"#include &lt;cstring&gt; #include &lt;iostream&gt; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } int n, a[600001]; int Lmsr() { // Lexicographically minimal string rotation int i = 1, j = 2, k = 0; while (i &lt;= n &amp;&amp; j &lt;= n &amp;&amp; k &lt;= n) if (a[i + k] == a[j + k]) { k++; } else { if (a[i + k] &gt; a[j + k]) i += k + 1; else j += k + 1; if (i == j) i++; k = 0; } return std::min(i, j); } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; std::memcpy(a + n + 1, a + 1, 4 * n); int p = Lmsr(); for (int i = p; i &lt; p + n; i++) std::cout &lt;&lt; a[i] &lt;&lt; ' '; return 0; } ","link":"http://xyf007.ml/post/mu-ban-zui-xiao-biao-shi-fa/"},{"title":"【模板】Min_25 筛","content":"求解积性函数前缀和的另一种做法。 要求质数处的 F(p)F(p)F(p) 值是关于 ppp 的多项式，质数次方处 F(pi)F(p^i)F(pi) 的值可以快速计算。常见实现是 O(n1−ϵ)O(n^{1-\\epsilon})O(n1−ϵ) 的，但是常数极小；经过优化可以做到 O(n34log⁡n)O\\left(\\dfrac{n^{\\frac{3}{4}}}{\\log n}\\right)O(lognn43​​)。一般 n≤1010n\\le10^{10}n≤1010。 定义 P\\mathbf{P}P 表示质数集，pip_ipi​ 表示第 iii 个质数，lpf⁡(i)\\operatorname{lpf}(i)lpf(i) 表示 iii 的最小质因子。 首先将这个多项式拆成若干个单项式之和，那么问题变成求出 F(p)=pkF(p)=p^kF(p)=pk 的前缀和。 设 S(n,j)S(n,j)S(n,j) 表示 lpf⁡(i)&gt;pj\\operatorname{lpf}(i)&gt;p_jlpf(i)&gt;pj​ 的 F(i)F(i)F(i) 之和，那么答案就是 S(n,0)+1S(n,0)+1S(n,0)+1。将其分成质数和合数分别计算。记 G(n)G(n)G(n) 表示 111 到 nnn 中所有质数的 kkk 次方和，枚举所有合数的最小质因子，那么有 S(n,j)=G(n)−∑i=1jF(pi)+∑pke≤n,k&gt;jF(pke)(S(⌊npke⌋,k)+[e≠1])S(n,j)=G(n)-\\sum_{i=1}^jF(p_i)+\\sum_{p_k^e\\le n,k&gt;j}F(p_k^e)\\left(S\\left(\\left\\lfloor\\dfrac{n}{p_k^e}\\right\\rfloor,k\\right)+[e\\ne1]\\right) S(n,j)=G(n)−i=1∑j​F(pi​)+pke​≤n,k&gt;j∑​F(pke​)(S(⌊pke​n​⌋,k)+[e​=1]) 注意这里枚举的是最小质因子，因此 pk≤np_k\\le\\sqrt{n}pk​≤n​。 考虑计算 G(n)G(n)G(n)。设一个函数 ggg 满足以下条件 g(n,j)=∑i∈P or lpf⁡(i)&gt;pjikg(n,j)=\\sum_{i\\in\\mathbf{P}\\text{ or }\\operatorname{lpf}(i)&gt;p_j}i^k g(n,j)=i∈P or lpf(i)&gt;pj​∑​ik 这里 iki^kik 是一个在质数处与 F(p)F(p)F(p) 相等的完全积性函数，具有良好的性质。那么 G(n)=g(n,x)G(n)=g(n,x)G(n)=g(n,x)，其中 xxx 满足是 px≤np_x\\le npx​≤n 的最大的数。从 g(n,j−1)g(n,j-1)g(n,j−1) 转移而来的时候，只有 lpf⁡(i)=pj\\operatorname{lpf}(i)=p_jlpf(i)=pj​ 的合数会变得不合法。由于 iki^kik 是完全积性函数，可以提出一个 pjkp_j^kpjk​，即 g(n,j)=g(n,j−1)−pjk(g(⌊npj⌋,j−1)−g(pj−1,j−1))g(n,j)=g(n,j-1)-p_j^k\\left(g\\left(\\left\\lfloor\\frac{n}{p_j}\\right\\rfloor,j-1\\right)-g(p_{j-1},j-1)\\right) g(n,j)=g(n,j−1)−pjk​(g(⌊pj​n​⌋,j−1)−g(pj−1​,j−1)) 后面是为了除去 lpf⁡\\operatorname{lpf}lpf 为质数的情况的答案。同理这里 pjp_jpj​ 也是 ≤n\\le\\sqrt{n}≤n​，因此后面部分可以直接线性筛。 可以发现所有式子中有用的位置都是 ⌊nx⌋\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor⌊xn​⌋ 的形式，共 O(n)O(\\sqrt{n})O(n​) 项，可以用 O(n)O(\\sqrt{n})O(n​) 的空间来存储。 代码是洛谷例题，F(pi)=(pi)2−piF(p^i)=(p^i)^2-p^iF(pi)=(pi)2−pi。 #include &lt;cmath&gt; #include &lt;iostream&gt; constexpr int kMod = 1e9 + 7, kInv2 = 500000004, kInv6 = 166666668; template &lt;typename T&gt; T add(T a, T b) { return (a + b) % kMod; } template &lt;typename T, typename... Args&gt; T add(T a, T b, Args... args) { return add(add(a, b), args...); } template &lt;typename T&gt; T sub(T a, T b) { return (a + kMod - b) % kMod; } template &lt;typename T, typename... Args&gt; T sub(T a, T b, Args... args) { return sub(sub(a, b), args...); } template &lt;typename T&gt; T mul(T a, T b) { return a * static_cast&lt;long long&gt;(b) % kMod; } template &lt;typename T, typename... Args&gt; T mul(T a, T b, Args... args) { return mul(mul(a, b), args...); } template &lt;typename T&gt; void Add(T &amp;a, T b) { a = add(a, b); } template &lt;typename T, typename... Args&gt; void Add(T &amp;a, T b, Args... args) { Add(a, add(b, args...)); } template &lt;typename T&gt; void Sub(T &amp;a, T b) { a = sub(a, b); } template &lt;typename T, typename... Args&gt; void Sub(T &amp;a, T b, Args... args) { Sub(a, add(b, args...)); } template &lt;typename T&gt; void Mul(T &amp;a, T b) { a = mul(a, b); } template &lt;typename T, typename... Args&gt; void Mul(T &amp;a, T b, Args... args) { Mul(a, mul(b, args...)); } template &lt;typename T1, typename T2&gt; T1 Ksm(T1 a, T2 b) { T1 s = 1; while (b) { if (b &amp; 1) Mul(s, a); Mul(a, a); b &gt;&gt;= 1; } return s; } template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } long long n, w[200001]; int lim, ind1[100001], ind2[100001], tot, p[100001], sp1[100001], sp2[100001], tot2, g1[200001], g2[200001]; bool np[100001]; void Init(int n) { np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) { p[++tot] = i; sp1[tot] = add(sp1[tot - 1], i), sp2[tot] = add(sp2[tot - 1], mul(i, i)); } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; j++) { np[i * p[j]] = true; if (i % p[j] == 0) break; } } } inline int GetId(long long x) { return x &lt;= lim ? ind1[x] : ind2[n / x]; } int S(long long n, int x) { if (p[x] &gt;= n) return 0; int id = GetId(n), ans = sub(sub(g2[id], sp2[x]), sub(g1[id], sp1[x])); for (int k = x + 1; k &lt;= tot &amp;&amp; 1LL * p[k] * p[k] &lt;= n; k++) { long long pe = p[k]; for (int e = 1; pe &lt;= n; e++, pe *= p[k]) { int s = pe % kMod; Add(ans, mul(s, s - 1, S(n / pe, k) + (e != 1))); } } return ans; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n, lim = std::sqrt(n), Init(lim); for (long long l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); w[++tot2] = n / l; int x = w[tot2] % kMod; g1[tot2] = mul(x, x + 1, kInv2) - 1; g2[tot2] = mul(x, x + 1, 2 * x + 1, kInv6) - 1; (w[tot2] &lt;= lim ? ind1[w[tot2]] : ind2[n / w[tot2]]) = tot2; } for (int j = 1; j &lt;= tot; j++) { for (int i = 1; i &lt;= tot2 &amp;&amp; 1LL * p[j] * p[j] &lt;= w[i]; i++) { int k = GetId(w[i] / p[j]); Sub(g1[i], mul(p[j], sub(g1[k], sp1[j - 1]))); Sub(g2[i], mul(p[j], p[j], sub(g2[k], sp2[j - 1]))); } } std::cout &lt;&lt; S(n, 0) + 1; return 0; } ","link":"http://xyf007.ml/post/mu-ban-min_25-shai/"},{"title":"【模板】类欧几里德算法","content":"求以下三个式子的值 f(a,b,c,n)=∑i=0n⌊ai+bc⌋g(a,b,c,n)=∑i=0ni⌊ai+bc⌋h(a,b,c,n)=∑i=0n⌊ai+bc⌋2\\begin{aligned}f(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\\\g(a,b,c,n)&amp;=\\sum_{i=0}^ni\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\\\h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor^2\\end{aligned} f(a,b,c,n)g(a,b,c,n)h(a,b,c,n)​=i=0∑n​⌊cai+b​⌋=i=0∑n​i⌊cai+b​⌋=i=0∑n​⌊cai+b​⌋2​ 先考虑求 fff。a=0a=0a=0 时就是 (n+1)⌊bc⌋(n+1)\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor(n+1)⌊cb​⌋。如果 a≥ca\\ge ca≥c 或 b≥cb\\ge cb≥c，那么有 f(a,b,c,n)=∑i=0n⌊(⌊ac⌋c+a mod c)i+(⌊bc⌋c+b mod c)c⌋=n(n+1)2⌊ac⌋+(n+1)⌊bc⌋+f(a mod c,b mod c,c,n)\\begin{aligned}f(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{\\left(\\left\\lfloor\\frac{a}{c}\\right\\rfloor c+a\\bmod c\\right)i+\\left(\\left\\lfloor\\frac{b}{c}\\right\\rfloor c+b\\bmod c\\right)}{c}\\right\\rfloor\\\\&amp;=\\frac{n(n+1)}{2}\\left\\lfloor\\frac{a}{c}\\right\\rfloor+(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor+f(a\\bmod c,b\\bmod c,c,n)\\end{aligned} f(a,b,c,n)​=i=0∑n​⌊c(⌊ca​⌋c+amodc)i+(⌊cb​⌋c+bmodc)​⌋=2n(n+1)​⌊ca​⌋+(n+1)⌊cb​⌋+f(amodc,bmodc,c,n)​ 问题转化为 a&lt;ca&lt;ca&lt;c 且 b&lt;cb&lt;cb&lt;c 的情况。考虑枚举 ⌊ai+bc⌋\\left\\lfloor\\dfrac{ai+b}{c}\\right\\rfloor⌊cai+b​⌋ 的值然后统计贡献。设 m=⌊an+bc⌋m=\\left\\lfloor\\dfrac{an+b}{c}\\right\\rfloorm=⌊can+b​⌋，可得 f(a,b,c,n)=∑j=0m−1∑i=0n[⌊ai+bc⌋&gt;j]f(a,b,c,n)=\\sum_{j=0}^{m-1}\\sum_{i=0}^n\\left[\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor&gt;j\\right] f(a,b,c,n)=j=0∑m−1​i=0∑n​[⌊cai+b​⌋&gt;j] 又 ⌊ai+bc⌋&gt;j ⟺ ⌊ai+bc⌋≥j+1 ⟺ ai+b≥cj+c ⟺ i&gt;⌊cj+c−b−1a⌋\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor&gt;j\\iff\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\ge j+1\\iff ai+b\\ge cj+c\\iff i&gt;\\left\\lfloor\\frac{cj+c-b-1}{a}\\right\\rfloor ⌊cai+b​⌋&gt;j⟺⌊cai+b​⌋≥j+1⟺ai+b≥cj+c⟺i&gt;⌊acj+c−b−1​⌋ 所以 f(a,b,c,n)=∑j=0m−1(n−⌊cj+c−b−1a⌋)=nm−f(c,c−b−1,a,m−1)\\begin{aligned}f(a,b,c,n)&amp;=\\sum_{j=0}^{m-1}\\left(n-\\left\\lfloor\\frac{cj+c-b-1}{a}\\right\\rfloor\\right)\\\\&amp;=nm-f(c,c-b-1,a,m-1)\\end{aligned} f(a,b,c,n)​=j=0∑m−1​(n−⌊acj+c−b−1​⌋)=nm−f(c,c−b−1,a,m−1)​ 复杂度同辗转相除法。 求解 g,hg,hg,h 过程相似。 当 a=0a=0a=0 时，g(a,b,c,n)=n(n+1)2⌊bc⌋g(a,b,c,n)=\\dfrac{n(n+1)}{2}\\left\\lfloor\\dfrac{b}{c}\\right\\rfloorg(a,b,c,n)=2n(n+1)​⌊cb​⌋。如果 a≥ca\\ge ca≥c 或 b≥cb\\ge cb≥c，那么有 g(a,b,c,n)=∑i=0ni⌊(⌊ac⌋c+a mod c)i+(⌊bc⌋c+b mod c)c⌋=n(n+1)(2n+1)6⌊ac⌋+n(n+1)2⌊bc⌋+g(a mod c,b mod c,c,n)\\begin{aligned}g(a,b,c,n)&amp;=\\sum_{i=0}^ni\\left\\lfloor\\frac{\\left(\\left\\lfloor\\frac{a}{c}\\right\\rfloor c+a\\bmod c\\right)i+\\left(\\left\\lfloor\\frac{b}{c}\\right\\rfloor c+b\\bmod c\\right)}{c}\\right\\rfloor\\\\&amp;=\\frac{n(n+1)(2n+1)}{6}\\left\\lfloor\\frac{a}{c}\\right\\rfloor+\\frac{n(n+1)}{2}\\left\\lfloor\\frac{b}{c}\\right\\rfloor+g(a\\bmod c,b\\bmod c,c,n)\\end{aligned} g(a,b,c,n)​=i=0∑n​i⌊c(⌊ca​⌋c+amodc)i+(⌊cb​⌋c+bmodc)​⌋=6n(n+1)(2n+1)​⌊ca​⌋+2n(n+1)​⌊cb​⌋+g(amodc,bmodc,c,n)​ 否则 g(a,b,c,n)=∑j=0m−1∑i=0ni[⌊ai+bc⌋&gt;j]=∑j=0m−1∑i=0ni[i&gt;⌊cj+c−b−1a⌋]\\begin{aligned}g(a,b,c,n)&amp;=\\sum_{j=0}^{m-1}\\sum_{i=0}^ni\\left[\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor&gt;j\\right]\\\\&amp;=\\sum_{j=0}^{m-1}\\sum_{i=0}^ni\\left[i&gt;\\left\\lfloor\\frac{cj+c-b-1}{a}\\right\\rfloor\\right]\\end{aligned} g(a,b,c,n)​=j=0∑m−1​i=0∑n​i[⌊cai+b​⌋&gt;j]=j=0∑m−1​i=0∑n​i[i&gt;⌊acj+c−b−1​⌋]​ 令 t=⌊cj+c−b−1a⌋t=\\left\\lfloor\\dfrac{cj+c-b-1}{a}\\right\\rfloort=⌊acj+c−b−1​⌋，那么有 g(a,b,c,n)=∑j=0m−1((t+1)+⋯+n)=∑j=0m−1(n+t+1)(n−t)2=12mn(n+1)−12f(c,c−b−1,a,m−1)−12h(c,c−b−1,a,m−1)\\begin{aligned}g(a,b,c,n)&amp;=\\sum_{j=0}^{m-1}((t+1)+\\cdots+n)\\\\&amp;=\\sum_{j=0}^{m-1}\\frac{(n+t+1)(n-t)}{2}\\\\&amp;=\\frac{1}{2}mn(n+1)-\\frac{1}{2}f(c,c-b-1,a,m-1)-\\frac{1}{2}h(c,c-b-1,a,m-1)\\end{aligned} g(a,b,c,n)​=j=0∑m−1​((t+1)+⋯+n)=j=0∑m−1​2(n+t+1)(n−t)​=21​mn(n+1)−21​f(c,c−b−1,a,m−1)−21​h(c,c−b−1,a,m−1)​ 当 a=0a=0a=0 时，h(a,b,c,n)=(n+1)⌊bc⌋2h(a,b,c,n)=(n+1)\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor^2h(a,b,c,n)=(n+1)⌊cb​⌋2。如果 a≥ca\\ge ca≥c 或 b≥cb\\ge cb≥c，那么有 h(a,b,c,n)=∑i=0n⌊(⌊ac⌋+a mod c)i+(⌊bc⌋+b mod c)c⌋=∑i=0n(⌊ac⌋i+⌊bc⌋+⌊(a mod c)i+(b mod c)c⌋)2=∑i=0n(⌊ac⌋2i2+⌊bc⌋2+⌊(a mod c)i+(b mod c)c⌋2+2⌊ac⌋⌊bc⌋i+2⌊ac⌋⌊(a mod c)i+(b mod c)c⌋i+2⌊bc⌋⌊(a mod c)i+(b mod c)c⌋)=n(n+1)(2n+1)6⌊ac⌋2+(n+1)⌊bc⌋2+h(a mod c,b mod c,c,n)+n(n+1)⌊ac⌋⌊bc⌋+2⌊ac⌋g(a mod c,b mod c,c,n)+2⌊bc⌋f(a mod c,b mod c,c,n)\\begin{aligned}h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left\\lfloor\\frac{\\left(\\left\\lfloor\\frac{a}{c}\\right\\rfloor+a\\bmod c\\right)i+\\left(\\left\\lfloor\\frac{b}{c}\\right\\rfloor+b\\bmod c\\right)}{c}\\right\\rfloor\\\\&amp;=\\sum_{i=0}^n\\left(\\left\\lfloor\\frac{a}{c}\\right\\rfloor i+\\left\\lfloor\\frac{b}{c}\\right\\rfloor+\\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor\\right)^2\\\\&amp;=\\sum_{i=0}^n\\left(\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2i^2+\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2+\\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor^2+2\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor i+2\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor i+2\\left\\lfloor\\frac{b}{c}\\right\\rfloor\\left\\lfloor\\frac{(a\\bmod c)i+(b\\bmod c)}{c}\\right\\rfloor\\right)\\\\&amp;=\\frac{n(n+1)(2n+1)}{6}\\left\\lfloor\\frac{a}{c}\\right\\rfloor^2+(n+1)\\left\\lfloor\\frac{b}{c}\\right\\rfloor^2+h(a\\bmod c,b\\bmod c,c,n)+n(n+1)\\left\\lfloor\\frac{a}{c}\\right\\rfloor\\left\\lfloor\\frac{b}{c}\\right\\rfloor+2\\left\\lfloor\\frac{a}{c}\\right\\rfloor g(a\\bmod c,b\\bmod c,c,n)+2\\left\\lfloor\\frac{b}{c}\\right\\rfloor f(a\\bmod c,b\\bmod c,c,n)\\end{aligned} h(a,b,c,n)​=i=0∑n​⌊c(⌊ca​⌋+amodc)i+(⌊cb​⌋+bmodc)​⌋=i=0∑n​(⌊ca​⌋i+⌊cb​⌋+⌊c(amodc)i+(bmodc)​⌋)2=i=0∑n​(⌊ca​⌋2i2+⌊cb​⌋2+⌊c(amodc)i+(bmodc)​⌋2+2⌊ca​⌋⌊cb​⌋i+2⌊ca​⌋⌊c(amodc)i+(bmodc)​⌋i+2⌊cb​⌋⌊c(amodc)i+(bmodc)​⌋)=6n(n+1)(2n+1)​⌊ca​⌋2+(n+1)⌊cb​⌋2+h(amodc,bmodc,c,n)+n(n+1)⌊ca​⌋⌊cb​⌋+2⌊ca​⌋g(amodc,bmodc,c,n)+2⌊cb​⌋f(amodc,bmodc,c,n)​ 注意到平方很难处理，因此利用 n2=2∑i=1ni−nn^2=2\\sum_{i=1}^ni-nn2=2∑i=1n​i−n 来处理，即 h(a,b,c,n)=∑i=0n((2∑j=1⌊ai+bc⌋j)−⌊ai+bc⌋)=2(∑i=0n∑j=1tj)−f(a,b,c,n)=2(∑j=0m−1(j+1)∑i=0n[⌊ai+bc⌋&gt;j])−f(a,b,c,n)=2(∑j=0m−1(j+1)(n−t))−f(a,b,c,n)=nm(m+1)−2g(c,c−b−1,a,m−1)−2f(c,c−b−1,a,m−1)−f(a,b,c,n)\\begin{aligned}h(a,b,c,n)&amp;=\\sum_{i=0}^n\\left(\\left(2\\sum_{j=1}^{\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor}j\\right)-\\left\\lfloor\\frac{ai+b}{c}\\right\\rfloor\\right)\\\\&amp;=2\\left(\\sum_{i=0}^n\\sum_{j=1}^tj\\right)-f(a,b,c,n)\\\\&amp;=2\\left(\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^n\\left[\\left\\lfloor\\dfrac{ai+b}{c}\\right\\rfloor&gt;j\\right]\\right)-f(a,b,c,n)\\\\&amp;=2\\left(\\sum_{j=0}^{m-1}(j+1)(n-t)\\right)-f(a,b,c,n)\\\\&amp;=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\\end{aligned} h(a,b,c,n)​=i=0∑n​⎝⎜⎛​⎝⎜⎛​2j=1∑⌊cai+b​⌋​j⎠⎟⎞​−⌊cai+b​⌋⎠⎟⎞​=2(i=0∑n​j=1∑t​j)−f(a,b,c,n)=2(j=0∑m−1​(j+1)i=0∑n​[⌊cai+b​⌋&gt;j])−f(a,b,c,n)=2(j=0∑m−1​(j+1)(n−t))−f(a,b,c,n)=nm(m+1)−2g(c,c−b−1,a,m−1)−2f(c,c−b−1,a,m−1)−f(a,b,c,n)​ 注意计算的时候存在相互递归，因此三个要一起算，用结构体存答案。 Node Solve(long long a, long long b, long long c, long long n) { Node ans; long long bc = b / c, c2 = mul(n, n + 1, kInv2); if (a == 0) { ans.f = mul(n + 1, bc); ans.g = mul(c2, bc); ans.h = mul(n + 1, bc, bc); return ans; } long long ac = a / c, c3 = mul(n, n + 1, 2 * n + 1, kInv6); if (a &gt;= c || b &gt;= c) { Node r = Solve(a % c, b % c, c, n); ans.f = add(mul(c2, ac), mul(n + 1, bc), r.f); ans.g = add(mul(c3, ac), mul(c2, bc), r.g); ans.h = add(mul(c3, ac, ac), mul(n + 1, bc, bc), mul(n, n + 1, ac, bc), mul(2 * bc, r.f), mul(2 * ac, r.g), r.h); return ans; } long long m = (a * n + b) / c; Node r = Solve(c, c - b - 1, a, m - 1); ans.f = sub(mul(n, m), r.f); ans.g = sub(mul(c2, m), mul(r.f, kInv2), mul(r.h, kInv2)); ans.h = sub(mul(n, m, m + 1), r.g, r.g, r.f, r.f, ans.f); return ans; } ","link":"http://xyf007.ml/post/mu-ban-lei-ou-ji-li-de-suan-fa/"},{"title":"【学习笔记】线性规划对偶","content":"线性规划对偶 线性规划 在数学中，线性规划（Linear Programming，简称 LP）特指目标函数和约束条件皆为线性的最优化问题。 标准型 描述线性规划问题的常用和最直观形式是标准型。一般，规定线性规划的标准形式为： max⁡z=∑i=1ncixis.t.{∑j=1nai,jxj≤bj,i=1,…,nxi≥0,i=1,…,n\\max z=\\sum_{i=1}^nc_ix_i\\\\\\text{s.t.}\\begin{cases}\\sum_{j=1}^na_{i,j}x_j\\le b_j,i=1,\\ldots,n\\\\x_i\\ge0,i=1,\\ldots,n\\end{cases} maxz=i=1∑n​ci​xi​s.t.{∑j=1n​ai,j​xj​≤bj​,i=1,…,nxi​≥0,i=1,…,n​ 写成矩阵形式： max⁡z=CXAX≤BX≥0\\begin{aligned}\\max z&amp;=CX\\\\AX&amp;\\le B\\\\X&amp;\\ge0\\end{aligned} maxzAXX​=CX≤B≥0​ 对偶 最大化与最小化互换，常数与目标函数互换，改变不等号，变量与约束对应。 max⁡CTX:AX≤B,X≥0min⁡BTY:ATY≥C,Y≥0\\begin{aligned}\\max C^TX:AX\\le B,X\\ge0\\\\\\min B^TY:A^TY\\ge C,Y\\ge0\\end{aligned} maxCTX:AX≤B,X≥0minBTY:ATY≥C,Y≥0​ 形式上就是考虑每一个变量的系数对对偶变量的影响。 费用流求解 首先观察原本形式和对偶形式，看看哪一个更容易求解。如果有简单的几何意义就可以直接做了。下面则是一种机械化求解的方法。 费用流里一条边 (u,v)(u,v)(u,v) 代表一个变量，流量 fu,vf_{u,v}fu,v​ 代表取值，容量 cu,vc_{u,v}cu,v​ 代表上界，费用 wu,vw_{u,v}wu,v​ 代表目标函数。目标就是 min⁡wf\\min wfminwf。 定义 bu=∑vfu,v−∑vfv,ub_u=\\sum_v f_{u,v}-\\sum_v f_{v,u}bu​=∑v​fu,v​−∑v​fv,u​，表示流出流量与流入流量之差。那么约束可以表示为 −fu,v≥−cu,v∑vfu,v−∑vfv,u=bufu,v≥0\\begin{aligned}-f_{u,v}&amp;\\ge-c_{u,v}\\\\\\sum_v f_{u,v}-\\sum_v f_{v,u}&amp;=b_u\\\\f_{u,v}&amp;\\ge0\\end{aligned} −fu,v​v∑​fu,v​−v∑​fv,u​fu,v​​≥−cu,v​=bu​≥0​ 转化成标准型，添加辅助变量 aia_iai​，可得 −fu,v≥−cu,vau+∑vfu,v−∑vfv,u≥bufu,v,au≥0\\begin{aligned}-f_{u,v}&amp;\\ge-c_{u,v}\\\\a_u+\\sum_v f_{u,v}-\\sum_v f_{v,u}&amp;\\ge b_u\\\\f_{u,v},a_u&amp;\\ge0\\end{aligned} −fu,v​au​+v∑​fu,v​−v∑​fv,u​fu,v​,au​​≥−cu,v​≥bu​≥0​ 将其对偶，设第一类不等式的对偶变量为 zu,vz_{u,v}zu,v​，第二类的为 quq_uqu​，则有 max⁡z=∑buqu−∑cu,vzu,vs.t.{−zu,v+qu−qv≤wu,vqu≤0zu,v≥0\\max z=\\sum b_uq_u-\\sum c_{u,v}z_{u,v}\\\\\\text{s.t.}\\begin{cases}-z_{u,v}+q_u-q_v\\le w_{u,v}\\\\q_u\\le0\\\\z_{u,v}\\ge0\\end{cases} maxz=∑bu​qu​−∑cu,v​zu,v​s.t.⎩⎪⎨⎪⎧​−zu,v​+qu​−qv​≤wu,v​qu​≤0zu,v​≥0​ 由于线性规划要求变量 ≥0\\ge0≥0，令 pu=−qup_u=-q_upu​=−qu​，则有 max⁡z=−∑bupu−∑cu,vzu,vs.t.{pv−pu−zu,v≤wu,vpu,zu,v≥0\\max z=-\\sum b_up_u-\\sum c_{u,v}z_{u,v}\\\\\\text{s.t.}\\begin{cases}p_v-p_u-z_{u,v}\\le w_{u,v}\\\\p_u,z_{u,v}\\ge0\\end{cases} maxz=−∑bu​pu​−∑cu,v​zu,v​s.t.{pv​−pu​−zu,v​≤wu,v​pu​,zu,v​≥0​ 符号取反 min⁡z=∑bupu+∑cu,vzu,vs.t.{zu,v≥pv−pu−wu,vpu,zu,v≥0\\min z=\\sum b_up_u+\\sum c_{u,v}z_{u,v}\\\\\\text{s.t.}\\begin{cases}z_{u,v}\\ge p_v-p_u-w_{u,v}\\\\p_u,z_{u,v}\\ge0\\end{cases} minz=∑bu​pu​+∑cu,v​zu,v​s.t.{zu,v​≥pv​−pu​−wu,v​pu​,zu,v​≥0​ 这里要把 zzz 的限制放到目标函数里面，显然 zzz 取下界最优，因此有 min⁡z=∑bupu+∑cu,vmax⁡(0,pv−pu−wu,v)\\min z=\\sum b_up_u+\\sum c_{u,v}\\max(0,p_v-p_u-w_{u,v}) minz=∑bu​pu​+∑cu,v​max(0,pv​−pu​−wu,v​) 之后只要往这个形式上凑就行了，注意后面 cu,vc_{u,v}cu,v​ 是用来调整限制的，比如将不合法情况的 ccc 设置成 +∞+\\infty+∞ 来保证不会取到。并且通过这个式子可以还原整张费用流的图。 例题 洛谷 P3337 [ZJOI2013]防守战线 战线可以看作一个长度为 nnn 的序列，现在需要在这个序列上建塔来防守敌兵，在序列第 iii 号位置上建一座塔有 cic_ici​ 的花费，且一个位置可以建任意多的塔，费用累加计算。有 mmm 个区间 [l1,r1],[l2,r2],…,[lm,rm][l_1,r_1],[l_2,r_2],\\ldots,[l_m,r_m][l1​,r1​],[l2​,r2​],…,[lm​,rm​]，在第 iii 个区间的范围内要建至少 did_idi​ 座塔。求最少花费。n≤1000n\\le1000n≤1000，m≤10000m\\le10000m≤10000。 设 pip_ipi​ 表示修建塔数量的前缀和，那么总花费就是 ∑i(pi−pi−1)ci=∑ipi(ci−ci+1)\\sum_i(p_i-p_{i-1})c_i=\\sum_ip_i(c_i-c_{i+1})∑i​(pi​−pi−1​)ci​=∑i​pi​(ci​−ci+1​)。限制就是 pi≥0p_i\\ge 0pi​≥0，pi≥pi−1p_i\\ge p_{i-1}pi​≥pi−1​，pri−pli−1≥dip_{r_i}-p_{l_i-1}\\ge d_ipri​​−pli​−1​≥di​。因此把 pi−1&gt;pip_{i-1}&gt;p_ipi−1​&gt;pi​ 和 pli−1&gt;pri−dip_{l_i-1}&gt;p_{r_i}-d_ipli​−1​&gt;pri​​−di​ 的情况设置成 +∞+\\infty+∞ 即可。因此最后就是 min⁡z=∑(ci−ci+1)pi+∑+∞max⁡(0,pi−1−pi)+∑+∞max⁡(0,pli−1−pri+di)\\min z=\\sum(c_i-c_{i+1})p_i+\\sum+\\infty\\max(0,p_{i-1}-p_i)+\\sum+\\infty\\max(0,p_{l_i-1}-p_{r_i}+d_i)minz=∑(ci​−ci+1​)pi​+∑+∞max(0,pi−1​−pi​)+∑+∞max(0,pli​−1​−pri​​+di​)。连边情况：i→i−1i\\to i-1i→i−1 连 (+∞,0)(+\\infty,0)(+∞,0) 的边，ri→li−1r_i\\to l_i-1ri​→li​−1 连 (∞,−di)(\\infty,-d_i)(∞,−di​) 的边。对于 ci−ci+1&gt;0c_i-c_{i+1}&gt;0ci​−ci+1​&gt;0 的点，其流出流量大于流入流量，因此是源点，其他的点同理。因此有多个源点和汇点，需要建超级源汇。 Aizu2230 How to Create a Good Game 给出 nnn 个点 mmm 条边的有向无环带权图，你可以增加一些边的边权，要求 0→n−10\\to n-10→n−1 的最长路不变，求最多能增加的边权之和。2≤n≤1002\\le n\\le1002≤n≤100，1≤m≤10001\\le m\\le10001≤m≤1000，1≤wi,j≤10001\\le w_{i,j}\\le10001≤wi,j​≤1000。 设 pip_ipi​ 表示 0→i0\\to i0→i 的最长路，DDD 表示初始 0→n−10\\to n-10→n−1 的最长路，zu,vz_{u,v}zu,v​ 表示 (u,v)(u,v)(u,v) 增加的边权，那么可得 max⁡z=∑zu,vs.t.{p0=0pn−1=Dpu+wu,v+zu,v≤pvpi,zu,v≥0\\max z=\\sum z_{u,v}\\\\\\text{s.t.}\\begin{cases}p_0=0\\\\p_{n-1}=D\\\\p_u+w_{u,v}+z_{u,v}\\le p_v\\\\p_i,z_{u,v}\\ge0\\end{cases} maxz=∑zu,v​s.t.⎩⎪⎪⎪⎨⎪⎪⎪⎧​p0​=0pn−1​=Dpu​+wu,v​+zu,v​≤pv​pi​,zu,v​≥0​ 注意到等号非常麻烦，但是可以 作差。转成标准型 min⁡z=∑−zu,vs.t.{pn−1−p0≤D−zu,v≥pu−pv+wu,vpi,zu,v≥0\\min z=\\sum-z_{u,v}\\\\\\text{s.t.}\\begin{cases}p_{n-1}-p_0\\le D\\\\-z_{u,v}\\ge p_u-p_v+w_{u,v}\\\\p_i,z_{u,v}\\ge0\\end{cases} minz=∑−zu,v​s.t.⎩⎪⎨⎪⎧​pn−1​−p0​≤D−zu,v​≥pu​−pv​+wu,v​pi​,zu,v​≥0​ pu−pv+wu,v&gt;0p_u-p_v+w_{u,v}&gt;0pu​−pv​+wu,v​&gt;0 和 pn−1−p0−D&gt;0p_{n-1}-p_0-D&gt;0pn−1​−p0​−D&gt;0 时不合法，否则 −z-z−z 取到下界 pu−pv+wu,vp_u-p_v+w_{u,v}pu​−pv​+wu,v​。可得 min⁡z=∑(+∞max⁡(0,pu−pv+wu,v)+pu−pv+wu,v)+∞max⁡(0,pn−1−p0−D)=∑wu,v+∑(outu−inu)pu+∑+∞max⁡(0,pu−pv+wu,v)+∞max⁡(0,pn−1−p0−D)\\begin{aligned}\\min z&amp;=\\sum(+\\infty\\max(0,p_u-p_v+w_{u,v})+p_u-p_v+w_{u,v})+\\infty\\max(0,p_{n-1}-p_0-D)\\\\&amp;=\\sum w_{u,v}+\\sum(\\textit{out}_u-\\textit{in}_u)p_u+\\sum+\\infty\\max(0,p_u-p_v+w_{u,v})+\\infty\\max(0,p_{n-1}-p_0-D)\\end{aligned} minz​=∑(+∞max(0,pu​−pv​+wu,v​)+pu​−pv​+wu,v​)+∞max(0,pn−1​−p0​−D)=∑wu,v​+∑(outu​−inu​)pu​+∑+∞max(0,pu​−pv​+wu,v​)+∞max(0,pn−1​−p0​−D)​ ABC224H Security Camera 2 给出一张二分图，左边有 nnn 个点，右边有 mmm 个点。你要在每个点上填一个自然数，设左边填的是 lil_ili​，右边填的是 rir_iri​，要求 ∀i,j\\forall i,j∀i,j 满足 li+rj≥ci,jl_i+r_j\\ge c_{i,j}li​+rj​≥ci,j​，代价为 ∑Aili+∑Biri\\sum A_il_i+\\sum B_ir_i∑Ai​li​+∑Bi​ri​。求代价的最小值。1≤n,m≤1001\\le n,m\\le1001≤n,m≤100，1≤Ai,Bi≤101\\le A_i,B_i\\le101≤Ai​,Bi​≤10，0≤ci,j≤1000\\le c_{i,j}\\le1000≤ci,j​≤100。 可以直接写出线性规划的式子 min⁡z=∑Aili+∑Biris.t.{li+rj≥ci,jli,ri≥0\\min z=\\sum A_il_i+\\sum B_ir_i\\\\\\text{s.t.}\\begin{cases}l_i+r_j\\ge c_{i,j}\\\\l_i,r_i\\ge0\\end{cases} minz=∑Ai​li​+∑Bi​ri​s.t.{li​+rj​≥ci,j​li​,ri​≥0​ 但是这个东西没有办法做，因为我们想要差的形式。所以直接把问题对偶，可得 max⁡z=∑ci,jpi,js.t.{∑jpi,j≤Ai∑jpj,i≤Bipi,j≥0\\max z=\\sum c_{i,j}p_{i,j}\\\\\\text{s.t.}\\begin{cases}\\sum_jp_{i,j}\\le A_i\\\\\\sum_jp_{j,i}\\le B_i\\\\p_{i,j}\\ge0\\end{cases} maxz=∑ci,j​pi,j​s.t.⎩⎪⎨⎪⎧​∑j​pi,j​≤Ai​∑j​pj,i​≤Bi​pi,j​≥0​ 然后就可以建图了。源点向左边连 (Ai,0)(A_i,0)(Ai​,0) 的边，左边 iii 向右边 jjj 连 (+∞,ci,j)(+\\infty,c_{i,j})(+∞,ci,j​) 的边，右边向汇点连 (Bj,0)(B_j,0)(Bj​,0) 的边，然后跑最大费用流即可。 动态规划模型 对偶时贡献系数会变成约束的常数，那么如果贡献系数很小，对偶之后的操作空间就很小。此时可能可以用 DP 解决。 例题 XX Opun Cup. GP of Moscow C. Circles 对于一个序列 s1,…,sns_1,\\ldots,s_ns1​,…,sn​，定义一个非负 实数 序列 x1,…,xnx_1,\\ldots,x_nx1​,…,xn​ 是平衡的当且仅当 ∀i,xi+xi mod n+1≤si\\forall i,x_i+x_{i\\bmod n+1}\\le s_i∀i,xi​+ximodn+1​≤si​。定义 f(s1,…,sn)f(s_1,\\ldots,s_n)f(s1​,…,sn​) 表示所有平衡序列中 ∑xi\\sum x_i∑xi​ 的最大值。给出一个序列 a1,…,ana_1,\\ldots,a_na1​,…,an​，对于 k∈[3,n]k\\in[3,n]k∈[3,n]，求 f(a1,a2,…,ak)f(a_1,a_2,\\ldots,a_k)f(a1​,a2​,…,ak​)。3≤n≤1053\\le n\\le10^53≤n≤105，0≤ai≤1050\\le a_i\\le10^50≤ai​≤105。 发现 aia_iai​ 巨大，而贡献系数是 111，因此直接对偶，变成相邻两个数相加 ≥1\\ge1≥1，贡献系数是 aia_iai​，求最小值。容易发现每个变量的取值都是 [0,1][0,1][0,1]。进一步地，可以发现所有变量都应当取 {0,1}\\{0,1\\}{0,1}，或者是全部 0.50.50.5。可以通过调整证明。于是直接 DP 就行了。时间复杂度 O(n)O(n)O(n)。 ","link":"http://xyf007.ml/post/xue-xi-bi-ji-xian-xing-gui-hua-dui-ou/"},{"title":"CSP–S2021 游记","content":"哈哈打烂了比去年还菜🤡🤡🤡 主要还是时间分配的问题，导致能拿的分没拿满。 开场先看 T1，意识到这场比赛难度巨大。一开始观察了一下 T1 的单调性，发现没有啥用，试图三分但是迅速把自己叉掉。然后意识到随着数量增加之前选到的一定还会选到，新增的只会影响之前没有位置的飞机。然后就用 std::set&lt;std::pair&lt;int, int&gt;&gt; 维护，每一轮不断二分出第一个合法的飞机然后删掉，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)，测了一下不到 0.1s。写了个拍发现自己 std::set 没清空，然后就拍上了。这时候大概过了一个小时，感觉还行（flag）。 然后开 T2，发现是计数题，顿感药丸。先试图想一个记录当前左括号数量和连续 * 数量的 DP 但是没法转移，然后意识到似乎可以区间 DP，想了一下应该是前缀和优化然后就开始写。写完发现各种写错，过了第一个样例过不了第二个。然后写了个暴力，发现过了样例二。接着写拍，然后 ()()() 的数据炸了。这时候我意识到 我的 DP 是会算重的，而且想了一下发现 我不会修，顿时一身冷汗下来了。这时候已经过去 2.5h，于是赶紧扔了去看 T3。 看 T3 的时候心态爆炸。先手玩了一下发现只有两种情况，把划分出的两段序列归并一下就行了。一开始题目看错以为要求最后序列字典序最小，不过刚开始写的时候想到为什么没有 SPJ，然后发现是操作序列字典序最小，以为自己要彻底凉凉了。不过冷静分析一下这样更简单了。但是码的时候还是各种错，可能是紧张的原因。过大样例又用了 1h，只剩半个小时了。 但是这个时候我又回去想 T2 试图过掉。想了 15min 还是不会做，去看 T4。然后尝试去打 k=2k=2k=2 的部分分，结果比赛结束都没写完。 估分 100+[0,15]+100+0=[200,215]100+[0,15]+100+0=[200,215]100+[0,15]+100+0=[200,215]，比赛结束发现人均 300+，哈哈就我是小丑。 实际上 T2 加一个钦定左右都是括号的方案数之类的就能避免算重，我之前没怎么做过。另外时间安排上来说，T2 应该更早弃掉，这样 T4 的最小割 60 还能拿到，同时主动放弃的心态远比假掉被迫放弃强。 UPD：T3 n=1n=1n=1 的情况挂了哈哈 ","link":"http://xyf007.ml/post/csp-s2021-you-ji/"},{"title":"【模板】Bron–Kerbosch 算法","content":"用来求解最大团的算法，大概就是搜索+剪枝。 最朴素的做法就是 DFS 的时候记录当前点 uuu 和与已选择的点都有边的集合 SSS。每次从 SSS 中挑选一个 vvv，然后 S←S∩adj⁡(v)S\\gets S\\cap\\operatorname{adj}(v)S←S∩adj(v)，进行下一层 DFS，直到 SSS 为空。但是这样非常慢，考虑各种剪枝。 每次只考虑编号大于 uuu 的点，避免重复统计。 记当前选择的点数为 cur\\textit{cur}cur，已经求出的最大值为 max\\textit{max}max。第二个剪枝是如果 cur+popcount⁡(S)≤max\\textit{cur}+\\operatorname{popcount}(S)\\le\\textit{max}cur+popcount(S)≤max 那么直接返回。这个是搜索的经典剪枝。 倒序枚举初始点，记 aia_iai​ 为使用编号为 [i,n)[i,n)[i,n) 的点形成的最大团，那么 aia_iai​ 就是以 iii 为起点 DFS 完之后的 max\\textit{max}max，所以 ai+1≤ai≤ai+1+1a_{i+1}\\le a_i\\le a_{i+1}+1ai+1​≤ai​≤ai+1​+1。在 DFS 的时候，如果遇到 cur+av≤max\\textit{cur}+a_v\\le\\textit{max}cur+av​≤max 直接返回。 注意到答案每次只可能增加 111，因此只要更新了答案就返回。 一张 nnn 个点的图极大团数量上限为 O(3n3)O(3^{\\frac{n}{3}})O(33n​)，朴素实现的 Bron–Kerbosch 算法最坏情况达到这个上界，因此时间复杂度 O(3n3)O(3^{\\frac{n}{3}})O(33n​)。在稀疏图上有更紧的上界。 还有 Pivot 优化和退化序优化，但我咕了。 #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } int n, a[50], g[50][50], max; long long adj[50]; bool Dfs(int u, long long S, int cur) { if (!S) { if (cur &gt; max) { max = cur; return true; } return false; } if (cur + __builtin_popcountll(S) &lt;= max) return false; for (int v = u + 1; v &lt; n; v++) if ((S &gt;&gt; v) &amp; 1) { if (cur + a[v] &lt;= max) return false; S ^= 1LL &lt;&lt; v; if (Dfs(v, S &amp; adj[v], cur + 1)) return true; } return false; } void Solve() { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) std::cin &gt;&gt; g[i][j]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) if (g[i][j]) adj[i] |= 1LL &lt;&lt; j; max = 0; long long S = 0LL; for (int i = n - 1; i &gt;= 0; S |= 1LL &lt;&lt; i--) { Dfs(i, S &amp; adj[i], 1); a[i] = max; } std::cout &lt;&lt; a[0] &lt;&lt; '\\n'; std::memset(adj, 0, 8 * n), std::memset(a, 0, 4 * n); } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); while (std::cin &gt;&gt; n &amp;&amp; n) Solve(); return 0; } ","link":"http://xyf007.ml/post/mu-ban-bron-kerbosch-suan-fa/"},{"title":"【模板】斯坦纳树","content":"#include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } int n, m, k, dp[1024][101]; std::vector&lt;std::pair&lt;int, int&gt;&gt; g[101]; bool vis[101]; void Spfa(int S) { std::queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) if (dp[S][i] != 0x3f3f3f3f) q.emplace(i), vis[i] = true; while (!q.empty()) { int u = q.front(); q.pop(), vis[u] = false; for (auto &amp;&amp;[v, w] : g[u]) if (dp[S][u] + w &lt; dp[S][v]) { dp[S][v] = dp[S][u] + w; if (!vis[v]) q.emplace(v), vis[v] = true; } } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= m; i++) { int u, v, w; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, u--, v--; g[u].emplace_back(v, w), g[v].emplace_back(u, w); } std::memset(dp, 0x3f, sizeof(dp)); for (int i = 0; i &lt; k; i++) { int x; std::cin &gt;&gt; x, x--; dp[1 &lt;&lt; i][x] = 0; } for (int S = 1; S &lt; (1 &lt;&lt; k); S++) { for (int T = S &amp; (S - 1); T; T = (T - 1) &amp; S) { if (T &lt; (S ^ T)) break; for (int i = 0; i &lt; n; i++) checkmin(dp[S][i], dp[T][i] + dp[T ^ S][i]); } Spfa(S); } std::cout &lt;&lt; *std::min_element(dp[(1 &lt;&lt; k) - 1], dp[(1 &lt;&lt; k) - 1] + n); return 0; } ","link":"http://xyf007.ml/post/mu-ban-si-tan-na-shu/"},{"title":"【学习笔记】PQ 树","content":"PQ 树 前言 这玩意似乎是个相当冷门的数据结构。。。网上的讲解极少而且相当难懂，干脆自己翻译一下这篇文章。 引入 PQ 树是一种基于树的数据结构，代表一组元素上的一系列排列，由 Kellogg S. Booth 和 George S. Lueker 于 1976 年发现命名，用来解决以下问题 给出 mmm 个集合 SiS_iSi​，你要找到一个 1∼n1\\sim n1∼n 的排列，使得每个集合内的元素都相邻。 PQ 树可以在 O(n+∑∣Si∣)O(n+\\sum|S_i|)O(n+∑∣Si​∣) 时间内构建。 定义 PQ 树有三种结点：叶子结点、P 结点 和 Q 结点。其中叶子结点代表排列中的一个元素，P 结点表示它的子结点可以任意排列，Q 结点表示它的儿子顺序可以反转。所有非叶子结点都是 P 结点或 Q 结点中的一种。P 结点至少有 2 个儿子，Q 结点至少有 3 个儿子。 由于结点的定义，PQ 树本身代表了 所有的 合法方案，其先序遍历就是其中之一。 下图是一棵 PQ 树。 其先序遍历 1,2,3,4,5 代表了一个合法方案。如果 P 结点的儿子重排列为 4,2,3，我们得到了另一个合法方案 1,4,2,3,5。保持 P 结点儿子顺序不变，Q 结点的儿子顺序反转，得到了另一个合法方案 5,3,2,4,1。 构建 PQ 树使用儿子-兄弟表示法。 我们增量构建一棵 PQ 树。 首先建立一棵树，其根为 P，总共 nnn 个儿子，分别是 1,2,…,n1,2,\\ldots,n1,2,…,n，代表没有任何限制时的 PQ 树。随着限制的不断加入，我们不断修改这棵树。 当加入一个新的限制集合 SSS 时，我们把所有属于这个集合的叶子结点标记为 黑色，不在这个集合内的叶子结点标记为 白色。对于所有非叶子结点，如果其所有儿子均为黑色，将其也标记为黑色；如果其所有儿子均为白色，将其也标记为白色；否则将其标记为 灰色。在下面的图中，黑色结点、白色结点、灰色结点分别用黑色、灰色、一半黑一半灰来表示。 我们要求 PQ 树中的结点按照颜色排序。 自底向上法 包含所有黑色结点的最小子树被称为 相关子树，相关子树的根（不一定是整棵树的根）被称为 相关根。 添加一个限制的过程被称为 reduction。一次 reduction 分为两个阶段：冒泡阶段和减少阶段。 冒泡阶段 冒泡阶段只处理相关子树。我们将相关子树中的所有结点标记为黑色或灰色，并为每个结点计算其拥有的相关子结点数量。为了高效地完成这个过程，我们从叶子往根处理相关子树。这需要记录每个点的父亲结点，但在减少阶段一个点的父亲结点经常要被修改。为了在线性时间内构造，只有 P 结点的儿子和 Q 结点的最后一个儿子 始终记录正确的父亲结点。对于 Q 结点的其他儿子，在冒泡阶段用最后一个儿子的父亲更新他们的父亲。 当遇到一个中间的结点时，我们看一下它的兄弟是否已经有合法的父亲结点。如果没有，将其标记为 阻塞 的。如果后面它的兄弟有了合法的父亲，那么修改这个结点的父亲并且取消标记。如果在冒泡阶段结束时，仍然有一段连续的阻塞结点（如下面的情况 Q3），一个没有父结点的“伪结点”成为该块的父结点，并在减少阶段时被去除。 减少阶段 减少阶段用一个队列来处理结点。首先将所有限制内的叶子结点加入队列。每次取出队首的结点 uuu 并处理。如果 uuu 的父亲也是相关子树内的结点，那么将 fau\\textit{fa}_ufau​ 入队。 对于每一个结点 uuu，我们分情况讨论。如果不属于其中任何一种情况，则无解。 叶子结点 将 uuu 标记为黑色。 P 结点 如果所有儿子均为黑色，将 uuu 标记为黑色。 如果 uuu 有黑色儿子和白色儿子，且 uuu 是相关根，那么新建一个 P 结点 vvv 成为它所有黑色儿子的根。 如果 uuu 有黑色儿子和白色儿子，且 uuu 不是相关根，那么做以下操作： 新建一个 P 结点 fff 成为所有黑色儿子的根。 新建一个 P 结点 eee 成为所有白色儿子的根。 如果 eee（和/或 fff）只有一个儿子，那么不要新建结点，而是将 eee（和/或 fff）直接赋值成那个儿子。 将 uuu 改成 Q 结点并把其儿子设为 eee 和 fff，将其标记为灰色。 注意到根据之前的定义，Q 结点至少有 3 个儿子，因此这里的 uuu 被视为一个”伪结点“，并且将在后面被继续处理。 如果 uuu 有一个灰色儿子 ppp，且 uuu 是相关根，那么新建一个 P 结点 vvv 作为其所有黑色儿子的根，将 vvv 的兄弟设为 ppp 最后一个一个黑色儿子，然后把 vvv 设为 ppp 的最后一个儿子。 如果 uuu 有一个灰色儿子 ppp，且 uuu 不是相关根，那么进行以下操作： 新建一个 P 结点 fff 成为所有黑色儿子的根。 新建一个 P 结点 eee 成为所有白色儿子的根。 如果 eee（和/或 fff）只有一个儿子，那么不要新建结点，而是将 eee（和/或 fff）直接赋值成那个儿子。 将 eee 的兄弟设为 ppp 最后一个白色儿子，然后把 eee 设为 ppp 的最后一个儿子。 将 fff 的兄弟设为 ppp 最后一个黑色儿子，然后把 fff 设为 ppp 的最后一个儿子。 如果 uuu 恰有两个灰色儿子 p1,p2p_1,p_2p1​,p2​，那么进行以下操作： 新建一个 P 结点 fff 成为所有黑色儿子的根。 如果 fff 只有一个儿子，那么不要新建结点，而是将 fff 直接赋值成那个儿子。 把 p1p_1p1​ 的最后一个黑色儿子的兄弟设为 fff。 把 fff 的兄弟设为 p2p_2p2​ 的最后一个黑色儿子。 把 p2p_2p2​ 的最后一个儿子设为 p2p_2p2​ 的最后一个白色儿子。 可以发现这样 p2p_2p2​ 就被合并进了 p1p_1p1​。 Q 结点 如果 uuu 只有黑色儿子，那么将 uuu 标记成黑色。（下面的图的形状错了。） 如果 uuu 有一个灰色儿子 ppp，且所有标记相同的儿子均连续出现，那么进行如下操作： 设 pfp_fpf​ 为 ppp 最后一个黑色儿子，pep_epe​ 为 ppp 最后一个白色儿子，fff 为 ppp 的黑色兄弟，eee 为 ppp 的白色兄弟。 将 fff 的兄弟设为 pfp_fpf​，eee 的兄弟设为 pep_epe​。 如果 ppp 没有一个白色兄弟或黑色兄弟，将 uuu 的最后一个儿子设成 ppp 的最后一个儿子。 删除 ppp。 如果 uuu 恰有两个灰色儿子 p1,p2p_1,p_2p1​,p2​，且所有标记相同的儿子均连续出现，那么对 p1,p2p_1,p_2p1​,p2​ 都进行上一种操作即可。 该构建方法是原论文中的，但是实现较为不便。 自顶向下法 目前 OI 中的实现大多采用该方法。其实方法类似，下面出现的情况基本都能在上面找到。 注意到根据之前的染色过程，所有黑色和白色的点都已经满足条件，因此我们只需要处理灰色结点。 P 结点 如果 uuu 有多于两个灰色儿子，无解。 如果 uuu 只有一个灰色儿子，且没有黑色儿子，递归处理灰色儿子。 否则先清空 uuu 的儿子，然后加入所有的白色儿子。新建一个 Q 结点 q1q_1q1​ 并成为 uuu 的儿子。在 q1q_1q1​ 中加入所有的灰色儿子。新建一个 P 结点 ppp 作为所有黑色儿子的根，将 ppp 插入 q1q_1q1​ 的中间。（对应了自底向上法 P 结点的所有情况。） 注意到我们会要求两个灰色节点白色全在左侧，黑色全在右侧（或相反），因此我们需要实现一个分裂函数 split，可以把这个子树的点分裂成黑白部分，并同时保留分裂成的子树的节点的所有可能。 Q 结点 找到最左边和最右边的非白色节点位置 l,rl,rl,r。如果 [l+1,r−1][l+1,r-1][l+1,r−1] 内有非黑色节点，无解。 如果没有黑色节点，只有一个灰色节点，递归处理这个灰色节点，否则只需要将 lll 和 rrr 位置的节点分裂。 分裂函数 令要分裂的点为 uuu，我们想把 uuu 分裂成左边全是白色，右边全是黑色的森林。如果 uuu 不是灰色结点则直接返回子树。只考虑灰色结点的情况。 如果 uuu 是 P 类结点： 如果 uuu 有至少两个灰色儿子，则无解。 否则左边是所有白色儿子，中间递归处理灰色儿子，右边是所有黑色儿子。注意到要保留所有的可能，因此要新建两个 P 结点分别作为白色儿子和黑色儿子的根。（对应自底向上法的 P4 情况。） 删除 uuu。 如果 uuu 是 Q 类结点： 如果正序和反序都不满足白-灰-黑，则无解。 如果有至少两个灰色儿子，也无解。 否则递归分裂灰色儿子即可。 删除 uuu。 最后把所有多余的结点（只有一个儿子的结点）删除。 代码实现 class PQTree { public: PQTree() {} void Init(int n) { n_ = n, rt_ = tot_ = n + 1; for (int i = 1; i &lt;= n; i++) g_[rt_].emplace_back(i); } void Insert(const std::string &amp;s) { s_ = s; Dfs0(rt_); Work(rt_); while (g_[rt_].size() == 1) rt_ = g_[rt_][0]; Remove(rt_); } std::vector&lt;int&gt; ans() { DfsAns(rt_); return ans_; } ~PQTree() {} private: int n_, rt_, tot_, pool_[100001], top_, typ_[100001] /* 0-P 1-Q */, col_[100001] /* 0-black 1-white 2-grey */; std::vector&lt;int&gt; g_[100001], ans_; std::string s_; void Fail() { std::cout &lt;&lt; &quot;NO\\n&quot;; std::exit(0); } int NewNode(int ty) { int x = top_ ? pool_[top_--] : ++tot_; typ_[x] = ty; return x; } void Delete(int u) { g_[u].clear(), pool_[++top_] = u; } void Dfs0(int u) { // get color of each node if (u &gt;= 1 &amp;&amp; u &lt;= n_) { col_[u] = s_[u] == '1'; return; } bool c0 = false, c1 = false; for (auto &amp;&amp;v : g_[u]) { Dfs0(v); if (col_[v]) c1 = true; if (col_[v] != 1) c0 = true; } if (c0 &amp;&amp; !c1) col_[u] = 0; else if (!c0 &amp;&amp; c1) col_[u] = 1; else col_[u] = 2; } bool Check(const std::vector&lt;int&gt; &amp;v) { int p2 = -1; for (int i = 0; i &lt; static_cast&lt;int&gt;(v.size()); i++) if (col_[v[i]] == 2) { if (p2 != -1) return false; p2 = i; } if (p2 == -1) for (int i = 0; i &lt; static_cast&lt;int&gt;(v.size()); i++) if (col_[v[i]]) { p2 = i; break; } for (int i = 0; i &lt; p2; i++) if (col_[v[i]]) return false; for (int i = p2 + 1; i &lt; static_cast&lt;int&gt;(v.size()); i++) if (col_[v[i]] != 1) return false; return true; } std::vector&lt;int&gt; Split(int u) { if (col_[u] != 2) return {u}; std::vector&lt;int&gt; ng; if (typ_[u]) { // Q if (!Check(g_[u])) { std::reverse(g_[u].begin(), g_[u].end()); if (!Check(g_[u])) Fail(); } for (auto &amp;&amp;v : g_[u]) if (col_[v] != 2) { ng.emplace_back(v); } else { auto s = Split(v); ng.insert(ng.end(), s.begin(), s.end()); } } else { // P std::vector&lt;int&gt; son[3]; for (auto &amp;&amp;x : g_[u]) son[col_[x]].emplace_back(x); if (son[2].size() &gt; 1) Fail(); if (!son[0].empty()) { int n0 = NewNode(0); g_[n0] = son[0]; ng.emplace_back(n0); } if (!son[2].empty()) { auto s = Split(son[2][0]); ng.insert(ng.end(), s.begin(), s.end()); } if (!son[1].empty()) { int n1 = NewNode(0); g_[n1] = son[1]; ng.emplace_back(n1); } } Delete(u); return ng; } void Work(int u) { if (col_[u] != 2) return; if (typ_[u]) { // Q int l = 1e9, r = -1e9; for (int i = 0; i &lt; static_cast&lt;int&gt;(g_[u].size()); i++) if (col_[g_[u][i]]) checkmin(l, i), checkmax(r, i); for (int i = l + 1; i &lt; r; i++) if (col_[g_[u][i]] != 1) Fail(); if (l == r &amp;&amp; col_[g_[u][l]] == 2) { Work(g_[u][l]); return; } std::vector&lt;int&gt; ng; for (int i = 0; i &lt; l; i++) ng.emplace_back(g_[u][i]); auto s = Split(g_[u][l]); ng.insert(ng.end(), s.begin(), s.end()); for (int i = l + 1; i &lt; r; i++) ng.emplace_back(g_[u][i]); if (l != r) { s = Split(g_[u][r]); std::reverse(s.begin(), s.end()); ng.insert(ng.end(), s.begin(), s.end()); } for (int i = r + 1; i &lt; static_cast&lt;int&gt;(g_[u].size()); i++) ng.emplace_back(g_[u][i]); g_[u] = ng; } else { // P std::vector&lt;int&gt; son[3]; for (auto &amp;&amp;x : g_[u]) son[col_[x]].emplace_back(x); if (son[1].empty() &amp;&amp; son[2].size() == 1) { Work(son[2][0]); return; } g_[u].clear(); if (son[2].size() &gt; 2) Fail(); g_[u] = son[0]; int n1 = NewNode(1); g_[u].emplace_back(n1); if (son[2].size() &gt;= 1) { auto s = Split(son[2][0]); g_[n1].insert(g_[n1].end(), s.begin(), s.end()); } if (son[1].size()) { int n2 = NewNode(0); g_[n1].emplace_back(n2); g_[n2] = son[1]; } if (son[2].size() &gt;= 2) { auto s = Split(son[2][1]); std::reverse(s.begin(), s.end()); g_[n1].insert(g_[n1].end(), s.begin(), s.end()); } } } void Remove(int u) { // remove the nodes with only one child for (auto &amp;&amp;v : g_[u]) { int tv = v; while (g_[tv].size() == 1) { int t = tv; tv = g_[tv][0]; Delete(t); } v = tv, Remove(v); } } void DfsAns(int u) { if (u &gt;= 1 &amp;&amp; u &lt;= n_) { ans_.emplace_back(u); return; } for (auto &amp;&amp;v : g_[u]) DfsAns(v); } } T; 习题 CF243E Matrix CF1552I Organizing a Music Festival 参考资料 Booth, Kellogg S. &amp; Lueker, George S. (1976). &quot;Testing for the consecutive ones property, interval graphs, and graph planarity using PQ-tree algorithms&quot;. Journal of Computer and System Sciences. 13 (3): 335–379. doi:10.1016/S0022-0000(76)80045-1. PQ Tree Algorithm and Consecutive Ones Problem CF243E Matrix PQTree - RainAir's Blog ","link":"http://xyf007.ml/post/xue-xi-bi-ji-pq-shu/"},{"title":"高精度模板","content":"class BigInt { public: int sign_; long long a_[100001]; BigInt(long long = 0LL); BigInt(const std::string &amp;); BigInt(const char *s) { *this = std::string(s); } BigInt &amp;operator=(long long v) { return *this = BigInt(v); } BigInt &amp;operator=(const std::string &amp;s) { return *this = BigInt(s); } BigInt &amp;operator=(const char *s) { return *this = BigInt(s); } bool operator&lt;(const BigInt &amp;rhs) const; bool operator&gt;(const BigInt &amp;rhs) const; bool operator&lt;=(const BigInt &amp;rhs) const; bool operator&gt;=(const BigInt &amp;rhs) const; bool operator==(const BigInt &amp;rhs) const; bool operator!=(const BigInt &amp;rhs) const; BigInt operator+(const BigInt &amp;) const; BigInt operator-(const BigInt &amp;) const; BigInt operator*(const BigInt &amp;) const; BigInt operator/(const BigInt &amp;) const; BigInt operator%(const BigInt &amp;) const; BigInt operator-() const { BigInt tmp = *this; tmp.sign_ *= -1; return tmp; } BigInt &amp;operator+=(const BigInt &amp;obj) { return *this = *this + obj; } BigInt &amp;operator-=(const BigInt &amp;obj) { return *this = *this - obj; } BigInt &amp;operator*=(const BigInt &amp;obj) { return *this = *this * obj; } BigInt &amp;operator/=(const BigInt &amp;obj) { return *this = *this / obj; } BigInt &amp;operator%=(const BigInt &amp;obj) { return *this = *this % obj; } BigInt &amp;operator++() { return *this += 1; } BigInt &amp;operator--() { return *this -= 1; } BigInt operator++(int); BigInt operator--(int); friend std::istream &amp;operator&gt;&gt;(std::istream &amp;, BigInt &amp;); friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, const BigInt &amp;); ~BigInt() {} private: static const int kLen_ = 8; static const long long kRadix_ = 100000000; }; inline BigInt::BigInt(long long v) : sign_(0) { std::memset(a_, 0, sizeof(a_)); if (v &lt; 0) sign_ = -1, v = -v; else if (v &gt; 0) sign_ = 1; int w = 1; a_[1] = v; while (a_[w] &gt;= kRadix_) a_[w + 1] += a_[w] / kRadix_, a_[w++] %= kRadix_; a_[0] = w; } inline BigInt::BigInt(const std::string &amp;s) : sign_(0) { std::memset(a_, 0, sizeof(a_)); std::string t(s); std::reverse(t.begin(), t.end()); if (t.back() == '-') sign_ = -1, t.pop_back(); if (sign_ != -1 &amp;&amp; t.back() != '0') sign_ = 1; while (t.size() &amp; 7) t += '0'; for (auto &amp;&amp;c : t) c -= '0'; a_[0] = t.size() &gt;&gt; 3; for (std::size_t i = 0; i &lt; t.size(); i += 8) a_[(i &gt;&gt; 3) + 1] = t[i] + t[i + 1] * 10 + t[i + 2] * 100 + t[i + 3] * 1000 + t[i + 4] * 10000 + t[i + 5] * 100000 + t[i + 6] * 1000000 + t[i + 7] * 10000000; } inline bool BigInt::operator&lt;(const BigInt &amp;rhs) const { if (sign_ != rhs.sign_) return sign_ &lt; rhs.sign_; if (a_[0] != rhs.a_[0]) return a_[0] * sign_ &lt; rhs.a_[0] * rhs.sign_; for (int i = a_[0]; i &gt;= 1; i--) if (a_[i] != rhs.a_[i]) return a_[i] * sign_ &lt; rhs.a_[i] * rhs.sign_; return false; } inline bool BigInt::operator&gt;(const BigInt &amp;rhs) const { return rhs &lt; *this; } inline bool BigInt::operator&lt;=(const BigInt &amp;rhs) const { return !(*this &gt; rhs); } inline bool BigInt::operator&gt;=(const BigInt &amp;rhs) const { return !(*this &lt; rhs); } inline bool BigInt::operator==(const BigInt &amp;rhs) const { return !(*this &lt; rhs) &amp;&amp; !(rhs &lt; *this); } inline bool BigInt::operator!=(const BigInt &amp;rhs) const { return *this &lt; rhs || rhs &lt; *this; } inline BigInt BigInt::operator+(const BigInt &amp;rhs) const { BigInt ans; if (sign_ * rhs.sign_ == 1) { ans.sign_ = sign_; int w = std::max(a_[0], rhs.a_[0]), ad = 0; for (int i = 1; i &lt;= w; i++) { ans.a_[i] = a_[i] + rhs.a_[i] + ad, ad = 0; if (ans.a_[i] &gt;= kRadix_) ans.a_[i] -= kRadix_, ad = 1; } if (ad) ans.a_[++w] = ad; ans.a_[0] = w; return ans; } BigInt tmp = sign_ == -1 ? -*this : -rhs; return sign_ == -1 ? rhs - tmp : *this - tmp; } inline BigInt BigInt::operator-(const BigInt &amp;rhs) const { BigInt ans; if (*this &lt; rhs) return -(rhs - *this); if (rhs.sign_ == -1) return *this + -rhs; ans.sign_ = 1; int w = a_[0], ad = 0; for (int i = 1; i &lt;= w; i++) { ans.a_[i] = a_[i] - rhs.a_[i] - ad, ad = 0; if (ans.a_[i] &lt; 0) ans.a_[i] += kRadix_, ad = 1; } while (w &gt; 1 &amp;&amp; !ans.a_[w]) w--; ans.a_[0] = w; if (w == 1 &amp;&amp; !ans.a_[1]) ans.sign_ = 0; return ans; } inline BigInt BigInt::operator*(const BigInt &amp;rhs) const { BigInt ans; ans.sign_ = sign_ * rhs.sign_; for (int i = 1; i &lt;= a_[0]; i++) for (int j = 1; j &lt;= rhs.a_[0]; j++) { ans.a_[i + j - 1] += a_[i] * rhs.a_[j]; if (ans.a_[i + j - 1] &gt;= kRadix_) { ans.a_[i + j] += ans.a_[i + j - 1] / kRadix_; ans.a_[i + j - 1] %= kRadix_; } } int w = a_[0] + rhs.a_[0] - 1; while (ans.a_[w + 1]) w++; ans.a_[0] = w; return ans; } inline BigInt BigInt::operator/(const BigInt &amp;rhs) const { BigInt ans, a = *this, b = rhs; ans.sign_ = sign_ * rhs.sign_; a.sign_ = b.sign_ = 1; if (a &lt; b) return BigInt(); int w = a_[0] - rhs.a_[0] + 1; b.a_[0] = a_[0]; for (int i = a_[0]; i &gt;= w &amp;&amp; i &gt;= 1; i--) b.a_[i] = b.a_[i - w + 1]; for (int i = w - 1; i &gt;= 1; i--) b.a_[i] = 0LL; for (int i = w; i &gt;= 1; i--) { long long l = 0LL, r = kRadix_ - 1, best = 0LL; while (l &lt;= r) { long long mid = (l + r) &gt;&gt; 1; if (BigInt(mid) * b &lt;= a) { best = mid; l = mid + 1; } else { r = mid - 1; } } ans.a_[i] = best; a -= BigInt(best) * b; while (a.a_[0] &gt; 1 &amp;&amp; !a.a_[a.a_[0]]) a.a_[0]--; for (int i = 1; i &lt;= a_[0]; i++) b.a_[i] = b.a_[i + 1]; b.a_[0]--; } while (w &gt; 1 &amp;&amp; !ans.a_[w]) w--; ans.a_[0] = w; if (w == 1 &amp;&amp; !ans.a_[1]) ans.sign_ = 0; return ans; } inline BigInt BigInt::operator%(const BigInt &amp;rhs) const { BigInt a(*this), b(rhs); a.sign_ = b.sign_ = 1; if (a &lt; b) return *this; int w = a_[0] - rhs.a_[0] + 1; b.a_[0] = a_[0]; for (int i = a_[0]; i &gt;= w; i--) b.a_[i] = b.a_[i - w + 1]; for (int i = w - 1; i &gt;= 1; i--) b.a_[i] = 0LL; for (int i = w; i &gt;= 1; i--) { long long l = 0LL, r = kRadix_ - 1, best = 0LL; while (l &lt;= r) { long long mid = (l + r) &gt;&gt; 1; if (BigInt(mid) * b &lt;= a) { best = mid; l = mid + 1; } else { r = mid - 1; } } a -= BigInt(best) * b; while (a.a_[0] &gt; 1 &amp;&amp; !a.a_[a.a_[0]]) a.a_[0]--; for (int i = 1; i &lt;= a_[0]; i++) b.a_[i] = b.a_[i + 1]; b.a_[0]--; } a.sign_ = sign_; w = a_[0]; while (w &gt; 1 &amp;&amp; !a.a_[w]) w--; a.a_[0] = w; if (w == 1 &amp;&amp; !a.a_[0]) a.sign_ = 0; return a; } inline BigInt BigInt::operator++(int) { BigInt tmp = *this; ++*this; return tmp; } inline BigInt BigInt::operator--(int) { BigInt tmp = *this; --*this; return tmp; } std::istream &amp;operator&gt;&gt;(std::istream &amp;in, BigInt &amp;lhs) { std::string s; in &gt;&gt; s; lhs = s; return in; } std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const BigInt &amp;lhs) { if (lhs.sign_ == -1) out &lt;&lt; '-'; int w = lhs.a_[0]; out &lt;&lt; lhs.a_[w]; for (int i = w - 1; i &gt;= 1; i--) out &lt;&lt; std::setw(lhs.kLen_) &lt;&lt; std::setfill('0') &lt;&lt; lhs.a_[i]; return out; } ","link":"http://xyf007.ml/post/gao-jing-du-mu-ban/"},{"title":"【模板】回文树","content":"class PalindromicTree { private: int tot_; char s_[500001]; int GetFail(int x) { while (s_[tot_ - t_[x].len - 1] != s_[tot_]) x = t_[x].fail; return x; } public: struct Node { int len, fail, ch[26], cnt; } t_[500005]; int sz_, last_; PalindromicTree() { sz_ = 1; t_[0].fail = t_[1].fail = 1, t_[1].len = -1; } void Expand(char c) { s_[++tot_] = c; int now = GetFail(last_); if (!t_[now].ch[c - 'a']) { int x = ++sz_; t_[x].len = t_[now].len + 2; t_[x].fail = t_[GetFail(t_[now].fail)].ch[c - 'a']; t_[x].cnt = t_[t_[x].fail].cnt + 1; t_[now].ch[c - 'a'] = x; } last_ = t_[now].ch[c - 'a']; } void Build(const char *s) { int n = std::strlen(s + 1); for (int i = 1; i &lt;= n; i++) Expand(s[i]); } ~PalindromicTree() {} } P; ","link":"http://xyf007.ml/post/mu-ban-hui-wen-shu/"},{"title":"【模板】矩阵树定理","content":"求 ∑T∏e∈Twe\\sum\\limits_T\\prod\\limits_{e\\in T}w_eT∑​e∈T∏​we​。 拉普拉斯矩阵 L=D−AL=D-AL=D−A，其中 DDD 是度数矩阵，AAA 是邻接矩阵。 无向图中 DDD 为邻边边权之和，有向图中分入度矩阵和出度矩阵。入度矩阵就是入边边权之和，出度矩阵就是出边边权之和。内向树用出度矩阵，外向树用入读矩阵。邻接矩阵就是出边边权之和。 以 iii 为根的树就是 LLL 去掉第 iii 行第 iii 列后行列式的值。 #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; constexpr int kMod = 1e9 + 7; template &lt;typename T&gt; T add(T a, T b) { return (a + b) % kMod; } template &lt;typename T, typename... Args&gt; T add(T a, T b, Args... args) { return add(add(a, b), args...); } template &lt;typename T&gt; T sub(T a, T b) { return (a + kMod - b) % kMod; } template &lt;typename T&gt; T mul(T a, T b) { return a * static_cast&lt;long long&gt;(b) % kMod; } template &lt;typename T, typename... Args&gt; T mul(T a, T b, Args... args) { return mul(mul(a, b), args...); } template &lt;typename T&gt; void Add(T &amp;a, T b) { a = add(a, b); } template &lt;typename T, typename... Args&gt; void Add(T &amp;a, T b, Args... args) { Add(a, add(b, args...)); } template &lt;typename T&gt; void Sub(T &amp;a, T b) { a = sub(a, b); } template &lt;typename T&gt; void Mul(T &amp;a, T b) { a = mul(a, b); } template &lt;typename T, typename... Args&gt; void Mul(T &amp;a, T b, Args... args) { Mul(a, mul(b, args...)); } template &lt;typename T1, typename T2&gt; T1 Ksm(T1 a, T2 b) { T1 s = 1; while (b) { if (b &amp; 1) Mul(s, a); Mul(a, a); b &gt;&gt;= 1; } return s; } template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } int n, m, t, d[301][301], a[301][301], l[301][301]; int Det(int n) { int s = 1, f = 0; for (int i = 1; i &lt;= n; i++) { int p = i; for (int j = i + 1; j &lt;= n; j++) if (l[j][i] &gt; l[p][i]) p = j; if (!l[p][i]) return 0; if (p != i) std::swap(l[p], l[i]), f ^= 1; int inv = Ksm(l[i][i], kMod - 2); for (int j = i + 1; j &lt;= n; j++) { int d = mul(l[j][i], inv); for (int k = i; k &lt;= n; k++) Sub(l[j][k], mul(l[i][k], d)); } Mul(s, l[i][i]); } return f ? (kMod - s) % kMod : s; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= m; i++) { int u, v, c; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; if (!t) { Add(d[u][u], c), Add(d[v][v], c); Add(a[u][v], c), Add(a[v][u], c); } else { Add(d[v][v], c), Add(a[u][v], c); } } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) l[i][j] = sub(d[i][j], a[i][j]); int rt = 1; for (int i = rt; i &lt; n; i++) for (int j = 1; j &lt;= n; j++) l[i][j] = l[i + 1][j]; for (int j = rt; j &lt; n; j++) for (int i = 1; i &lt; n; i++) l[i][j] = l[i][j + 1]; std::cout &lt;&lt; Det(n - 1); return 0; } ","link":"http://xyf007.ml/post/mu-ban-ju-zhen-shu-ding-li/"},{"title":"【模板】行列式求值","content":"#include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } int n, p, a[601][601]; template &lt;typename T&gt; T add(T a, T b) { return (a + b) % p; } template &lt;typename T, typename... Args&gt; T add(T a, T b, Args... args) { return add(add(a, b), args...); } template &lt;typename T&gt; T sub(T a, T b) { return (a + p - b) % p; } template &lt;typename T&gt; T mul(T a, T b) { return a * static_cast&lt;long long&gt;(b) % p; } template &lt;typename T, typename... Args&gt; T mul(T a, T b, Args... args) { return mul(mul(a, b), args...); } template &lt;typename T&gt; void Add(T &amp;a, T b) { a = add(a, b); } template &lt;typename T, typename... Args&gt; void Add(T &amp;a, T b, Args... args) { Add(a, add(b, args...)); } template &lt;typename T&gt; void Sub(T &amp;a, T b) { a = sub(a, b); } template &lt;typename T&gt; void Mul(T &amp;a, T b) { a = mul(a, b); } template &lt;typename T, typename... Args&gt; void Mul(T &amp;a, T b, Args... args) { Mul(a, mul(b, args...)); } template &lt;typename T1, typename T2&gt; T1 Ksm(T1 a, T2 b) { T1 s = 1; while (b) { if (b &amp; 1) Mul(s, a); Mul(a, a); b &gt;&gt;= 1; } return s; } int Det() { int s = 1, f = 0; for (int i = 1; i &lt;= n; i++) { int po = i; for (int j = i + 1; j &lt;= n; j++) if (a[j][i] &gt; a[po][i]) po = j; if (!a[po][i]) return 0; if (po != i) std::swap(a[po], a[i]), f ^= 1; for (int j = i + 1; j &lt;= n; j++) { if (a[j][i] &gt; a[i][i]) std::swap(a[j], a[i]), f ^= 1; while (a[j][i]) { int d = a[i][i] / a[j][i]; for (int k = i; k &lt;= n; k++) Sub(a[i][k], mul(a[j][k], d)); std::swap(a[i], a[j]), f ^= 1; } } Mul(s, a[i][i]); } return f ? (p - s) % p : s; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) std::cin &gt;&gt; a[i][j], a[i][j] %= p; std::cout &lt;&lt; Det(); return 0; } ","link":"http://xyf007.ml/post/mu-ban-hang-lie-shi-qiu-zhi/"},{"title":"【模板】扩展 KMP","content":"#include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } char a[20000001], b[20000001]; int n, m, z[20000001], p[20000001]; int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; (a + 1) &gt;&gt; (b + 1); n = std::strlen(a + 1), m = std::strlen(b + 1); z[1] = m; for (int i = 2, l = 0, r = 0; i &lt;= m; i++) { if (i &lt;= r) z[i] = std::min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= m &amp;&amp; b[i + z[i]] == b[z[i] + 1]) z[i]++; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; } for (int i = 1, l = 0, r = 0; i &lt;= n; i++) { if (i &lt;= r) p[i] = std::min(z[i - l + 1], r - i + 1); while (i + p[i] &lt;= n &amp;&amp; a[i + p[i]] == b[p[i] + 1]) p[i]++; if (i + p[i] - 1 &gt; r) l = i, r = i + p[i] - 1; } long long ans = 0LL; for (int i = 1; i &lt;= m; i++) ans ^= i * static_cast&lt;long long&gt;(z[i] + 1); std::cout &lt;&lt; ans &lt;&lt; '\\n'; ans = 0LL; for (int i = 1; i &lt;= n; i++) ans ^= i * static_cast&lt;long long&gt;(p[i] + 1); std::cout &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuo-zhan-kmp/"},{"title":"【模板】插头 DP","content":"#include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;numeric&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;tuple&gt; #include &lt;unordered_map&gt; #include &lt;unordered_set&gt; constexpr int kMod = 299993; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) x = y; } template &lt;typename T&gt; void checkmin(T &amp;x, T y) { if (x &gt; y) x = y; } struct Node { int S[2], nxt; long long dp[2]; } mp[300001]; int n, m, ex, ey, cur, lst, head[300001], E[2]; bool ok[15][15]; long long ans; char s[13][13]; auto decode = [](int S) { std::vector&lt;int&gt; v(m + 1); for (int i = 0; i &lt;= m; i++) v[i] = (S &gt;&gt; (2 * i)) &amp; 3; return v; }; auto encode = [](const std::vector&lt;int&gt; &amp;v) { int S = 0; for (int i = 0; i &lt;= m; i++) S += v[i] &lt;&lt; (2 * i); return S; }; void Insert(int S, long long v) { int u = S % kMod; for (int i = head[u]; i != -1; i = mp[i].nxt) if (S == mp[i].S[cur]) { mp[i].dp[cur] += v; return; } mp[E[cur]].S[cur] = S, mp[E[cur]].dp[cur] = v, mp[E[cur]].nxt = head[u]; head[u] = E[cur]++; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; (s[i] + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (s[i][j] == '.') ex = i, ey = j, ok[i][j] = true; std::memset(head, -1, sizeof(head)); Insert(0, 1LL); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { lst = cur, cur ^= 1; std::memset(head, -1, sizeof(head)), E[cur] = 0; for (int k = 0; k &lt; E[lst]; k++) { std::vector&lt;int&gt; S = decode(mp[k].S[lst]), T = S; int le = S[0], up = S[j]; long long d = mp[k].dp[lst]; if (s[i][j] == '*') { if (!le &amp;&amp; !up) Insert(encode(T), d); } else if (!le &amp;&amp; !up) { if (ok[i + 1][j] &amp;&amp; ok[i][j + 1]) { T[j] = 1, T[0] = 2; Insert(encode(T), d); } } else if (le &amp;&amp; !up) { if (ok[i + 1][j]) { T[j] = le, T[0] = 0; Insert(encode(T), d); T = S; } if (ok[i][j + 1]) Insert(encode(T), d); } else if (!le &amp;&amp; up) { if (ok[i + 1][j]) Insert(encode(T), d); if (ok[i][j + 1]) { T[0] = up, T[j] = 0; Insert(encode(T), d); T = S; } } else if (le == 2 &amp;&amp; up == 1) { T[0] = T[j] = 0; Insert(encode(T), d); } else if (le == 1 &amp;&amp; up == 1) { T[0] = T[j] = 0; int tmp = 1; for (int l = j + 1; l &lt;= m; l++) { if (T[l] == 1) tmp++; if (T[l] == 2) tmp--; if (!tmp) { T[l] = 1; break; } } Insert(encode(T), d); } else if (le == 2 &amp;&amp; up == 2) { T[0] = T[j] = 0; int tmp = -1; for (int l = j - 1; l &gt;= 1; l--) { if (T[l] == 1) tmp++; if (T[l] == 2) tmp--; if (!tmp) { T[l] = 2; break; } } Insert(encode(T), d); } else if (le == 1 &amp;&amp; up == 2) { T[0] = T[j] = 0; bool f = true; for (int l = 1; l &lt;= m; l++) f &amp;= !T[l]; if (f &amp;&amp; i == ex &amp;&amp; j == ey) ans += d; } } } std::cout &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-cha-tou-dp/"},{"title":"2–SAT","content":"2–SAT 简介 SAT 是适定性（Satisfiability）问题的简称。一般形式为 k-适定性问题，简称 k-SAT。但是当 k≥3k \\geq 3k≥3 时是 NP 完全的，因此在 OI 中我们只讨论 2-SAT 问题。 通俗的说，就是给你 nnn 个变量 aia_iai​，每个变量能且只能取 000 或 111 的值。同时给出若干条件，形式诸如 ai∧aj=0a_i \\land a_j=0ai​∧aj​=0，¬ai∨aj=1\\lnot a_i \\lor a_j=1¬ai​∨aj​=1 等。而求解 2-SAT 的解就是求出满足所有限制的一组 aia_iai​。 算法内容 将其转化成一个图论问题。 首先将每一个变量 aia_iai​ 拆成两个点 i0,i1i_0,i_1i0​,i1​，分别表示 aia_iai​ 选择 0/10/10/1。然后我们考虑建边来表示这些关系。令一条有向边 x→yx \\rightarrow yx→y 表示如果选择了 xxx 就必须选 yyy。那么我们可以举一些简单的例子来总结下连边的规律： ai∨aj=1a_i \\lor a_j=1ai​∨aj​=1：i0→j1,j0→i1i_0 \\rightarrow j_1,j_0 \\rightarrow i_1i0​→j1​,j0​→i1​。 ai∧aj=0a_i \\land a_j=0ai​∧aj​=0：i1→j0,j1→i0i_1 \\rightarrow j_0,j_1 \\rightarrow i_0i1​→j0​,j1​→i0​。 ai=1a_i=1ai​=1：i0→i1i_0 \\rightarrow i_1i0​→i1​。 剩下的情况可以类似写出。 然后用 Tarjan 缩点。如果 i0i_0i0​ 与 i1i_1i1​ 在同一个强连通分量中，表明 ai=0a_i=0ai​=0 且 ai=1a_i=1ai​=1，显然无解。否则对于每一个变量 aia_iai​，取 i0,i1i_0,i_1i0​,i1​ 所在的强联通分量编号较大的作为答案。 时间复杂度为 O(n+m)O(n+m)O(n+m)。 代码实现 以洛谷 P4782 【模板】2-SAT 问题 为例。 #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; struct edge { int to, nxt; } e[2000001]; int n, m, E, head[2000001], dfn[2000001], low[2000001], tot, s[2000001], top, col[2000001], c; bool vis[2000001]; void checkmin(int &amp;x, int y) { if (x &gt; y) x = y; } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void tarjan(int u) { dfn[u] = low[u] = ++tot; s[++top] = u; vis[u] = 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (!dfn[v]) { tarjan(v); checkmin(low[u], low[v]); } else if (vis[v]) { checkmin(low[u], dfn[v]); } } if (dfn[u] == low[u]) { col[u] = ++c; vis[u] = 0; while (s[top] != u) { col[s[top]] = c; vis[s[top--]] = 0; } top--; } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { int u, v, a, b; std::cin &gt;&gt; u &gt;&gt; a &gt;&gt; v &gt;&gt; b; add(u + !a * n, v + b * n); add(v + !b * n, u + a * n); } for (int i = 1; i &lt;= 2 * n; i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i++) { if (col[i] == col[i + n]) { std::cout &lt;&lt; &quot;IMPOSSIBLE&quot;; return 0; } } std::cout &lt;&lt; &quot;POSSIBLE\\n&quot;; for (int i = 1; i &lt;= n; i++) std::cout &lt;&lt; (col[i] &gt; col[i + n]) &lt;&lt; ' '; return 0; } 其他例题 HDU3062. Party 2-SAT 模板题，按照题意建图即可。 【NOI2017】游戏 可以发现如果没有 x，每个地图都只适合两种赛车，就是 2-SAT 模板题。而如果我们暴力枚举每一个 x 的地图是适合 AB 或适合 AC，并不会漏掉合法解，因此总复杂度为 O(2d×(n+m))O(2^{d} \\times (n+m))O(2d×(n+m))。 SGU307. Cipher 你会发现他非常像联合省选 2021 D1T2。 其实我们不难看出，整个网格的状态是由第一行和第一列决定的。我们不妨枚举 (0,0)(0,0)(0,0) 的状态，然后再根据给出的和对于所有其他第一行和第一列的格子做限制。然后通过 2-SAT 得出第一行和第一列的合法状态。最后简单递推即可。 具体的限制如图： 【UER #6】寻找罪犯 首先是要围绕每个人是否是犯人和每句话是否是真话来思考。 我们已知如下条件： 好人不说谎话。 说了谎话的只能是坏人。 所以我们就知道了一组对称的限制条件： 好人 ⟹ \\implies⟹ 之前没说过谎话； 之前 ⟹ \\implies⟹ 说过谎话坏人。 如何判断一句话是否是谎话？ 这个人说的话和事实不相符，这也是一种限制条件。同时还有一个很重要的条件：哪怕是坏人，也最多只说一句谎话。如果当前是谎话，那这个人之前所说的所有话和之后所说的所有话都是真话。因此考虑对前后缀建点。 ","link":"http://xyf007.ml/post/2-sat/"},{"title":"【模板】威佐夫博弈","content":" 有两堆石子，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取的人输。 假设两堆石子为 x,y(x&lt;y)x,y(x&lt;y)x,y(x&lt;y)，那么先手必败，当且仅当 (y−x)×ϕ=x(y-x) \\times \\phi=x(y−x)×ϕ=x，这里 ϕ=5+12\\phi=\\dfrac{\\sqrt{5}+1}{2}ϕ=25​+1​。 constexpr double kPhi = 1.6180339887498948482045868343656381177203; int main(int argc, char const *argv[]) { Read(a, b); if (a &gt; b) std::swap(a, b); std::printf(&quot;%c&quot;, &quot;10&quot;[static_cast&lt;int&gt;((b - a) * kPhi) == a]); return 0; } ","link":"http://xyf007.ml/post/mu-ban-wei-zuo-fu-bo-yi/"},{"title":"【模板】多项式指数函数","content":"求 eF(x)e^{F(x)}eF(x)。 O(nlog⁡2n)O(n \\log^2 n)O(nlog2n) 的做法 令 G(x)=eF(x)G(x)=e^{F(x)}G(x)=eF(x)，两边求导可得 G′(x)=F′(x)eF(x)G&#x27;(x)=F&#x27;(x)e^{F(x)}G′(x)=F′(x)eF(x)，即 G′(x)=F′(x)∗G(x)G&#x27;(x)=F&#x27;(x)*G(x)G′(x)=F′(x)∗G(x)。则 [xn]G′(x)=[xn]F′(x)∗G(x)(n+1)gn+1=∑i=0n(n−i+1)fn−i+1gign=∑i=0n−1(n−i)fn−igin\\begin{aligned} [x^n]G&#x27;(x)&amp;=[x^n]F&#x27;(x)*G(x)\\\\ (n+1)g_{n+1}&amp;=\\sum_{i=0}^n(n-i+1)f_{n-i+1}g_i\\\\ g_n&amp;=\\dfrac{\\sum_{i=0}^{n-1}(n-i)f_{n-i}g_i}{n} \\end{aligned} [xn]G′(x)(n+1)gn+1​gn​​=[xn]F′(x)∗G(x)=i=0∑n​(n−i+1)fn−i+1​gi​=n∑i=0n−1​(n−i)fn−i​gi​​​ 分治 FFT 计算即可。 O(nlog⁡n)O(n \\log n)O(nlogn) 的做法 牛顿迭代：给定多项式 g(x)g(x)g(x)，求 f(x)f(x)f(x) 满足 g(f(x))≡0(modxn)g(f(x)) \\equiv 0 \\pmod{x^n}g(f(x))≡0(modxn)。 倍增，先求出 [x0]g(f(x))=0[x^0]g(f(x))=0[x0]g(f(x))=0 的解。 假设已求得模 xn2x^{\\frac{n}{2}}x2n​ 意义下的解 f0(x)f_0(x)f0​(x)，通过泰勒展开可得 f(x)≡f0(x)−g(f0(x))g′(f0(x))(modxn)f(x) \\equiv f_0(x)-\\dfrac{g(f_0(x))}{g&#x27;(f_0(x))} \\pmod{x^n}f(x)≡f0​(x)−g′(f0​(x))g(f0​(x))​(modxn)。 在这里 ln⁡f(x)−F(x)=0≡g(f(x))(modxn)\\ln f(x)-F(x)=0 \\equiv g(f(x)) \\pmod{x^n}lnf(x)−F(x)=0≡g(f(x))(modxn)，因此 f(x)≡f0(x)−ln⁡f0(x)−F(x)1f0(x)≡f0(x)(1−ln⁡f0(x)+F(x))(modxn)f(x) \\equiv f_0(x)-\\dfrac{\\ln f_0(x)-F(x)}{\\dfrac{1}{f_0(x)}} \\equiv f_0(x)(1-\\ln f_0(x)+F(x)) \\pmod{x^n}f(x)≡f0​(x)−f0​(x)1​lnf0​(x)−F(x)​≡f0​(x)(1−lnf0​(x)+F(x))(modxn)。 void Exp(int *a, int *b, int n) { static int f[800001]; b[0] = 1; for (int len = 2; len &lt;= n; len &lt;&lt;= 1) { std::memset(f, 0, 4 * len); Ln(b, f, len); f[0] = sub(add(1, a[0]), f[0]); for (int i = 1; i &lt; len; i++) { f[i] = sub(a[i], f[i]); } std::memset(f + len, 0, 4 * len); Ntt(b, len &lt;&lt; 1, 1); Ntt(f, len &lt;&lt; 1, 1); for (int i = 0; i &lt; (len &lt;&lt; 1); i++) { Mul(b[i], f[i]); } Ntt(b, len &lt;&lt; 1, -1); std::memset(b + len, 0, 4 * len); } } ","link":"http://xyf007.ml/post/mu-ban-duo-xiang-shi-zhi-shu-han-shu/"},{"title":"【模板】多项式对数函数","content":"求 ln⁡f(x)\\ln f(x)lnf(x)。 对 ln⁡f(x)\\ln f(x)lnf(x) 求导再积分，可得 ln⁡f(x)≡∫dln⁡x≡∫f′(x)f(x)dx(modxn)\\ln f(x) \\equiv \\int \\mathrm{d} \\ln x \\equiv \\int \\dfrac{f&#x27;(x)}{f(x)} \\mathrm{d}x \\pmod{x^n}lnf(x)≡∫dlnx≡∫f(x)f′(x)​dx(modxn)，而多项式求导和积分都是 O(n)O(n)O(n) 的，多项式求逆是 O(nlog⁡n)O(n \\log n)O(nlogn) 的，所以复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 void Ln(int *a, int *b, int n) { static int c[800001], f[800001]; for (int i = 0; i &lt; n - 1; i++) { c[i] = mul(a[i + 1], i + 1); } std::memset(f, 0, 4 * n); Inv(a, f, n); Ntt(c, n &lt;&lt; 1, 1); Ntt(f, n &lt;&lt; 1, 1); for (int i = 0; i &lt; (n &lt;&lt; 1); i++) { Mul(f[i], c[i]); } Ntt(f, n &lt;&lt; 1, -1); for (int i = n - 1; i &gt;= 1; i--) { b[i] = mul(f[i - 1], inv[i]); } } ","link":"http://xyf007.ml/post/mu-ban-duo-xiang-shi-dui-shu-han-shu/"},{"title":"【模板】广义后缀自动机（广义 SAM）","content":"#include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;numeric&gt; int n; char s[1000001]; class GeneralSuffixAutomaton { public: struct Node { int len, link, nxt[26]; } t_[2000001]; int sz_, last_; GeneralSuffixAutomaton() { t_[0].link = -1; } void Expand(char); void Build(const char *); ~GeneralSuffixAutomaton() {} } S; void GeneralSuffixAutomaton::Expand(char c) { int p = last_; if (t_[p].nxt[c - 'a']) { int q = t_[p].nxt[c - 'a']; if (t_[q].len == t_[p].len + 1) { last_ = q; } else { int nq = ++sz_; t_[nq].len = t_[p].len + 1; t_[nq].link = t_[q].link; std::memcpy(t_[nq].nxt, t_[q].nxt, sizeof(t_[nq].nxt)); while (p != -1 &amp;&amp; t_[p].nxt[c - 'a'] == q) { t_[p].nxt[c - 'a'] = nq; p = t_[p].link; } t_[q].link = nq; last_ = nq; } return; } int cur = ++sz_; t_[cur].len = t_[p].len + 1; while (p != -1 &amp;&amp; !t_[p].nxt[c - 'a']) { t_[p].nxt[c - 'a'] = cur; p = t_[p].link; } if (p == -1) { t_[cur].link = 0; } else { int q = t_[p].nxt[c - 'a']; if (t_[q].len == t_[p].len + 1) { t_[cur].link = q; } else { int nq = ++sz_; t_[nq].len = t_[p].len + 1; t_[nq].link = t_[q].link; std::memcpy(t_[nq].nxt, t_[q].nxt, sizeof(t_[q].nxt)); while (p != -1 &amp;&amp; t_[p].nxt[c - 'a'] == q) { t_[p].nxt[c - 'a'] = nq; p = t_[p].link; } t_[cur].link = t_[q].link = nq; } } last_ = cur; } void GeneralSuffixAutomaton::Build(const char *s) { last_ = 0; std::size_t n = std::strlen(s); for (std::size_t i = 0; i &lt; n; i++) { Expand(s[i]); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; s; S.Build(s); } long long ans = 0LL; for (int i = 1; i &lt;= S.sz_; i++) { ans += S.t_[i].len - S.t_[S.t_[i].link].len; } std::cout &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-guang-yi-hou-zhui-zi-dong-ji-guang-yi-sam/"},{"title":"【模板】李超树","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;numeric&gt; constexpr int kMod = 39989, kMody = 1e9; struct Segment { int id; double k, b; Segment(int id = 0, double k = 0.0, double b = 0.0) : id(id), k(k), b(b) {} } t[200001]; double F(Segment s, int x) { return s.k * x + s.b; } int n; void Modify(int L, int R, int l, int r, Segment v, int x) { int mid = (l + r) &gt;&gt; 1; if (L &lt;= l &amp;&amp; r &lt;= R) { if (F(t[x], mid) &lt; F(v, mid) || !t[x].id) { std::swap(t[x], v); } double p = (v.b - t[x].b) / (t[x].k - v.k); if (l == r || t[x].k == v.k || p &lt; l || p &gt; r || !v.id) { return; } if (v.k &lt; t[x].k) { Modify(L, R, l, mid, v, x + x); } else { Modify(L, R, mid + 1, r, v, x + x + 1); } return; } if (L &lt;= mid) { Modify(L, R, l, mid, v, x + x); } if (R &gt; mid) { Modify(L, R, mid + 1, r, v, x + x + 1); } } Segment Query(int l, int r, int p, int x) { if (l == r) { return t[x]; } int mid = (l + r) &gt;&gt; 1; Segment res; if (p &lt;= mid) { res = Query(l, mid, p, x + x); } else { res = Query(mid + 1, r, p, x + x + 1); } return F(res, p) &gt; F(t[x], p) ? res : t[x]; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n; int lastans = 0, op, x0, x1, y0, y1, k, tot = 0; auto decode = [&amp;lastans](int &amp;x, const int &amp;mod) -&gt; void { x = (x + lastans - 1) % mod + 1; }; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; op; if (!op) { std::cin &gt;&gt; k; decode(k, kMod); std::cout &lt;&lt; (lastans = Query(1, kMod, k, 1).id) &lt;&lt; '\\n'; } else { std::cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; x1 &gt;&gt; y1; decode(x0, kMod); decode(y0, kMody); decode(x1, kMod); decode(y1, kMody); Segment s; s.id = ++tot; if (x0 &gt; x1) { std::swap(x0, x1); std::swap(y0, y1); } if (x0 == x1) { s.k = 0.0; s.b = std::max(y0, y1); } else { s.k = (y1 - y0) / static_cast&lt;double&gt;(x1 - x0); s.b = y0 - s.k * x0; } Modify(x0, x1, 1, kMod, s, 1); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-li-chao-shu/"},{"title":"【模板】动态 DP","content":"线段树维护转移矩阵。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;numeric&gt; struct Edge { int to, nxt; } e[200001]; int n, m, E, head[100001], a[100001], f[100001][2], fa[100001], sz[100001], son[100001], top[100001], bot[100001], dfn[100001], tot, id[100001]; void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } void Add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } class Matrix { public: int a_[2][2]; Matrix() { std::memset(a_, ~0x3f, sizeof(a_)); } Matrix operator*(const Matrix &amp;) const; ~Matrix() {} } t[400001], g[100001]; Matrix Matrix::operator*(const Matrix &amp;b) const { Matrix s; for (int i = 0; i &lt; 2; i++) { for (int k = 0; k &lt; 2; k++) { for (int j = 0; j &lt; 2; j++) { checkmax(s.a_[i][j], a_[i][k] + b.a_[k][j]); } } } return s; } void Dfs(int u, int f) { sz[u] = 1; fa[u] = f; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == f) { continue; } Dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[son[u]]) { son[u] = v; } } } void Dfs2(int u, int t) { id[dfn[u] = ++tot] = u; top[u] = t; checkmax(bot[t], tot); f[u][1] = g[u].a_[1][0] = a[u]; g[u].a_[0][0] = g[u].a_[0][1] = 0; if (son[u]) { Dfs2(son[u], t); f[u][0] += std::max(f[son[u]][0], f[son[u]][1]); f[u][1] += f[son[u]][0]; } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa[u] || v == son[u]) { continue; } Dfs2(v, v); f[u][0] += std::max(f[v][0], f[v][1]); f[u][1] += f[v][0]; g[u].a_[0][0] = g[u].a_[0][1] += std::max(f[v][0], f[v][1]); g[u].a_[1][0] += f[v][0]; } } void Pushup(int x) { t[x] = t[x + x] * t[x + x + 1]; } void Build(int l, int r, int x) { if (l == r) { t[x] = g[id[l]]; return; } int mid = (l + r) &gt;&gt; 1; Build(l, mid, x + x); Build(mid + 1, r, x + x + 1); Pushup(x); } void Modify(int l, int r, int p, int x) { if (l == r) { t[x] = g[id[p]]; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { Modify(l, mid, p, x + x); } else { Modify(mid + 1, r, p, x + x + 1); } Pushup(x); } Matrix Query(int L, int R, int l, int r, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { return t[x]; } int mid = (l + r) &gt;&gt; 1; if (L &gt; mid) { return Query(L, R, mid + 1, r, x + x + 1); } else if (R &lt;= mid) { return Query(L, R, l, mid, x + x); } else { return Query(L, R, l, mid, x + x) * Query(L, R, mid + 1, r, x + x + 1); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; } for (int i = 1; i &lt; n; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; Add(u, v); Add(v, u); } Dfs(1, 0); Dfs2(1, 1); Build(1, n, 1); for (int i = 1; i &lt;= m; i++) { int x, y; std::cin &gt;&gt; x &gt;&gt; y; g[x].a_[1][0] += y - a[x]; a[x] = y; Matrix pre, nxt, ans; while (x) { pre = Query(dfn[top[x]], bot[top[x]], 1, n, 1); Modify(1, n, dfn[x], 1); nxt = Query(dfn[top[x]], bot[top[x]], 1, n, 1); x = fa[top[x]]; g[x].a_[0][0] = g[x].a_[0][1] += std::max(nxt.a_[0][0], nxt.a_[1][0]) - std::max(pre.a_[0][0], pre.a_[1][0]); g[x].a_[1][0] += nxt.a_[0][0] - pre.a_[0][0]; } ans = Query(1, bot[1], 1, n, 1); std::cout &lt;&lt; std::max(ans.a_[0][0], ans.a_[1][0]) &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dong-tai-dp/"},{"title":"【模板】带修莫队","content":"加一维时间轴，复杂度 O(n53)O(n^{\\frac{5}{3}})O(n35​)。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; struct Query { int l, r, t, id; } q[133334]; struct Modify { int x, pre, now; } b[133334]; int n, m, B, a[133334], pos[133334], tot, ans[133334], cnt[1000001]; int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m; B = std::pow(n, 2.0 / 3.0); for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; pos[i] = (i - 1) / B + 1; } char op[10]; int t = 0; for (int i = 1; i &lt;= m; i++) { std::cin &gt;&gt; op; if (op[0] == 'Q') { tot++; std::cin &gt;&gt; q[tot].l &gt;&gt; q[tot].r; q[tot].t = t; q[tot].id = tot; } else { t++; std::cin &gt;&gt; b[t].x &gt;&gt; b[t].now; b[t].pre = a[b[t].x]; a[b[t].x] = b[t].now; } } for (int i = t; i &gt;= 1; i--) { a[b[i].x] = b[i].pre; } t = 0; std::sort(q + 1, q + tot + 1, [](const Query &amp;x, const Query &amp;y) -&gt; bool { return pos[x.l] == pos[y.l] ? pos[x.r] == pos[y.r] ? x.t &lt; y.t : pos[x.r] &lt; pos[y.r] : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0, sum = 0; for (int i = 1; i &lt;= tot; i++) { while (l &gt; q[i].l) { sum += !cnt[a[--l]]++; } while (r &lt; q[i].r) { sum += !cnt[a[++r]]++; } while (l &lt; q[i].l) { sum -= !--cnt[a[l++]]; } while (r &gt; q[i].r) { sum -= !--cnt[a[r--]]; } while (t &lt; q[i].t) { t++; if (b[t].x &gt;= l &amp;&amp; b[t].x &lt;= r) { sum -= !--cnt[a[b[t].x]]; sum += !cnt[b[t].now]++; } a[b[t].x] = b[t].now; } while (t &gt; q[i].t) { if (b[t].x &gt;= l &amp;&amp; b[t].x &lt;= r) { sum -= !--cnt[a[b[t].x]]; sum += !cnt[b[t].pre]++; } a[b[t].x] = b[t].pre; t--; } ans[q[i].id] = sum; } for (int i = 1; i &lt;= tot; i++) { std::cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dai-xiu-mo-dui/"},{"title":"【模板】树上莫队","content":"把树变成欧拉序（括号序）然后莫队。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; struct Edge { int to, nxt; } e[80001]; struct Query { int l, r, id, lca; } q[100001]; int n, m, E, head[40001], a[40001], b[40001], dfn[80001], in[40001], out[40001], tot, dep[40001], fa[40001], top[40001], sz[40001], son[40001], vis[40001], B, pos[80001], cnt[40001], ans[100001], sum; void Add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int f) { dep[u] = dep[f] + 1; fa[u] = f; sz[u] = 1; dfn[in[u] = ++tot] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == f) { continue; } Dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[son[u]]) { son[u] = v; } } dfn[out[u] = ++tot] = u; } void Dfs2(int u, int t) { top[u] = t; if (son[u]) { Dfs2(son[u], t); } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa[u] || v == son[u]) { continue; } Dfs2(v, v); } } int GetLca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) { std::swap(u, v); } u = fa[top[u]]; } return dep[u] &lt; dep[v] ? u : v; } void Modify(int x) { if (vis[x] ^= 1) { sum += !cnt[a[x]]++; } else { sum -= !--cnt[a[x]]; } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; } std::memcpy(b + 1, a + 1, 4 * n); std::sort(b + 1, b + n + 1); int nn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) { a[i] = std::lower_bound(b + 1, b + nn + 1, a[i]) - b; } for (int i = 1; i &lt; n; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; Add(u, v); Add(v, u); } Dfs(1, 0); Dfs2(1, 1); B = std::sqrt(n &lt;&lt; 1); for (int i = 1; i &lt;= 2 * n; i++) { pos[i] = (i - 1) / B + 1; } for (int i = 1; i &lt;= m; i++) { int u, v, lca; std::cin &gt;&gt; u &gt;&gt; v; q[i].id = i; if (in[u] &gt; in[v]) { std::swap(u, v); } lca = GetLca(u, v); if (u == lca) { q[i].l = in[u]; q[i].r = in[v]; } else { q[i].l = out[u]; q[i].r = in[v]; q[i].lca = lca; } } std::sort(q + 1, q + m + 1, [](const Query &amp;x, const Query &amp;y) -&gt; bool { return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) { Modify(dfn[--l]); } while (r &lt; q[i].r) { Modify(dfn[++r]); } while (l &lt; q[i].l) { Modify(dfn[l++]); } while (r &gt; q[i].r) { Modify(dfn[r--]); } if (q[i].lca) { Modify(q[i].lca); } ans[q[i].id] = sum; if (q[i].lca) { Modify(q[i].lca); } } for (int i = 1; i &lt;= m; i++) { std::cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-shu-shang-mo-dui/"},{"title":"【模板】线段树分治","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;numeric&gt; struct Edge { int u, v; } e[200001]; int n, m, k; std::vector&lt;int&gt; v[400001]; class DisjointSet { private: int fa_[200001], s_[200001], top_, sz_[200001]; public: DisjointSet() {} void Init(); int Find(int); void Merge(int, int); void Undo(); ~DisjointSet() {} friend void Dfs(int, int, int); } T; void DisjointSet::Init() { std::iota(fa_ + 1, fa_ + 2 * n + 1, 1); std::fill(sz_ + 1, sz_ + 2 * n + 1, 1); } int DisjointSet::Find(int x) { while (x != fa_[x]) { x = fa_[x]; } return x; } void DisjointSet::Merge(int x, int y) { x = Find(x); y = Find(y); if (x == y) { return; } if (sz_[x] &gt; sz_[y]) { std::swap(x, y); } s_[++top_] = x; sz_[y] += sz_[x]; fa_[x] = y; } void DisjointSet::Undo() { int x = s_[top_--]; sz_[fa_[x]] -= sz_[x]; fa_[x] = x; } void Insert(int L, int R, int l, int r, int val, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { v[x].emplace_back(val); return; } int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) { Insert(L, R, l, mid, val, x + x); } if (R &gt; mid) { Insert(L, R, mid + 1, r, val, x + x + 1); } } void Dfs(int l, int r, int x) { bool f = true; int top = T.top_; for (auto &amp;&amp;i : v[x]) { int fu = T.Find(e[i].u), fv = T.Find(e[i].v); if (fu == fv) { for (int j = l; j &lt;= r; j++) { std::cout &lt;&lt; &quot;No\\n&quot;; } f = false; break; } T.Merge(fu, T.Find(e[i].v + n)); T.Merge(fv, T.Find(e[i].u + n)); } if (f) { if (l == r) { std::cout &lt;&lt; &quot;Yes\\n&quot;; } else { int mid = (l + r) &gt;&gt; 1; Dfs(l, mid, x + x); Dfs(mid + 1, r, x + x + 1); } } while (T.top_ &gt; top) { T.Undo(); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int l, r; for (int i = 1; i &lt;= m; i++) { std::cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; l &gt;&gt; r; if (l == r) { continue; } Insert(l + 1, r, 1, k, i, 1); } T.Init(); Dfs(1, k, 1); return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-duan-shu-fen-zhi/"},{"title":"【模板】莫队二次离线","content":"将贡献差分，打标记，要手推式子。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;numeric&gt; struct Query { int l, r, id; long long ans; } q[100001]; struct Node { int l, r, id, op; Node(int l = 0, int r = 0, int id = 0, int op = 0) : l(l), r(r), id(id), op(op) {} }; int n, m, B, tot, k, a[100001], pos[100001], pre[100001], cnt[16384]; std::vector&lt;int&gt; v; std::vector&lt;Node&gt; b[100001]; int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; if (k &gt; 14) { for (int i = 1; i &lt;= m; i++) { std::cout &lt;&lt; &quot;0\\n&quot;; } return 0; } B = std::sqrt(n); tot = (n - 1) / B + 1; for (int i = 0; i &lt; 16384; i++) { if (__builtin_popcount(i) == k) { v.emplace_back(i); } } for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; pos[i] = (i - 1) / B + 1; } for (int i = 1; i &lt;= n; i++) { pre[i] = cnt[a[i]]; for (auto &amp;&amp;j : v) { cnt[j ^ a[i]]++; } } for (int i = 1; i &lt;= m; i++) { std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } std::sort(q + 1, q + m + 1, [](const Query &amp;x, const Query &amp;y) -&gt; bool { return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { if (l &gt; q[i].l) { b[r].emplace_back(q[i].l, l - 1, i, 1); } while (l &gt; q[i].l) { q[i].ans -= pre[--l]; } if (r &lt; q[i].r) { b[l - 1].emplace_back(r + 1, q[i].r, i, -1); } while (r &lt; q[i].r) { q[i].ans += pre[++r]; } if (l &lt; q[i].l) { b[r].emplace_back(l, q[i].l - 1, i, -1); } while (l &lt; q[i].l) { q[i].ans += pre[l++]; } if (r &gt; q[i].r) { b[l - 1].emplace_back(q[i].r + 1, r, i, 1); } while (r &gt; q[i].r) { q[i].ans -= pre[r--]; } } std::memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) { for (auto &amp;&amp;j : v) { cnt[a[i] ^ j]++; } for (auto &amp;&amp;j : b[i]) { for (int o = j.l; o &lt;= j.r; o++) { if (o &lt; i &amp;&amp; !k) { q[j.id].ans += j.op * (cnt[a[o]] - 1); } else { q[j.id].ans += j.op * cnt[a[o]]; } } } } for (int i = 1; i &lt;= m; i++) { q[i].ans += q[i - 1].ans; } std::sort(q + 1, q + m + 1, [](const Query &amp;x, const Query &amp;y) -&gt; bool { return x.id &lt; y.id; }); for (int i = 1; i &lt;= m; i++) { std::cout &lt;&lt; q[i].ans &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-mo-dui-er-ci-li-xian/"},{"title":"【模板】回滚莫队","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; struct Query { int l, r, id; } q[200001]; int n, m, B, tot, a[200001], b[200001], pos[200001], L[501], R[501], fst[200001], lst[200001], c[200001], cnt, ans[200001]; template &lt;typename T&gt; void Read(T &amp;x) { x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') { c = getchar(); } x = c - '0'; while ((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') { x = x * 10 + c - '0'; } } template &lt;typename T, typename... Args&gt; void Read(T &amp;x, Args &amp;...args) { Read(x); Read(args...); } void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } int Calc(int l, int r) { int ans = 0; for (int i = l; i &lt;= r; i++) { if (!fst[a[i]]) { fst[a[i]] = i; } else { checkmax(ans, i - fst[a[i]]); } } for (int i = l; i &lt;= r; i++) { fst[a[i]] = 0; } return ans; } int main(int argc, char const *argv[]) { Read(n); B = std::sqrt(n); tot = (n - 1) / B + 1; for (int i = 1; i &lt;= n; i++) { Read(a[i]); pos[i] = (i - 1) / B + 1; } for (int i = 1; i &lt; tot; i++) { L[i] = (i - 1) * B + 1; R[i] = i * B; } L[tot] = (tot - 1) * B + 1; R[tot] = n; std::memcpy(b + 1, a + 1, 4 * n); std::sort(b + 1, b + n + 1); int nn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) { a[i] = std::lower_bound(b + 1, b + nn + 1, a[i]) - b; } Read(m); for (int i = 1; i &lt;= m; i++) { Read(q[i].l, q[i].r); q[i].id = i; } std::sort(q + 1, q + m + 1, [](const Query &amp;x, const Query &amp;y) -&gt; bool { return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int p = 1; for (int i = 1; i &lt;= tot; i++) { int l = R[i] + 1, r = R[i], max = 0; cnt = 0; while (p &lt;= m &amp;&amp; pos[q[p].l] == i) { if (pos[q[p].r] == i) { ans[q[p].id] = Calc(q[p].l, q[p].r); } else { while (r &lt; q[p].r) { r++; lst[a[r]] = r; if (!fst[a[r]]) { fst[a[r]] = r; c[++cnt] = a[r]; } checkmax(max, r - fst[a[r]]); } int tmp = max; while (l &gt; q[p].l) { l--; if (!lst[a[l]]) { lst[a[l]] = l; } else { checkmax(max, lst[a[l]] - l); } } ans[q[p].id] = max; while (l &lt;= R[i]) { if (lst[a[l]] == l) { lst[a[l]] = 0; } l++; } max = tmp; } p++; } for (int i = 1; i &lt;= cnt; i++) { fst[c[i]] = lst[c[i]] = 0; } } for (int i = 1; i &lt;= m; i++) { std::cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-hui-gun-mo-dui/"},{"title":"【学习笔记】Burnside 引理","content":"Burnside 引理学习笔记 前言 略去所有的定义及证明，只考虑如何用来解题。 正题 设 GGG 是一个作用在集合 XXX 上的有限群。对 g∈Gg \\in Gg∈G，设 XgX^gXg 表示 XXX 中在 ggg 作用下的不动元素（也称轨道数），则表示 GGG 作用在 XXX 上产生的所有等价类的集合 X/GX/GX/G 满足: ∣X/G∣=1∣G∣∑g∈G∣Xg∣|X/G|=\\dfrac{1}{|G|}\\sum\\limits_{g \\in G}|X^g| ∣X/G∣=∣G∣1​g∈G∑​∣Xg∣ 例： 给长度为 nnn 的环用 mmm 种颜色染色，求本质不同方案数。 将旋转操作作为置换群中的元素，求出每一种置换对应的不动点数为 gcd⁡(n,i)\\gcd(n,i)gcd(n,i)。 故答案为 1n∑i=1nmgcd⁡(n,i)\\dfrac{1}{n}\\sum_{i=1}^nm^{\\gcd(n,i)}n1​∑i=1n​mgcd(n,i)。 重要的一点： 一个轨道内所有的元素是一样的。 奥妙重重的立体置换群 给一个立方体染色方案数。 三维空间的旋转有多种，面的中心、棱的中心、顶点的中心连线都可以做对称轴。 转的角度可以考虑平面展开图。 旋转 角度 数量 面 棱 点 不转 0°0\\degree0° 111 (1)6(1)^6(1)6 (1)12(1)^{12}(1)12 (1)8(1)^8(1)8 面面 90°90\\degree90° 333 (1)2(4)1(1)^2(4)^1(1)2(4)1 (4)3(4)^3(4)3 (4)2(4)^2(4)2 面面 180°180\\degree180° 333 (1)2(2)2(1)^2(2)^2(1)2(2)2 (2)6(2)^6(2)6 (2)4(2)^4(2)4 面面 270°270\\degree270° 333 (1)2(4)1(1)^2(4)^1(1)2(4)1 (4)3(4)^3(4)3 (4)2(4)^2(4)2 棱棱 180°180\\degree180° 666 (2)3(2)^3(2)3 (1)2(2)5(1)^2(2)^5(1)2(2)5 (2)4(2)^4(2)4 点点 120°120\\degree120° 444 (3)2(3)^2(3)2 (3)4(3)^4(3)4 (1)2(3)2(1)^2(3)^2(1)2(3)2 点点 240°240\\degree240° 444 (3)2(3)^2(3)2 (3)4(3)^4(3)4 (1)2(3)2(1)^2(3)^2(1)2(3)2 立体图形外角和：点数 ×(180°−∑内角和)=720°\\times(180\\degree-\\sum\\text{内角和})=720\\degree×(180°−∑内角和)=720°。 ","link":"http://xyf007.ml/post/xue-xi-bi-ji-burnside-yin-li/"},{"title":"【模板】最小圆覆盖","content":"Circle SmallestCircle(const std::vector&lt;Point&gt; &amp;b) { std::vector&lt;Point&gt; a(b); std::srand(std::chrono::_V2::steady_clock::now().time_since_epoch().count()); std::random_shuffle(a.begin(), a.end()); Circle O(a.front()); for (size_t i = 1; i &lt; a.size(); i++) { if (!O.InCircle(a.at(i))) { O = Circle(a.at(i)); for (size_t j = 0; j &lt; i; j++) { if (!O.InCircle(a.at(j))) { O = Circle(a.at(i), a.at(j)); for (size_t k = 0; k &lt; j; k++) { if (!O.InCircle(a.at(k))) { O = Circle(a.at(i), a.at(j), a.at(k)); } } } } } } return O; } ","link":"http://xyf007.ml/post/mu-ban-zui-xiao-yuan-fu-gai/"},{"title":"【模板】二维凸包","content":"Polygon ConvexHull(const std::vector&lt;Point&gt; &amp;b) { std::vector&lt;Point&gt; a(b), s; std::swap(*a.begin(), *std::min_element(a.begin(), a.end(), [](const Point &amp;x, const Point &amp;y) -&gt; bool { return x.y_ &lt; y.y_; })); s.emplace_back(a.at(0)); std::sort(a.begin() + 1, a.end(), [&amp;a](const Point &amp;x, const Point &amp;y) -&gt; bool { return Vector(*a.begin(), x).IsCcw(Vector(*a.begin(), y)); }); s.emplace_back(a.at(1)); int top = 1; for (size_t i = 2; i &lt; a.size(); i++) { while (top &amp;&amp; !Vector(s.at(top - 1), s.back()).IsCcw(Vector(s.at(top - 1), a.at(i)))) { s.pop_back(); top--; } s.emplace_back(a.at(i)); top++; } return s; } ","link":"http://xyf007.ml/post/mu-ban-er-wei-tu-bao/"},{"title":"【模板】计算几何代码头","content":"#include &lt;algorithm&gt; #include &lt;chrono&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;set&gt; #include &lt;vector&gt; #ifndef M_PI_2 #define M_PI_2 1.57079632679489661923 #endif constexpr double kEps = 1e-10; constexpr int kPrecision = 8; std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count()); int Sign(const double &amp;x) { if (std::fabs(x) &lt; kEps) return 0; return x &gt;= kEps ? 1 : -1; } class Vector; class Point { public: double x_, y_; Point() {} Point(double x, double y) : x_(x), y_(y) {} Point(const std::pair&lt;double, double&gt; &amp;b) : x_(b.first), y_(b.second) {} Point &amp;operator=(const std::pair&lt;double, double&gt; &amp;b) { this-&gt;x_ = b.first, this-&gt;y_ = b.second; return *this; } Point &amp;operator=(const Point &amp;b) { this-&gt;x_ = b.x_, this-&gt;y_ = b.y_; return *this; } Point operator+(const Vector &amp;) const; Point operator-(const Vector &amp;) const; Point &amp;operator+=(const Vector &amp;b) { return *this = *this + b; } Point &amp;operator-=(const Vector &amp;b) { return *this = *this - b; } friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Point &amp;a) { in &gt;&gt; a.x_ &gt;&gt; a.y_; return in; } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Point &amp;a) { out &lt;&lt; std::setprecision(kPrecision) &lt;&lt; std::fixed &lt;&lt; a.x_ &lt;&lt; ',' &lt;&lt; a.y_; return out; } ~Point() {} }; class Vector { public: double x_, y_; Vector() {} Vector(double x, double y) : x_(x), y_(y) {} Vector(const std::pair&lt;double, double&gt; &amp;b) : x_(b.first), y_(b.second) {} Vector(Point a, Point b) { x_ = b.x_ - a.x_, y_ = b.y_ - a.y_; } double Magnitude() const { return std::hypot(x_, y_); } double PolarAngle() const { return std::atan2(y_, x_); } Vector &amp;operator=(const std::pair&lt;double, double&gt; &amp;b) { this-&gt;x_ = b.first, this-&gt;y_ = b.second; return *this; } Vector &amp;operator=(const Vector &amp;b) { this-&gt;x_ = b.x_, this-&gt;y_ = b.y_; return *this; } Vector operator+(const Vector &amp;b) const { return Vector(x_ + b.x_, y_ + b.y_); } Vector operator-(const Vector &amp;b) const { return Vector(x_ - b.x_, y_ - b.y_); } Vector operator*(const double &amp;b) const { return Vector(x_ * b, y_ * b); } Vector operator/(const double &amp;b) const { return Vector(x_ / b, y_ / b); } Vector &amp;operator+=(const Vector &amp;b) { x_ += b.x_, y_ += b.y_; return *this; } Vector &amp;operator-=(const Vector &amp;b) { x_ -= b.x_, y_ -= b.y_; return *this; } Vector &amp;operator*=(const double &amp;b) { x_ *= b, y_ *= b; return *this; } Vector &amp;operator/=(const double &amp;b) { x_ /= b, y_ /= b; return *this; } void Rotate(const double &amp;angle) { double x = x_, y = y_; x_ = x * std::cos(angle) - y * std::sin(angle); y_ = x * std::sin(angle) + y * std::cos(angle); } friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Vector &amp;a) { in &gt;&gt; a.x_ &gt;&gt; a.y_; return in; } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Vector &amp;a) { out &lt;&lt; std::setprecision(kPrecision) &lt;&lt; std::fixed &lt;&lt; a.x_ &lt;&lt; ',' &lt;&lt; a.y_; return out; } ~Vector() {} }; class Line { public: Point p_; Vector v_; Line() {} Line(Point p, Vector v) : p_(p), v_(v) {} friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Line &amp;a) { Point A, B; in &gt;&gt; A &gt;&gt; B; a = Line(A, Vector(A, B)); return in; } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Line &amp;a) { out &lt;&lt; a.p_ &lt;&lt; ' ' &lt;&lt; a.p_ + a.v_; return out; } ~Line() {} }; class Segment { public: Point a_, b_; Segment() {} Segment(Point a, Point b) : a_(a), b_(b) {} friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Segment &amp;a) { in &gt;&gt; a.a_ &gt;&gt; a.b_; return in; } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Segment &amp;a) { out &lt;&lt; std::setprecision(kPrecision) &lt;&lt; std::fixed &lt;&lt; a.a_ &lt;&lt; ' ' &lt;&lt; a.b_; return out; } ~Segment() {} }; class Circle { public: Point o_; double r_; Circle() {} Circle(Point o, double r) : o_(o), r_(r) {} Circle(Point A) { o_ = A, r_ = 0.0; } Circle(Point A, Point B); Circle(Point A, Point B, Point C); Circle(const std::pair&lt;Point, double&gt; &amp;b) : o_(b.first), r_(b.second) {} ~Circle() {} friend std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Circle &amp;a) { in &gt;&gt; a.o_ &gt;&gt; a.r_; return in; } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Circle &amp;a) { out &lt;&lt; a.o_ &lt;&lt; ',' &lt;&lt; a.r_; return out; } }; using Polygon = std::vector&lt;Point&gt;; Point Point::operator+(const Vector &amp;b) const { return Point(x_ + b.x_, y_ + b.y_); } Point Point::operator-(const Vector &amp;b) const { return Point(x_ - b.x_, y_ - b.y_); } double Dis(const Point &amp;a, const Point &amp;b) { return std::hypot(a.x_ - b.x_, a.y_ - b.y_); } double Dot(const Vector &amp;a, const Vector &amp;b) { return a.x_ * b.x_ + a.y_ * b.y_; } double Cross(const Vector &amp;a, const Vector &amp;b) { return a.x_ * b.y_ - b.x_ * a.y_; } bool IsCcw(const Vector &amp;a, const Vector &amp;b) { return Sign(Cross(a, b)) &gt; 0; } Vector Rotate(const Vector &amp;a, const double &amp;angle) { return Vector(a.x_ * std::cos(angle) - a.y_ * std::sin(angle), a.x_ * std::sin(angle) + a.y_ * std::cos(angle)); } double Dis(const Point &amp;a, const Line &amp;l) { Vector v(l.p_, a); return std::fabs(Cross(v, l.v_)) / l.v_.Magnitude(); } Point Projection(const Point &amp;A, const Line &amp;l) { Vector a(l.p_, A), v = l.v_ * Dot(a, l.v_) / Dot(l.v_, l.v_); return l.p_ + v; } Point Intersection(const Line &amp;a, const Line &amp;b) { Vector v(a.p_, b.p_); double k = Cross(a.v_, v) / Cross(b.v_, a.v_); return b.p_ + b.v_ * k; } bool IsIntersecting(const Segment &amp;a, const Segment &amp;b) { Vector v1(a.a_, a.b_), v2(b.a_, b.b_); return Sign(Cross(v1, Vector(a.a_, b.a_))) * Sign(Cross(v1, Vector(a.a_, b.b_))) &lt; 0 &amp;&amp; Sign(Cross(v2, Vector(b.a_, a.a_))) * Sign(Cross(v2, Vector(b.a_, a.b_))) &lt; 0; } Point Intersection(const Segment &amp;a, const Segment &amp;b) { return Intersection(Line(a.a_, Vector(a.a_, a.b_)), Line(b.a_, Vector(b.a_, b.b_))); } double Dis(const Point &amp;A, const Segment &amp;b) { Vector v1(b.a_, b.b_), v2(b.a_, A), v3(b.b_, A); if (Sign(Dot(v1, v2)) &lt; 0) return v2.Magnitude(); else if (Sign(Dot(v1, v3)) &lt; 0) return v3.Magnitude(); else return std::fabs(Cross(v1, v2)) / v1.Magnitude(); } Circle::Circle(Point A, Point B) { o_ = Point((A.x_ + B.x_) / 2, (A.y_ + B.y_) / 2), r_ = Dis(o_, A); } Circle::Circle(Point A, Point B, Point C) { double a, b, c, d, e, f; a = B.y_ - A.y_; b = C.y_ - A.y_; c = B.x_ - A.x_; d = C.x_ - A.x_; e = B.x_ * B.x_ + B.y_ * B.y_ - A.x_ * A.x_ - A.y_ * A.y_; f = C.x_ * C.x_ + C.y_ * C.y_ - A.x_ * A.x_ - A.y_ * A.y_; o_ = Point((a * f - b * e) / (2 * a * d - 2 * b * c), (d * e - c * f) / (2 * a * d - 2 * b * c)); r_ = Dis(o_, A); } bool InCircle(const Circle &amp;O, const Point &amp;A) { return Sign(Dis(O.o_, A) - O.r_) &lt;= 0; } Circle InscribedCircle(const Point &amp;A, const Point &amp;B, const Point &amp;C) { double a = Dis(B, C), b = Dis(A, C), c = Dis(A, B), p = (a + b + c) / 2; return Circle(Point((a * A.x_ + b * B.x_ + c * C.x_) / (a + b + c), (a * A.y_ + b * B.y_ + c * C.y_) / (a + b + c)), sqrt((p - a) * (p - b) * (p - c) / p)); } std::vector&lt;Point&gt; Intersection(const Line &amp;l, const Circle &amp;O) { std::vector&lt;Point&gt; ans; if (Sign(Dis(O.o_, l) - O.r_) &lt; 0) { Point p = Projection(O.o_, l); double d = Dis(O.o_, p), t = std::sqrt(O.r_ * O.r_ - d * d); Vector v(l.v_ * t / l.v_.Magnitude()); ans.emplace_back(p + v), ans.emplace_back(p - v); } else if (!Sign(Dis(O.o_, l) - O.r_)) { ans.emplace_back(Projection(O.o_, l)); } return ans; } std::vector&lt;Point&gt; Intersection(const Circle &amp;O1, const Circle &amp;O2) { std::vector&lt;Point&gt; ans; double d = Dis(O1.o_, O2.o_); Vector v(O1.o_, O2.o_); if (Sign(d - O1.r_ - O2.r_) &lt; 0) { double angle = std::acos((O1.r_ * O1.r_ + d * d - O2.r_ * O2.r_) / (2 * O1.r_ * d)); ans.emplace_back(O1.o_ + Rotate(v, angle) * O1.r_ / d); ans.emplace_back(O1.o_ + Rotate(v, -angle) * O1.r_ / d); } else if (!Sign(d - O1.r_ - O2.r_)) { ans.emplace_back(O1.o_ + v * O1.r_ / d); } return ans; } std::vector&lt;Line&gt; Tangents(const Point &amp;P, const Circle &amp;O) { std::vector&lt;Line&gt; ans; Vector a(P, O.o_); double d = a.Magnitude(); if (Sign(d - O.r_) &gt; 0) { double angle = std::asin(O.r_ / d); ans.emplace_back(P, Rotate(a, angle)); ans.emplace_back(P, Rotate(a, -angle)); } else if (Sign(d - O.r_) == 0) { ans.emplace_back(P, Rotate(a, M_PI_2)); } return ans; } Circle SmallestCircle(const std::vector&lt;Point&gt; &amp;b) { std::vector&lt;Point&gt; a(b); std::shuffle(a.begin(), a.end(), rng); Circle O(a[0]); for (size_t i = 1; i &lt; a.size(); i++) if (!InCircle(O, a[i])) { O = Circle(a[i]); for (size_t j = 0; j &lt; i; j++) if (!InCircle(O, a[j])) { O = Circle(a[i], a[j]); for (size_t k = 0; k &lt; j; k++) if (!InCircle(O, a[k])) O = Circle(a[i], a[j], a[k]); } } return O; } double Area(const Polygon &amp;a) { double ans = 0.0; for (size_t i = 1; i + 1 &lt; a.size(); i++) ans += Cross(Vector(a[0], a[i]), Vector(a[0], a[i + 1])); return ans / 2; } Polygon ConvexHull(const std::vector&lt;Point&gt; &amp;b) { std::vector&lt;Point&gt; a(b), s; std::swap(*a.begin(), *std::min_element(a.begin(), a.end(), [](const Point &amp;x, const Point &amp;y) { return x.y_ &lt; y.y_; })); s.emplace_back(a[0]); std::sort(a.begin() + 1, a.end(), [&amp;a](const Point &amp;x, const Point &amp;y) { return IsCcw(Vector(*a.begin(), x), Vector(*a.begin(), y)); }); s.emplace_back(a[1]); int top = 1; for (size_t i = 2; i &lt; a.size(); i++) { while (top &amp;&amp; !IsCcw(Vector(s[top - 1], s.back()), Vector(s[top - 1], a[i]))) s.pop_back(), top--; s.emplace_back(a[i]); top++; } return s; } ","link":"http://xyf007.ml/post/mu-ban-ji-suan-ji-he-dai-ma-tou/"},{"title":"【模板】原根","content":"原根 阶 若 gcd⁡(a,p)=1\\gcd(a,p)=1gcd(a,p)=1，使 al≡1(modp)a^l \\equiv 1 \\pmod pal≡1(modp) 成立的最小的 lll 称为 aaa 关于模 ppp 的阶，记作 ord⁡pa\\operatorname{ord}_paordp​a。 原根 若 gcd⁡(g,p)=1\\gcd(g,p)=1gcd(g,p)=1 且 ord⁡pg=φ(p)\\operatorname{ord}_pg=\\varphi(p)ordp​g=φ(p)，则 ggg 为 ppp 的一个原根。 ggg 为 ppp 的一个原根 ⟺ gcd⁡(g,p)=1\\iff \\gcd(g,p)=1⟺gcd(g,p)=1 且 g,g2,…,gφ(p)g,g^2,\\ldots,g^{\\varphi(p)}g,g2,…,gφ(p) 两两不同。 判断原根 一个数 nnn 有原根当且仅当 n=1,2,4,pa,2pan=1,2,4,p^a,2p^an=1,2,4,pa,2pa，其中 ppp 为奇素数，aaa 为正整数。 求最小原根 一个数 nnn 最小的原根在 O(n14)O(n^{\\frac{1}{4}})O(n41​) 级别，因此可以暴力枚举。 考虑我们如何检测一个数 xxx 是不是 nnn 的原根。如果 nnn 比较小，可以暴力检查是否重复。但是如果 nnn 在 10910^9109 级别的话，φ(n)\\varphi(n)φ(n) 也是这个级别的，需要优化。 如果 xxx 不是 nnn 的原根，说明存在 i,j(0&lt;i&lt;j≤φ(n))i,j(0&lt;i&lt;j \\leq \\varphi(n))i,j(0&lt;i&lt;j≤φ(n)) 满足 xi≡xj(modn)x^i \\equiv x^j \\pmod nxi≡xj(modn)，即 xj−i≡1(modn)x^{j-i} \\equiv 1 \\pmod nxj−i≡1(modn)。而 xφ(n)≡1(modn)x^{\\varphi(n)} \\equiv 1 \\pmod nxφ(n)≡1(modn)，故 (j−i)∣φ(n)(j-i) \\mid \\varphi(n)(j−i)∣φ(n)。所以可以只枚举 φ(n)\\varphi(n)φ(n) 的因子。 如果令 p1,p2,…,pkp_1,p_2,\\ldots,p_kp1​,p2​,…,pk​ 为 φ(n)\\varphi(n)φ(n) 的所有质因子，只需要检测 ∀i∈[1,k],xφ(n)pk\\forall i \\in [1,k],x^{\\frac{\\varphi(n)}{p_k}}∀i∈[1,k],xpk​φ(n)​ 在模 ppp 意义下是否均不为 111 即可。 求所有原根 设 ggg 为 nnn 的一个原根，则集合 S={gi∣1≤i≤φ(n),gcd⁡(i,φ(n))=1}S=\\{g^i \\mid 1 \\leq i \\leq \\varphi(n),\\gcd(i,\\varphi(n))=1\\}S={gi∣1≤i≤φ(n),gcd(i,φ(n))=1} 给出 nnn 的全部原根。因此，若 nnn 有原根，则 nnn 有 φ(φ(n))\\varphi(\\varphi(n))φ(φ(n)) 个关于模 nnn 两两互不同余的原根。 代码实现 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; int t, n, phi; int Ksm(int a, int b, int p) { int s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;long long&gt;(a) % p; } a = a * static_cast&lt;long long&gt;(a) % p; b &gt;&gt;= 1; } return s; } int CalcPhi(int x) { int ans = x; for (int i = 2; i * i &lt;= x; i++) { if (!(x % i)) { ans = ans / i * (i - 1); while (!(x % i)) { x /= i; } } } if (x &gt; 1) { ans = ans / x * (x - 1); } return ans; } bool Check(int p, int x) { if (std::__gcd(p, x) != 1) { return false; } int tmp = phi; for (int i = 2; i * i &lt;= tmp; i++) { if (!(tmp % i)) { if (Ksm(x, phi / i, p) == 1) { return false; } while (!(tmp % i)) { tmp /= i; } } } if (tmp &gt; 1) { if (Ksm(x, phi / tmp, p) == 1) { return false; } } return true; } int CalcPrimitiveRoot(int p) { phi = CalcPhi(p); for (int i = 1; i &lt; p; i++) { if (Check(p, i)) { return i; } } return -1; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; t; while (t--) { std::cin &gt;&gt; n; std::cout &lt;&lt; CalcPrimitiveRoot(n) &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-yuan-gen/"},{"title":"【模板】Pollard's rho 分解质因数","content":"Pollard's rho 分解质因数 Pollard's rho 算法用于快速分解大数，其核心是快速找到这个数的一个质因子，运用随机化的思想。 前置知识 朴素分解质因数（O(n)O(\\sqrt{n})O(n​) 算法） Miller-Rabin 素性判定 生日悖论 我们来考虑这样一种情况：在 [1,1000][1,1000][1,1000] 里面取一个给定的数，一次成功的概率是多少呢？显然是 11000\\dfrac{1}{1000}10001​。 考虑取两个的情况：在 [1,1000][1,1000][1,1000] 里面任意选取两个数 i,ji,ji,j，问 ∣i−j∣∣i−j∣∣i−j∣ 等于给定的值的概率是多大？答案会扩大到 1500\\dfrac{1}{500}5001​ 左右，也就是将近扩大一倍。因为 iii 在 [1,1000][1,1000][1,1000] 里面取出一个正整数的概率是 100%100\\%100%，而取出 jjj 满足 ∣i−j∣|i-j|∣i−j∣ 等于给定值有两种情况。 这给了我们一点启发：这种“组合随机采样”的方法可以大大提高准确率。 这就是生日悖论的模型。假如说一个班上有 kkk 个人，如果找到一个人的生日是 777 月 666 日，这个概率的确会相当低。但是如果单纯想找到两个生日相同的人，这个概率会高很多。一个有 232323 个人组成的班级中，两个人在同一天生日的概率至少有 50%50\\%50%。当 kkk 取到 606060 时这个概率 P(k)≈0.9999P(k) \\approx 0.9999P(k)≈0.9999。这个数学模型和我们日常的经验严重不符，也是“生日悖论”这个名字的由来。 正题 如果基于试除法，复杂度必然为 O(n)O(\\sqrt{n})O(n​) 级别的，为此必须使用其他的想法，Pollard-Rho 的核心思想就是猜一个数是 nnn 的因子。但是对于一个巨大的因子很少的数，比如 1000000014000000049=100000000721000000014000000049 = 1000000007^21000000014000000049=10000000072，成功的概率仅为 11000000014000000049\\dfrac{1}{1000000014000000049}10000000140000000491​，期望猜测的次数是 100000001400000004910000000140000000491000000014000000049。我们希望找到一个优化猜测的办法。 优化随机算法 显然我们不需要真的猜到质因子，如果我们猜到了一个数 xxx，它和 nnn 的最大公因数 ggg 大于 111，那么 ggg 就可以用来分解 nnn。同样考虑 100000001400000004910000000140000000491000000014000000049，我们猜到 100000000710000000071000000007 的所有倍数都可以，复杂度下降到 O(n)O(\\sqrt{n})O(n​)，但这样还不够。 根据之前的生日悖论，我们又可以想到，不一定要猜到这个数 xxx，可以猜两个数，他们的差为 xxx，成功率又会提升。 构造伪随机函数 我们不妨考虑构造一个伪随机数序列，然后取相邻的两项来求差。取 f(x)=(x2+c) mod nf(x)=(x^2+c) \\bmod nf(x)=(x2+c)modn 生成 {xi}\\{x_i\\}{xi​}，其中 ccc 为一个 [1,n)[1,n)[1,n) 内的随机数。 可以发现数列在最终会进入循环，这也是 f(x)f(x)f(x) 被称为伪随机函数的原因。 如果将这些数如下图一样排列起来，会发现这个图像酷似一个 ρ\\rhoρ，算法也因此得名 rho。 伪随机数序列中不同值的数量约为 n\\sqrt{n}n​ 个。设 mmm 为 nnn 的最小非平凡因子，显然有 m≤nm \\leq \\sqrt{n}m≤n​。记 yi=xi mod my_i=x_i \\bmod myi​=xi​modm，推导可得： yi+1=xi+1 mod m=((xi2+c) mod n) mod m=(xi2+c) mod m=((xi mod m)2+c) mod m=(yi2+c) mod m\\begin{aligned} y_{i+1}&amp;=x_{i+1} \\bmod m\\\\ &amp;=((x_i^2+c) \\bmod n) \\bmod m\\\\ &amp;=(x_i^2+c) \\bmod m\\\\ &amp;=((x_i \\bmod m)^2+c) \\bmod m\\\\ &amp;=(y_i^2+c) \\bmod m \\end{aligned} yi+1​​=xi+1​modm=((xi2​+c)modn)modm=(xi2​+c)modm=((xi​modm)2+c)modm=(yi2​+c)modm​ 于是就得到了一个新序列 {yi}\\{y_i\\}{yi​}（当然也可以写作 {xi mod m}\\{x_i \\bmod m\\}{xi​modm}），并且根据生日悖论可以得知序列中不同值的个数约为 O(m)≤O(n14)O(\\sqrt{m}) \\leq O(n^{\\frac{1}{4}})O(m​)≤O(n41​)。 假设存在两个位置 i,ji,ji,j 使得 xi≠xjx_i \\neq x_jxi​​=xj​ 且 yi=yjy_i=y_jyi​=yj​，就可以用 gcd⁡(n,∣xi−xj∣)\\gcd(n, |x_i-x_j|)gcd(n,∣xi​−xj​∣) 获得一个因子。 期望时间复杂度：O(n14)O(n^{\\frac{1}{4}})O(n41​)。 弗洛伊德判环 假设两个人在赛跑，A 的速度快，B 的速度慢，经过一定时间后，A 一定会和 B 相遇，且相遇时 A 跑过的总距离减去 B 跑过的总距离一定是圈长的 kkk 倍。 设 a=f(1),b=f(f(1))a=f(1),b=f(f(1))a=f(1),b=f(f(1))，每一次更新 a=f(a),b=f(f(b))a=f(a),b=f(f(b))a=f(a),b=f(f(b))，只要检查在更新过程中 aaa、bbb 是否相等，如果相等了，那么就出现了环。 我们每次令 d=gcd⁡(n,∣xi−xj∣)d=\\gcd(n,|x_i-x_j|)d=gcd(n,∣xi​−xj​∣)，判断 ddd 是否满足 1&lt;d&lt;n1&lt;d&lt;n1&lt;d&lt;n，若满足则可直接返回 ddd。由于 {xi}\\{x_i\\}{xi​} 是一个伪随机数列，必定会形成环，在形成环时就不能再继续操作了，直接返回 nnn 本身，并且在后续操作里调整随机常数 ccc，重新分解。 倍增优化 注意到每次求 gcd 的时候的复杂度都为 O(log⁡n)O(\\log n)O(logn)，不可忽略。我们可以多乘一些数，再一次性求 gcd。前人实践得出每隔 127127127 个数比较效率优异。 代码实现 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;random&gt; #include &lt;chrono&gt; std::mt19937 mt_rand(std::chrono::_V2::steady_clock::now().time_since_epoch().count()); std::uniform_int_distribution&lt;long long&gt; R(1LL, 1000000000000000000LL); constexpr int kPrime[] = {0, 2, 3, 5, 11, 17, 19, 23, 37, 41, 43}; int t; long long n, max; void checkmax(long long &amp;x, long long y) { if (x &lt; y) { x = y; } } long long Ksm(long long a, long long b, long long p) { long long s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;__int128_t&gt;(a) % p; } a = a * static_cast&lt;__int128_t&gt;(a) % p; b &gt;&gt;= 1; } return s; } bool MillerRabin(long long n, int a) { long long d = n - 1; int r = 0; while (!(d &amp; 1)) { r++; d &gt;&gt;= 1; } long long x = Ksm(a, d, n); if (x == 1) { return true; } for (int i = 0; i &lt; r; i++) { if (x == n - 1) { return true; } x = x * static_cast&lt;__int128_t&gt;(x) % n; } return false; } bool IsPrime(long long x) { if (x &lt; 2) { return false; } for (int i = 1; i &lt;= 10; i++) { if (x == kPrime[i]) { return true; } if (!MillerRabin(x, kPrime[i])) { return false; } } return true; } long long F(long long x, long long c, long long n) { return (x * static_cast&lt;__int128_t&gt;(x) + c) % n; } long long PollardRho(long long n) { long long c = R(mt_rand) % (n - 1) + 1, s = 0, t = 0, v = 1; for (int len = 1;; len &lt;&lt;= 1) { s = t; v = 1; for (int step = 1; step &lt;= len; step++) { t = F(t, c, n); v = v * static_cast&lt;__int128_t&gt;(llabs(s - t)) % n; if (!(step % 127)) { long long gcd = std::__gcd(v, n); if (gcd &gt; 1) { return gcd; } } } long long gcd = std::__gcd(v, n); if (gcd &gt; 1) { return gcd; } } return n; } void Factor(long long n) { if (n &lt;= max || n &lt; 2) { return; } if (IsPrime(n)) { checkmax(max, n); return; } long long d = n; while (d == n) { d = PollardRho(n); } while (!(n % d)) { n /= d; } Factor(d); Factor(n); } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; t; while (t--) { std::cin &gt;&gt; n; if (IsPrime(n)) { std::cout &lt;&lt; &quot;Prime\\n&quot;; continue; } max = 0; Factor(n); std::cout &lt;&lt; max &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-pollards-rho-fen-jie-zhi-yin-shu/"},{"title":"【模板】Miller–Rabin 素性测试","content":"如果 nnn 为素数，取 a&lt;na&lt;na&lt;n，设 n−1=d×2rn-1=d \\times 2^rn−1=d×2r，则要么 ad≡1(modn)a^d \\equiv 1 \\pmod nad≡1(modn)，要么 ∃0≤i&lt;r\\exist 0 \\leq i&lt;r∃0≤i&lt;r，满足 ad×2i≡−1(modn)a^{d \\times 2^i} \\equiv -1 \\pmod nad×2i≡−1(modn)。取一些数判断即可。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; constexpr int kPrime[] = {0, 2, 3, 5, 11, 17, 19, 23, 37, 41, 43}; int t; long long n; long long Ksm(long long a, long long b, long long p) { long long s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;__int128_t&gt;(a) % p; } a = a * static_cast&lt;__int128_t&gt;(a) % p; b &gt;&gt;= 1; } return s; } bool MillerRabin(long long n, int a) { long long d = n - 1; int r = 0; while (!(d &amp; 1)) { r++; d &gt;&gt;= 1; } long long x = Ksm(a, d, n); if (x == 1) { return true; } for (int i = 0; i &lt; r; i++) { if (x == n - 1) { return true; } x = x * static_cast&lt;__int128_t&gt;(x) % n; } return false; } bool IsPrime(long long x) { if (x &lt; 2) { return false; } for (int i = 1; i &lt;= 10; i++) { if (x == kPrime[i]) { return true; } if (!MillerRabin(x, kPrime[i])) { return false; } } return true; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; t; while (t--) { std::cin &gt;&gt; n; std::cout &lt;&lt; (IsPrime(n) ? 'Y' : 'N') &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-miller-rabin-su-xing-ce-shi/"},{"title":"【模板】分治 FFT","content":" 给出 g1,g2,…,gng_1,g_2,\\ldots,g_ng1​,g2​,…,gn​，求解 fi=∑j=1ifi−jgjf_i=\\sum_{j=1}^if_{i-j}g_jfi​=∑j=1i​fi−j​gj​。 看起来就是 FFT/NTT，但是后面的值依赖于前面的值，于是像 CDQ 分治一样，算前面的值对后面的贡献。 时间复杂度 O(nlog⁡2n)O(n \\log^2 n)O(nlog2n) #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; constexpr int kMod = 998244353, kG = 3; int n, a[400001], b[400001], rev[400001], lg[400001], g[400001], ig[400001], A[400001], B[400001]; int Ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;long long&gt;(a) % kMod; } a = a * static_cast&lt;long long&gt;(a) % kMod; b &gt;&gt;= 1; } return s; } void NTT(int *a, int n, int op) { for (int i = 0; i &lt; n; i++) { rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lg[n] - 1)); } for (int i = 0; i &lt; n; i++) { if (i &lt; rev[i]) { std::swap(a[i], a[rev[i]]); } } for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { int wn = op == 1 ? g[mid &lt;&lt; 1] : ig[mid &lt;&lt; 1], a1, a2; for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { int w = 1; for (int j = 0; j &lt; mid; j++) { a1 = a[i + j]; a2 = static_cast&lt;long long&gt;(w) * a[i + j + mid] % kMod; a[i + j] = (a1 + a2) % kMod; a[i + j + mid] = (a1 - a2 + kMod) % kMod; w = w * static_cast&lt;long long&gt;(wn) % kMod; } } } if (op == -1) { int inv = Ksm(n, kMod - 2); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(inv) % kMod; } } } void Solve(int l, int r) { if (l + 1 &gt;= r) { return; } int mid = (l + r) &gt;&gt; 1; Solve(l, mid); memcpy(A, a + l, 4 * (mid - l)); memset(A + mid - l, 0, 4 * (r - mid)); memcpy(B, b, 4 * (r - l)); NTT(A, r - l, 1); NTT(B, r - l, 1); for (int i = 0; i &lt; r - l; i++) { A[i] = A[i] * static_cast&lt;long long&gt;(B[i]) % kMod; } NTT(A, r - l, -1); for (int i = mid; i &lt; r; i++) { a[i] = (a[i] + A[i - l]) % kMod; } Solve(mid, r); } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); a[0] = 1; std::cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { std::cin &gt;&gt; b[i]; } int len = 1, cnt = 0; while (len &lt; n) { cnt++; len &lt;&lt;= 1; } g[len] = Ksm(kG, (kMod - 1) &gt;&gt; cnt); ig[len] = Ksm(g[len], kMod - 2); for (int i = cnt - 1; i &gt;= 0; i--) { g[1 &lt;&lt; i] = g[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(g[1 &lt;&lt; (i + 1)]) % kMod; ig[1 &lt;&lt; i] = ig[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(ig[1 &lt;&lt; (i + 1)]) % kMod; } for (int i = 1; i &lt;= cnt; i++) { lg[1 &lt;&lt; i] = i; } Solve(0, len); for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; a[i] &lt;&lt; ' '; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-fen-zhi-fft/"},{"title":"【模板】多项式求逆","content":"当只有一项的时候，显然 [x0]f−1(x)=([x0]f(x))−1\\left[x^0\\right]f^{-1}(x)=\\left(\\left[x^0\\right]f(x)\\right)^{-1}[x0]f−1(x)=([x0]f(x))−1。 现在假设已经求出了 f(x)f(x)f(x) 在模 xn2x^{\\frac{n}{2}}x2n​ 意义下的逆元 f0−1(x)f_0^{-1}(x)f0−1​(x)，那么有 f(x)f0−1(x)≡1(modxn2)f(x)f−1(x)≡1(modxn2)∴f−1(x)−f0−1(x)≡0(modxn2)\\begin{aligned} f(x)f_0^{-1}(x) &amp;\\equiv 1 &amp;\\pmod {x^{\\frac{n}{2}}}\\\\ f(x)f^{-1}(x) &amp;\\equiv 1 &amp;\\pmod {x^{\\frac{n}{2}}}\\\\ \\therefore f^{-1}(x)-f_0^{-1}(x) &amp;\\equiv 0 &amp;\\pmod {x^\\frac{n}{2}} \\end{aligned} f(x)f0−1​(x)f(x)f−1(x)∴f−1(x)−f0−1​(x)​≡1≡1≡0​(modx2n​)(modx2n​)(modx2n​)​ 两边平方，同乘 f(x)f(x)f(x) 并移项可得 f−2(x)−2f−1(x)f0−1(x)+f0−2(x)≡0(modxn)f−1(x)≡f0−1(x)(2−f(x)f0−1(x))(modxn)\\begin{aligned} f^{-2}(x)-2f^{-1}(x)f_0^{-1}(x)+f_0^{-2}(x) &amp;\\equiv 0 &amp;\\pmod {x^n}\\\\ f^{-1}(x) &amp;\\equiv f_0^{-1}(x)(2-f(x)f_0^{-1}(x)) &amp;\\pmod {x^n} \\end{aligned} f−2(x)−2f−1(x)f0−1​(x)+f0−2​(x)f−1(x)​≡0≡f0−1​(x)(2−f(x)f0−1​(x))​(modxn)(modxn)​ 递归计算即可。 时间复杂度：T(n)=T(n2)+O(nlog⁡n)=O(nlog⁡n)T(n)=T\\left(\\dfrac{n}{2}\\right)+O(n \\log n)=O(n \\log n)T(n)=T(2n​)+O(nlogn)=O(nlogn)。 注意事项：最后一次求逆会倍增到长度的两倍，因此预处理要多一次。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; constexpr int kMod = 998244353, kG = 3; int n, a[400001], b[400001], rev[400001], g[400001], ig[400001], lg[400001]; int Ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;long long&gt;(a) % kMod; } a = a * static_cast&lt;long long&gt;(a) % kMod; b &gt;&gt;= 1; } return s; } void NTT(int *a, int n, int op) { for (int i = 0; i &lt; n; i++) { rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lg[n] - 1)); } for (int i = 0; i &lt; n; i++) { if (i &lt; rev[i]) { std::swap(a[i], a[rev[i]]); } } for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { int wn = op == 1 ? g[mid &lt;&lt; 1] : ig[mid &lt;&lt; 1], a1, a2; for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { int w = 1; for (int j = 0; j &lt; mid; j++) { a1 = a[i + j]; a2 = static_cast&lt;long long&gt;(w) * a[i + j + mid] % kMod; a[i + j] = (a1 + a2) % kMod; a[i + j + mid] = (a1 - a2 + kMod) % kMod; w = w * static_cast&lt;long long&gt;(wn) % kMod; } } } if (op == -1) { int inv = Ksm(n, kMod - 2); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(inv) % kMod; } } } void Get_inv(const int *a, int n, int *b) { static int tmp[400001]; b[0] = Ksm(a[0], kMod - 2); for (int len = 2; len &lt;= n; len &lt;&lt;= 1) { memcpy(tmp, a, 4 * len); memset(tmp + len, 0, 4 * len); NTT(b, len &lt;&lt; 1, 1); NTT(tmp, len &lt;&lt; 1, 1); for (int i = 0; i &lt; (len &lt;&lt; 1); i++) { b[i] = static_cast&lt;long long&gt;(b[i]) * (2 - static_cast&lt;long long&gt;(b[i]) * tmp[i] % kMod + kMod) % kMod; } NTT(b, len &lt;&lt; 1, -1); memset(b + len, 0, 4 * len); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { std::cin &gt;&gt; a[i]; } int len = 1, cnt = 0; while (len &lt; n) { cnt++; len &lt;&lt;= 1; } cnt++; len &lt;&lt;= 1; g[len] = Ksm(kG, (kMod - 1) &gt;&gt; cnt); ig[len] = Ksm(g[len], kMod - 2); for (int i = cnt - 1; i &gt;= 0; i--) { g[1 &lt;&lt; i] = g[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(g[1 &lt;&lt; (i + 1)]) % kMod; ig[1 &lt;&lt; i] = ig[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(ig[1 &lt;&lt; (i + 1)]) % kMod; } for (int i = 1; i &lt;= cnt; i++) { lg[1 &lt;&lt; i] = i; } Get_inv(a, len &gt;&gt;= 1, b); for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; b[i] &lt;&lt; ' '; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-duo-xiang-shi-qiu-ni/"},{"title":"【模板】快速莫比乌斯/沃尔什变换（FMT/FWT）","content":"快速莫比乌斯/沃尔什变换 通常见到的多项式卷积是 Ck=∑i+j=kAiBjC_k=\\sum_{i+j=k}A_iB_jCk​=∑i+j=k​Ai​Bj​ 形式的，可以用 FFT/NTT 做。 如果将操作符换成集合运算符，比如如下形式 Ck=∑i∣j=kAiBjCk=∑i&amp;j=kAiBjCk=∑i⊕j=kAiBj\\begin{aligned} C_k&amp;=\\sum_{i|j=k}A_iB_j\\\\ C_k&amp;=\\sum_{i \\&amp; j=k}A_iB_j\\\\ C_k&amp;=\\sum_{i \\oplus j=k}A_iB_j \\end{aligned} Ck​Ck​Ck​​=i∣j=k∑​Ai​Bj​=i&amp;j=k∑​Ai​Bj​=i⊕j=k∑​Ai​Bj​​ FFT/NTT 就不能做了，需要用到 FMT/FWT。但是它们的想法是共通的：用另外的多项式来表示 AAA、BBB，然后再对应相乘，最后再变换回来。 根据准确的定义，快速莫比乌斯变换只能解决与和或的运算，快速沃尔什变换只能解决异或的运算。 快速莫比乌斯变换 或运算 我们构造 FMT[A]i=∑j∣i=iAjFMT[A]_i=\\sum_{j|i=i}A_jFMT[A]i​=∑j∣i=i​Aj​，即 iii 对应二进制表示的所有子集的和。（类似高维前缀和的思想） 则有 FMT[A]×FMT[B]=(∑j∣i=iAj)(∑k∣i=iBk)=∑j∣i=i∑k∣i=iAjBk=∑(j∣k)∣i=iAjBk=FMT[C]\\begin{aligned} FMT[A] \\times FMT[B]&amp;=\\left(\\sum_{j|i=i}A_j\\right)\\left(\\sum_{k|i=i}B_k\\right)\\\\ &amp;=\\sum_{j|i=i}\\sum_{k|i=i}A_jB_k\\\\ &amp;=\\sum_{(j|k)|i=i}A_jB_k\\\\ &amp;=FMT[C] \\end{aligned} FMT[A]×FMT[B]​=⎝⎛​j∣i=i∑​Aj​⎠⎞​⎝⎛​k∣i=i∑​Bk​⎠⎞​=j∣i=i∑​k∣i=i∑​Aj​Bk​=(j∣k)∣i=i∑​Aj​Bk​=FMT[C]​ 我们令 A0A_0A0​ 表示 AAA 的前一半，A1A_1A1​ 表示后一半，那么 A0A_0A0​ 就是 AAA 下标最高位为 000 的位，他的子集就是他本身的子集（因为最高位为 000 了），但是 A1A_1A1​ 的最高位是 111，他满足条件的子集不仅仅是他本身，还包最高位为 000 的子集，即 FMT[A]=merge⁡(FMT[A0],FMT[A0]+FMT[A1])FMT[A]=\\operatorname{merge}(FMT[A_0],FMT[A_0]+FMT[A_1]) FMT[A]=merge(FMT[A0​],FMT[A0​]+FMT[A1​]) 其中 merge⁡\\operatorname{merge}merge 表示直接拼接。 那么 IFMT 也就很好实现 A=merge⁡(A0,A1−A0)A=\\operatorname{merge}(A_0,A_1-A_0) A=merge(A0​,A1​−A0​) 与运算 和或运算类似，定义 FMT[A]=∑j&amp;i=iAjFMT[A]=\\sum_{j \\&amp; i=i}A_jFMT[A]=∑j&amp;i=i​Aj​，有 FMT[A]=merge⁡(FMT[A0]+FMT[A1],FMT[A1])FMT[A]=\\operatorname{merge}(FMT[A_0]+FMT[A_1],FMT[A_1]) FMT[A]=merge(FMT[A0​]+FMT[A1​],FMT[A1​]) A=merge⁡(A0−A1,A1)A=\\operatorname{merge}(A_0-A_1,A_1) A=merge(A0​−A1​,A1​) 快速沃尔什变换 定义 x⊗y=popcount⁡(x&amp;y) mod 2x \\otimes y=\\operatorname{popcount}(x \\&amp; y) \\bmod 2x⊗y=popcount(x&amp;y)mod2，其中 popcount⁡\\operatorname{popcount}popcount 表示二进制下 111 的个数。 满足 (i⊗j)⊕(i⊗k)=i⊗(j⊕k)(i \\otimes j) \\oplus (i \\otimes k)=i \\otimes (j \\oplus k)(i⊗j)⊕(i⊗k)=i⊗(j⊕k)。 构造 FWT[A]i=∑i⊗j=0Aj−∑i⊗j=1AjFWT[A]_i=\\sum_{i \\otimes j=0}A_j-\\sum_{i \\otimes j=1}A_jFWT[A]i​=∑i⊗j=0​Aj​−∑i⊗j=1​Aj​。 则有 FWT[A]×FWT[B]=(∑j⊗i=0Aj−∑j⊗i=1Aj)(∑k⊗i=0Bk−∑k⊗i=1Bk)=(∑j⊗i=0Aj)(∑k⊗i=0Bk)−(∑j⊗i=0Aj)(∑k⊗i=1Bk)−(∑j⊗i=1Aj)(∑k⊗i=0Bk)+(∑j⊗i=1Aj)(∑k⊗i=1Bk)=∑i⊗(j⊕k)=0AjBk−∑i⊗(j⊕k)=1AjBk=FWT[C]\\begin{aligned} FWT[A] \\times FWT[B]&amp;=\\left(\\sum_{j \\otimes i=0}A_j-\\sum_{j \\otimes i=1}A_j\\right)\\left(\\sum_{k \\otimes i=0}B_k-\\sum_{k \\otimes i=1}B_k\\right)\\\\ &amp;=\\left(\\sum_{j \\otimes i=0}A_j\\right)\\left(\\sum_{k \\otimes i=0}B_k\\right)-\\left(\\sum_{j \\otimes i=0}A_j\\right)\\left(\\sum_{k \\otimes i=1}B_k\\right)-\\left(\\sum_{j \\otimes i=1}A_j\\right)\\left(\\sum_{k \\otimes i=0}B_k\\right)+\\left(\\sum_{j \\otimes i=1}A_j\\right)\\left(\\sum_{k \\otimes i=1}B_k\\right)\\\\ &amp;=\\sum_{i \\otimes (j \\oplus k)=0}A_jB_k-\\sum_{i \\otimes (j \\oplus k)=1}A_jB_k\\\\ &amp;=FWT[C] \\end{aligned} FWT[A]×FWT[B]​=(j⊗i=0∑​Aj​−j⊗i=1∑​Aj​)(k⊗i=0∑​Bk​−k⊗i=1∑​Bk​)=(j⊗i=0∑​Aj​)(k⊗i=0∑​Bk​)−(j⊗i=0∑​Aj​)(k⊗i=1∑​Bk​)−(j⊗i=1∑​Aj​)(k⊗i=0∑​Bk​)+(j⊗i=1∑​Aj​)(k⊗i=1∑​Bk​)=i⊗(j⊕k)=0∑​Aj​Bk​−i⊗(j⊕k)=1∑​Aj​Bk​=FWT[C]​ 因此 FWT[A]=merge⁡(FWT[A0]+FWT[A1],FWT[A0]−FWT[A1])FWT[A]=\\operatorname{merge}(FWT[A_0]+FWT[A_1],FWT[A_0]-FWT[A_1]) FWT[A]=merge(FWT[A0​]+FWT[A1​],FWT[A0​]−FWT[A1​]) A=merge⁡(A0+A12,A0−A12)A=\\operatorname{merge}\\left(\\frac{A_0+A_1}{2},\\frac{A_0-A_1}{2}\\right) A=merge(2A0​+A1​​,2A0​−A1​​) 代码实现 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; constexpr int kMod = 998244353; int n, m, A[131072], B[131072], a[131072], b[131072]; void FMT_Or(int *a, int n, int op) { for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { for (int j = 0; j &lt; mid; j++) { a[i + j + mid] = ((a[i + j + mid] + a[i + j] * op) % kMod + kMod) % kMod; } } } } void FMT_And(int *a, int n, int op) { for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { for (int j = 0; j &lt; mid; j++) { a[i + j] = ((a[i + j] + a[i + j + mid] * op) % kMod + kMod) % kMod; } } } } void FWT_Xor(int *a, int n, int op) { for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { for (int j = 0; j &lt; mid; j++) { int tmp1 = (a[i + j] + a[i + j + mid]) % kMod, tmp2 = (a[i + j] - a[i + j + mid] + kMod) % kMod; a[i + j] = tmp1 * static_cast&lt;long long&gt;(op) % kMod; a[i + j + mid] = tmp2 * static_cast&lt;long long&gt;(op) % kMod; } } } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; m; n = 1 &lt;&lt; m; for (int i = 0; i &lt; n; i++) { std::cin &gt;&gt; A[i]; } for (int i = 0; i &lt; n; i++) { std::cin &gt;&gt; B[i]; } memcpy(a, A, 4 * n); memcpy(b, B, 4 * n); FMT_Or(a, n, 1); FMT_Or(b, n, 1); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(b[i]) % kMod; } FMT_Or(a, n, -1); for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; a[i] &lt;&lt; ' '; } std::cout &lt;&lt; '\\n'; memcpy(a, A, 4 * n); memcpy(b, B, 4 * n); FMT_And(a, n, 1); FMT_And(b, n, 1); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(b[i]) % kMod; } FMT_And(a, n, -1); for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; a[i] &lt;&lt; ' '; } std::cout &lt;&lt; '\\n'; memcpy(a, A, 4 * n); memcpy(b, B, 4 * n); FWT_Xor(a, n, 1); FWT_Xor(b, n, 1); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(b[i]) % kMod; } FWT_Xor(a, n, 499122177); for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; a[i] &lt;&lt; ' '; } std::cout &lt;&lt; '\\n'; return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuai-su-mo-bi-wu-si-wo-er-shi-bian-huan-fmtfwt/"},{"title":"【模板】上下界网络流","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; constexpr int kInf = 1000000000; struct Edge { int to, nxt, cost; } e[500001]; int n, m, E, head[2001], cur[2001], dep[2001], s, t, ss, tt; void init() { E = 0; memset(head, -1, sizeof(head)); } void Add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } bool Bfs() { std::queue&lt;int&gt; q; memcpy(cur + 1, head + 1, 4 * (n + m + 4)); memset(dep, -1, sizeof(dep)); dep[s] = 0; q.emplace(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (e[i].cost &amp;&amp; dep[v] == -1) { dep[v] = dep[u] + 1; q.emplace(v); } } } return dep[t] != -1; } int Dfs(int u, int sum) { if (u == t || !sum) { return sum; } int ans = 0; for (int i = cur[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (dep[v] == dep[u] + 1 &amp;&amp; e[i].cost) { int min = Dfs(v, std::min(sum, e[i].cost)); if (min) { e[i].cost -= min; e[i ^ 1].cost += min; ans += min; sum -= min; if (!sum) { break; } } } cur[u] = e[i].nxt; } if (!ans) { dep[u] = -1; } return ans; } int Dinic() { int ans = 0; while (Bfs()) { ans += Dfs(s, kInf); } return ans; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); while (std::cin &gt;&gt; n &gt;&gt; m) { init(); s = n + m + 1; t = n + m + 2; ss = n + m + 3; tt = n + m + 4; int x, c, d, l, r; for (int i = 1; i &lt;= m; i++) { std::cin &gt;&gt; x; Add(n + i, tt, x); Add(tt, n + i, 0); Add(n + i, t, kInf); Add(t, n + i, 0); Add(ss, t, x); Add(t, ss, 0); } for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; c &gt;&gt; d; Add(s, i, d); Add(i, s, 0); for (int j = 1; j &lt;= c; j++) { std::cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; x++; Add(i, tt, l); Add(tt, i, 0); Add(i, n + x, r - l); Add(n + x, i, 0); Add(ss, n + x, l); Add(n + x, ss, 0); } } Add(t, s, kInf); Add(s, t, 0); s = ss; t = tt; Dinic(); bool f = true; for (int i = head[ss]; i != -1; i = e[i].nxt) { if (e[i].cost) { f = false; std::cout &lt;&lt; &quot;-1\\n\\n&quot;; break; } } if (!f) { continue; } s = n + m + 1; t = n + m + 2; std::cout &lt;&lt; Dinic() &lt;&lt; &quot;\\n\\n&quot;; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-shang-xia-jie-wang-luo-liu/"},{"title":"【模板】长链剖分","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; struct Edge { int to, nxt; } e[1000001]; int n, q, E, head[500001], fa[500001][20], rt, dep[500001], d[500001], son[500001], lg[500001], top[500001]; unsigned int s; std::vector&lt;int&gt; up[500001], down[500001]; unsigned int get(unsigned int x) { x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; return s = x; } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u) { dep[u] = d[u] = d[fa[u][0]] + 1; for (int i = 1; (1 &lt;&lt; i) &lt;= d[u]; i++) { fa[u][i] = fa[fa[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; Dfs(v); if (dep[v] &gt; dep[son[u]]) { son[u] = v; dep[u] = dep[v]; } } } void Dfs2(int u, int t) { top[u] = t; if (u == t) { int x = u; for (int i = 0; i &lt;= dep[u] - d[u]; i++) { up[u].emplace_back(x); x = fa[x][0]; } x = u; for (int i = 0; i &lt;= dep[u] - d[u]; i++) { down[u].emplace_back(x); x = son[x]; } } if (son[u]) { Dfs2(son[u], t); } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == son[u]) { continue; } Dfs2(v, v); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; fa[i][0]; add(fa[i][0], i); if (!fa[i][0]) { rt = i; } } for (int i = 2; i &lt;= n; i++) { lg[i] = lg[i &gt;&gt; 1] + 1; } Dfs(rt); Dfs2(rt, rt); int x, k; long long ans = 0, lastans = 0; for (int i = 1; i &lt;= q; i++) { x = (get(s) ^ lastans) % n + 1; k = (get(s) ^ lastans) % d[x]; if (k) { x = fa[x][lg[k]]; k -= (1 &lt;&lt; lg[k]) + d[x] - d[top[x]]; x = top[x]; ans ^= i * static_cast&lt;long long&gt;(lastans = k &gt;= 0 ? up[x].at(k) : down[x].at(-k)); } else { ans ^= i * static_cast&lt;long long&gt;(lastans = x); } } std::cout &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-chang-lian-pou-fen/"},{"title":"【模板】虚树","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; struct Edge { int to, nxt, cost; } e[500001]; int n, q, k, a[250001], E, head[250001], s[250001], top, dep[250001], f[500001][20], first[500001], tot, lg[500001]; long long dp[250001], min[250001]; bool vis[250001]; void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int fa) { dep[u] = dep[fa] + 1; f[first[u] = ++tot][0] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } min[v] = std::min(min[u], static_cast&lt;long long&gt;(e[i].cost)); Dfs(v, u); f[++tot][0] = u; } } int GetLca(int u, int v) { int l = first[u], r = first[v]; if (l &gt; r) { std::swap(l, r); } int len = lg[r - l + 1]; return dep[f[l][len]] &lt; dep[f[r - (1 &lt;&lt; len) + 1][len]] ? f[l][len] : f[r - (1 &lt;&lt; len) + 1][len]; } void Solve(int u) { dp[u] = 0; long long sum = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; Solve(v); sum += dp[v]; } dp[u] = vis[u] ? min[u] : std::min(min[u], sum); head[u] = -1; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) { int u, v, c; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; add(u, v, c); add(v, u, c); } min[1] = 0x7fffffffffffffffLL; Dfs(1, 0); for (int i = 2; i &lt;= tot; i++) { lg[i] = lg[i &gt;&gt; 1] + 1; } for (int i = 1; i &lt;= lg[tot]; i++) { for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= tot; j++) { f[j][i] = dep[f[j][i - 1]] &lt; dep[f[j + (1 &lt;&lt; (i - 1))][i - 1]] ? f[j][i - 1] : f[j + (1 &lt;&lt; (i - 1))][i - 1]; } } memset(head, -1, sizeof(head)); std::cin &gt;&gt; q; while (q--) { std::cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { std::cin &gt;&gt; a[i]; vis[a[i]] = true; } std::sort(a + 1, a + k + 1, [](const int &amp;x, const int &amp;y) -&gt; bool { return first[x] &lt; first[y]; }); E = 0; s[top = 1] = 1; for (int i = 1; i &lt;= k; i++) { int lca = GetLca(s[top], a[i]); while (top &gt; 1 &amp;&amp; s[top] != lca) { int tmp = s[top--]; if (first[lca] &gt; first[s[top]]) { s[++top] = lca; } add(s[top], tmp, 0); } s[++top] = a[i]; } while (top &gt; 1) { add(s[top - 1], s[top], 0); top--; } Solve(1); std::cout &lt;&lt; dp[1] &lt;&lt; '\\n'; for (int i = 1; i &lt;= k; i++) { vis[a[i]] = false; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-xu-shu/"},{"title":"【模板】边分治","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; struct Edge { int to, nxt, w; } e[400001]; int n, N, E, head[200001], a[200001], sz[200001], root, maxp, SZ, tot[2]; std::vector&lt;int&gt; g[200001]; std::pair&lt;int, int&gt; b[2][200001]; bool vis[200001]; long long ans; template &lt;typename T&gt; void checkmax(T &amp;x, T y) { if (x &lt; y) { x = y; } } void add(int f, int t, int w) { e[E].to = t; e[E].w = w; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } g[u].emplace_back(v); Dfs(v, u); } } void Rebuild() { memset(head, -1, sizeof(head)); E = 0; for (int i = 1; i &lt;= n; i++) { size_t sz = g[i].size(); if (sz &lt;= 2) { for (size_t j = 0; j &lt; sz; j++) { int v = g[i].at(j); add(i, v, v &lt;= N); add(v, i, v &lt;= N); } } else { int t1 = ++n, t2 = ++n; a[t1] = a[t2] = a[i]; add(i, t1, 0); add(t1, i, 0); add(i, t2, 0); add(t2, i, 0); for (size_t j = 0; j &lt; sz; j++) { int v = g[i].at(j); if (j &amp; 1) { g[t1].emplace_back(v); } else { g[t2].emplace_back(v); } } } } } void get_root(int u, int fa) { sz[u] = 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[i &gt;&gt; 1]) { continue; } get_root(v, u); sz[u] += sz[v]; int t = std::max(sz[v], SZ - sz[v]); if (t &lt; maxp) { maxp = t; root = i; } } } void get_dis(int u, int fa, int len, int min, int id) { b[id][++tot[id]] = {min, len}; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[i &gt;&gt; 1]) { continue; } get_dis(v, u, len + e[i].w, std::min(min, a[v]), id); } } void Calc(int u) { tot[0] = tot[1] = 0; get_dis(e[u].to, e[u ^ 1].to, 0, a[e[u].to], 0); get_dis(e[u ^ 1].to, e[u].to, 0, a[e[u ^ 1].to], 1); std::sort(b[0] + 1, b[0] + tot[0] + 1, std::greater&lt;std::pair&lt;int, int&gt;&gt;()); std::sort(b[1] + 1, b[1] + tot[1] + 1, std::greater&lt;std::pair&lt;int, int&gt;&gt;()); int p0 = 1, p1 = 0, maxl = 0; while (p0 &lt;= tot[0]) { while (p1 &lt; tot[1] &amp;&amp; b[1][p1 + 1].first &gt;= b[0][p0].first) { checkmax(maxl, b[1][++p1].second); } if (p1) { checkmax(ans, b[0][p0].first * static_cast&lt;long long&gt;(b[0][p0].second + maxl + e[u].w + 1)); } p0++; } p0 = maxl = 0; p1 = 1; while (p1 &lt;= tot[1]) { while (p0 &lt; tot[0] &amp;&amp; b[0][p0 + 1].first &gt;= b[1][p1].first) { checkmax(maxl, b[0][++p0].second); } if (p0) { checkmax(ans, b[1][p1].first * static_cast&lt;long long&gt;(b[1][p1].second + maxl + e[u].w + 1)); } p1++; } } void Solve(int u) { Calc(u); vis[u &gt;&gt; 1] = true; int sz1 = sz[e[u].to], sz2 = SZ - sz[e[u].to]; SZ = sz1; maxp = 1e9; get_root(e[u].to, e[u ^ 1].to); if (maxp &lt; 1e9) { Solve(root); } SZ = sz2; maxp = 1e9; get_root(e[u ^ 1].to, e[u].to); if (maxp &lt; 1e9) { Solve(root); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n; N = n; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; } for (int i = 1; i &lt; n; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; add(u, v, 1); add(v, u, 1); } Dfs(1, 0); Rebuild(); SZ = n; maxp = 1e9; get_root(1, 0); Solve(root); std::cout &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-bian-fen-zhi/"},{"title":"【模板】点分树","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; struct Edge { int to, nxt; } e[200001]; int n, m, a[100001], E, head[100001], sz[100001], SZ, tsz, root, maxp[100001], fa[100001], dep[100001], f[200001][19], tot, first[100001], lg[200001]; std::vector&lt;int&gt; t[2][100001]; bool vis[100001]; void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int fa) { dep[u] = dep[fa] + 1; f[first[u] = ++tot][0] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } Dfs(v, u); f[++tot][0] = u; } } int GetLca(int u, int v) { int l = first[u], r = first[v]; if (l &gt; r) { std::swap(l, r); } int len = lg[r - l + 1]; return dep[f[l][len]] &lt; dep[f[r - (1 &lt;&lt; len) + 1][len]] ? f[l][len] : f[r - (1 &lt;&lt; len) + 1][len]; } void get_root(int u, int fa) { tsz++; sz[u] = 1; maxp[u] = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) { continue; } get_root(v, u); checkmax(maxp[u], sz[v]); sz[u] += sz[v]; } checkmax(maxp[u], SZ - sz[u]); if (!root || maxp[u] &lt; maxp[root]) { root = u; } } void Solve(int u) { vis[u] = true; sz[u] = tsz + 1; t[0][u].resize(sz[u] + 1); t[1][u].resize(sz[u] + 1); for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v]) { continue; } root = tsz = 0; SZ = sz[v]; get_root(v, u); fa[root] = u; Solve(root); } } void add(int u, int id, int x, int val) { x++; while (x &lt;= sz[u]) { t[id][u].at(x) += val; x += x &amp; -x; } } int query(int u, int id, int x) { x++; checkmin(x, sz[u]); int s = 0; while (x) { s += t[id][u].at(x); x -= x &amp; -x; } return s; } void modify(int u, int x) { int now = u; while (now) { add(now, 0, dep[u] + dep[now] - 2 * dep[GetLca(u, now)], x); now = fa[now]; } now = u; while (fa[now]) { add(now, 1, dep[u] + dep[fa[now]] - 2 * dep[GetLca(u, fa[now])], x); now = fa[now]; } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i]; } for (int i = 1; i &lt; n; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } Dfs(1, 0); for (int i = 2; i &lt;= tot; i++) { lg[i] = lg[i &gt;&gt; 1] + 1; } for (int i = 1; i &lt;= lg[tot]; i++) { for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= tot; j++) { f[j][i] = dep[f[j][i - 1]] &lt; dep[f[j + (1 &lt;&lt; (i - 1))][i - 1]] ? f[j][i - 1] : f[j + (1 &lt;&lt; (i - 1))][i - 1]; } } SZ = n; get_root(1, 0); Solve(root); for (int i = 1; i &lt;= n; i++) { modify(i, a[i]); } int lastans = 0; for (int i = 1; i &lt;= m; i++) { int op, x, y; std::cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; x ^= lastans; y ^= lastans; if (!op) { lastans = query(x, 0, y); int now = x; while (fa[now]) { int d = dep[x] + dep[fa[now]] - 2 * dep[GetLca(x, fa[now])]; if (d &lt;= y) { lastans += query(fa[now], 0, y - d) - query(now, 1, y - d); } now = fa[now]; } std::cout &lt;&lt; lastans &lt;&lt; '\\n'; } else { modify(x, y - a[x]); a[x] = y; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dian-fen-shu/"},{"title":"【模板】笛卡尔树","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; int n, a[10000001], s[10000001], top, l[10000001], r[10000001]; char gc() { static char now[1 &lt;&lt; 20], *S, *T; if (T == S) { T = (S = now) + fread(now, 1, 1 &lt;&lt; 20, stdin); if (T == S) { return EOF; } } return *S++; } int read() { int s = 0; char c = gc(); while (c &lt; '0' || c &gt; '9') { c = gc(); } s = (c ^ 48); while ((c = gc()) &gt;= '0' &amp;&amp; c &lt;= '9') { s = s * 10 + (c ^ 48); } return s; } int main(int argc, char const *argv[]) { n = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); while (top &amp;&amp; a[s[top]] &gt; a[i]) { l[i] = s[top--]; } r[s[top]] = i; s[++top] = i; } long long ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; i++) { ans1 ^= i * static_cast&lt;long long&gt;(l[i] + 1); ans2 ^= i * static_cast&lt;long long&gt;(r[i] + 1); } printf(&quot;%lld %lld&quot;, ans1, ans2); return 0; } ","link":"http://xyf007.ml/post/mu-ban-di-ka-er-shu/"},{"title":"【模板】CDQ 分治","content":"对第一维排序，第二位归并，第三维树状数组维护。 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; struct node { int x, y, z, id; } a[100001], b[100001], tmp[100001]; int n, k, t[200001], tot, ans[100001], cnt[100001], sum[100001]; void add(int x, int val) { while (x &lt;= k) { t[x] += val; x += x &amp; -x; } } int query(int x) { int s = 0; while (x) { s += t[x]; x -= x &amp; -x; } return s; } void Cdq(int l, int r) { if (l == r) { return; } int mid = (l + r) &gt;&gt; 1, i = l, j = mid + 1, p = l; Cdq(l, mid); Cdq(mid + 1, r); while (i &lt;= mid &amp;&amp; j &lt;= r) { if (b[i].y &lt;= b[j].y) { add(b[i].z, sum[b[i].id]); tmp[p++] = b[i++]; } else { ans[b[j].id] += query(b[j].z); tmp[p++] = b[j++]; } } while (i &lt;= mid) { add(b[i].z, sum[b[i].id]); tmp[p++] = b[i++]; } while (j &lt;= r) { ans[b[j].id] += query(b[j].z); tmp[p++] = b[j++]; } for (int i = l; i &lt;= mid; i++) { add(b[i].z, -sum[b[i].id]); } memcpy(b + l, tmp + l, (r - l + 1) * 16); } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z; } std::sort(a + 1, a + n + 1, [](const node &amp;x, const node &amp;y) -&gt; bool { return x.x == y.x ? x.y == y.y ? x.z &lt; y.z : x.y &lt; y.y : x.x &lt; y.x; }); for (int i = 1; i &lt;= n; i++) { if (a[i].x != a[i - 1].x || a[i].y != a[i - 1].y || a[i].z != a[i - 1].z) { b[++tot] = a[i]; b[tot].id = tot; sum[tot] = 1; } else { sum[tot]++; } } Cdq(1, tot); for (int i = 1; i &lt;= tot; i++) { cnt[ans[b[i].id] + sum[b[i].id] - 1] += sum[b[i].id]; } for (int i = 0; i &lt; n; i++) { std::cout &lt;&lt; cnt[i] &lt;&lt; '\\n'; } return 0; } ","link":"http://xyf007.ml/post/mu-ban-cdq-fen-zhi/"},{"title":"CSP2020 总结","content":"CSP2020 总结 这次 CSP–S 的比赛，整体上来说是没有考好的。根据现在的结果来看，应该拿到 320320320 以上的分数，才算是正常发挥，如果能够全部打满，可以达到 345345345 左右。 比赛情况 这次比赛的时间安排，我自己认为是合理的：T1 一小时五分钟，T2 半小时，T3 一个半小时，T4 半小时。 刚出考场时我估计自己是 100+100+(50∼80)+70=320∼350100+100+(50 \\sim 80)+70=320 \\sim 350100+100+(50∼80)+70=320∼350。 实际得分：70+95+50+70=28570+95+50+70=28570+95+50+70=285。 T1 和 T2 没有拿到满分非常不好，T3 指数级暴力都比我高，只有 T4 快速玩出 O(nlog⁡n)O(n \\log n)O(nlogn) 的 707070 分是比较好的发挥。 出现的问题 这次比赛很明显的问题就是 T1 的挂分和 T2 的特判又一次错误。 在场上我大约一小时就通过了 T1 的大样例，因此认为自己的代码肯定没有问题。实际上由于使用 while 循环减去 365365365 天进入下一年，导致某些闰年的最后一天跳到了下一年的第一天。场上我认为公元前和公元后的闰年情况是对称的，于是写的时候也是对称的，没有考虑到前面的情况是没有限制总共减 333 次的。这里的问题是偷懒，没有想清楚就直接写。 T2 又错了 555 分，这是去年已经犯过的问题，但是我只记住了不能写 1ULL &lt;&lt; 64，没有记住答案恰好为 2642^{64}264 时也会造成错误。这里表明了我对之前的错误没有了解清楚原因。 T3 则没有考虑到乘 000 的情况，因此直接顺着做，导致很多情况直接全部输出了 000，少了 252525 分。实际上我看到了数据范围中包括了 000，但是完全没考虑。没有想清楚边界情况，导致失分。 接下来的目标 在 NOIP2020 之前还有不到一个月的时间，这段时间里，想要大幅提升水平是不太可能的，因此主要的目标应该放在减少失误，避免无谓的失分上。要做到 hehezhou\\texttt{h\\color{Red}{ehezhou}}hehezhou 一样，对自己的情况极为了解，能将自己想到的全部实现，并且不出现错误。希望能够达到 320320320 分的成绩。 其他 虽然说这次 CSP 的成绩不尽如人意，但是毕竟这只是 CSP，借这次机会在更重要的 NOIP 前给自己一个清醒的认识，也是很有必要的。 尽管 €€£ 的数据相当地烂，但是这并不是我抱怨的理由，我为什么没有做到最好呢？即使别人的暴力能拿到比我更高的分数，那又怎么样呢？如果按照我自己的做法，仔细考虑完整并正确实现，也能达到同样的分数。 ","link":"http://xyf007.ml/post/csp2020-zong-jie/"},{"title":"错误合集","content":"错误合集 总结各种反复出现的错误。 忘记初始化（运行初始化函数、head 赋初值等）。 多测没清空。 没删调试语句。 多测的时候，读入一半就直接完成特判 continue，忘记读入该测试数据全部内容，导致输入错位。 for (int i = n; i &gt;= 1; i++)。 for (int j = 1; j &lt;= n; i++)。 有多个名字相近的函数的时候调用错误，如 Dfs()、Dfs2()。 各种边界情况忘记判断。 特判的时候写错。 1ULL &lt;&lt; 64 是会挂的。 特判的答案也可能超过 264−12^{64}-1264−1。 变量名/函数名打错。 Dijkstra 时堆中只存了编号。 快读没赋初值为 000。 滚动数组刷表法没清空上一轮。 多项式没清空数组。 长度不同的 FFT/NTT 没有重新计算 rev。 重载 cmp 的时候没加 const。 数组开小，有些维度可能是在值域上。 线段树/平衡树忘记 pushdown。 不满足二分性质的不要乱二分。 long long 范围内两个数相除要用 long double。 for (int j = 1; j &lt;= n; j++) 写成 for (int j = 0; j &lt; n; j++)。 数学题不要脑抽写模拟。 注意宏定义的优先级。 李超树 pushup 的时候不是赋值成儿子的信息。 即使理论复杂度正确也不要用 std::vector&lt;char&gt; 来判断两个字符串是否相等。 线段树没开 4 倍空间。 爆 long long 没有及时取 min。 用哈希判断字符串集合的时候没有把分隔符放进去。 树上背包合并没有清空数组。 ","link":"http://xyf007.ml/post/cuo-wu-he-ji/"},{"title":"【数学】基本不等式","content":"基本不等式总结 基本定义 21a+1b≤ab≤a+b2≤a2+b22\\frac{2}{\\frac{1}{a}+\\frac{1}{b}} \\leq \\sqrt{ab} \\leq \\frac{a+b}{2} \\leq \\sqrt{\\frac{a^2+b^2}{2}} a1​+b1​2​≤ab​≤2a+b​≤2a2+b2​​ 当且仅当 a,b&gt;0,a=ba,b&gt;0,a=ba,b&gt;0,a=b 时等号成立。 常用方法 猜（极不推荐） 根据对称等特殊性质猜测。 函数（不推荐） 将所求的式子变成有关一个变量的函数，暴力计算。注意取值范围。 整体代换 例1、已知 ab=a+b+5(a&gt;0,b&gt;0)ab=a+b+5(a&gt;0,b&gt;0)ab=a+b+5(a&gt;0,b&gt;0)，求 ababab 的取值范围。 法一 变成有关 aaa 的函数，可得 ab=a⋅a+5a−1ab=a \\cdot \\dfrac{a+5}{a-1}ab=a⋅a−1a+5​，换元处理，略。 法二 原式可得 ab−5=a+b≥2abab-5=a+b \\geq 2\\sqrt{ab}ab−5=a+b≥2ab​，令 t=ab&gt;0t=\\sqrt{ab}&gt;0t=ab​&gt;0 ∴t2−2t−5≥0\\therefore t^2-2t-5 \\geq 0∴t2−2t−5≥0，解得 t≤1−6t \\leq 1-\\sqrt{6}t≤1−6​ 或 t≥1+6t \\geq 1+\\sqrt{6}t≥1+6​ ∵t&gt;0\\because t&gt;0∵t&gt;0 ∴t≥1+6,ab≥7+26\\therefore t \\geq 1+\\sqrt{6},ab \\geq 7+2\\sqrt{6}∴t≥1+6​,ab≥7+26​ 例2、已知 x&gt;0,y&gt;0x&gt;0,y&gt;0x&gt;0,y&gt;0，且 2x+4y+xy=12x+4y+xy=12x+4y+xy=1，则 x+2yx+2yx+2y 的最小值是__________。 ","link":"http://xyf007.ml/post/shu-xue-ji-ben-bu-deng-shi/"},{"title":"【学习笔记】斯特林数","content":"斯特林数学习笔记 基本定义 第一类斯特林数 第一类斯特林数 [nm]\\begin{bmatrix}n\\\\ m\\end{bmatrix}[nm​] 表示将 nnn 个两两不同的元素，划分为 mmm 个非空圆排列的方案数。 递推式： [nm]=[n−1m−1]+(n−1)[n−1m]\\begin{bmatrix}n\\\\ m\\end{bmatrix} = \\begin{bmatrix}n-1\\\\ m-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\ m\\end{bmatrix} [nm​]=[n−1m−1​]+(n−1)[n−1m​] 递推边界为 [n0]=[n=0]\\begin{bmatrix}n\\\\ 0\\end{bmatrix}=[n=0][n0​]=[n=0]。 第一类斯特林数用处较少，大部分内容会与第二类斯特林数有关。 第二类斯特林数 第二类斯特林数 {nm}\\begin{Bmatrix}n\\\\ m\\end{Bmatrix}{nm​} 表示将 nnn 个两两不同的元素，划分为 mmm 个非空子集的方案数。 递推式： {nm}={n−1m−1}+m{n−1m}\\begin{Bmatrix}n\\\\ m\\end{Bmatrix} = \\begin{Bmatrix}n-1\\\\ m-1\\end{Bmatrix}+m\\begin{Bmatrix}n-1\\\\ m\\end{Bmatrix} {nm​}={n−1m−1​}+m{n−1m​} 递推边界为 {n0}=[n=0]\\begin{Bmatrix}n\\\\ 0\\end{Bmatrix}=[n=0]{n0​}=[n=0]。 斯特林数的应用 斯特林数与组合数 无标号集合比较难处理，我们考虑将其转换成有标号的集合并除以 m!m!m!。 运用容斥，枚举至少有 kkk 个集合是空集的方案数。 可以得到 {nm}=1m!∑k=0m(−1)k(mk)(m−k)n\\begin{Bmatrix}n\\\\ m\\end{Bmatrix}=\\frac{1}{m!}\\sum_{k=0}^m(-1)^k\\binom{m}{k}(m-k)^n {nm​}=m!1​k=0∑m​(−1)k(km​)(m−k)n 如果枚举至少有 kkk 个集合是非空的，那么可得 {nm}=1m!∑k=0m(−1)m−k(mk)kn=∑k=0mknk!⋅(−1)m−k(m−k)!\\begin{aligned} \\begin{Bmatrix}n\\\\ m\\end{Bmatrix}&amp;=\\frac{1}{m!}\\sum_{k=0}^m(-1)^{m-k}\\binom{m}{k}k^n\\\\ &amp;=\\sum_{k=0}^m\\frac{k^n}{k!}\\cdot\\frac{(-1)^{m-k}}{(m-k)!} \\end{aligned} {nm​}​=m!1​k=0∑m​(−1)m−k(km​)kn=k=0∑m​k!kn​⋅(m−k)!(−1)m−k​​ 这样就可以卷积计算了。 斯特林数与各种幂 下降幂 nm=∑i=0m{mi}ni‾n^m=\\sum_{i=0}^m\\begin{Bmatrix}m\\\\ i\\end{Bmatrix}n^{\\underline{i}} nm=i=0∑m​{mi​}ni​ 证明： nmn^mnm 的组合意义就是 mmm 个球放入 nnn 个盒子里的方案数。那么枚举这 mmm 个球共放入 iii 个盒子，且盒子不能为空的情况总和就是答案。 注意斯特林数是无标号的集合，我们要乘 i!i!i! 将其转换成有标号的。 所以 nm=∑i=0m(ni){mi}i!=∑i=0m{mi}ni‾\\begin{aligned} n^m&amp;=\\sum_{i=0}^m\\binom{n}{i}\\begin{Bmatrix}m\\\\ i\\end{Bmatrix}i!\\\\ &amp;=\\sum_{i=0}^m\\begin{Bmatrix}m\\\\ i\\end{Bmatrix}n^{\\underline{i}} \\end{aligned} nm​=i=0∑m​(in​){mi​}i!=i=0∑m​{mi​}ni​​ 上升幂 ","link":"http://xyf007.ml/post/xue-xi-bi-ji-si-te-lin-shu/"},{"title":"【模板】割点","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; struct edge { int to, nxt; } e[200001]; int n, m, E, head[20001], dfn[20001], low[20001], tot; bool cut[20001]; vector&lt;int&gt; ans; void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void tarjan(int u, int fa) { int sz = 0; dfn[u] = low[u] = ++tot; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (!dfn[v]) { tarjan(v, fa); checkmin(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; u != fa) { cut[u] = 1; } sz++; } else { checkmin(low[u], dfn[v]); } } if (u == fa &amp;&amp; sz &gt; 1) { cut[u] = 1; } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); add(v, u); } for (int i = 1; i &lt;= n; i++) { if (!dfn[i]) { tarjan(i, i); } } for (int i = 1; i &lt;= n; i++) { if (cut[i]) { ans.push_back(i); } } printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto &amp;&amp;i : ans) { printf(&quot;%d &quot;, i); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-ge-dian/"},{"title":"【模板】二次剩余","content":"二次剩余 一个数 aaa，如果不是 ppp 的倍数且模 ppp 同余于某个数的平方，则称 aaa 为模 ppp 的二次剩余。 我们往往要对 aaa 求解以下方程（即模意义下的开方）： x2≡a(modp)x^2\\equiv a \\pmod p x2≡a(modp) 这里只讨论ppp为奇质数的情况，用 Cipolla 算法求解。 二次剩余的数量 满足“nnn 是模 ppp 的二次剩余”的 nnn 一共有 p−12\\frac{p-1}{2}2p−1​ 个（0不包括在内），非二次剩余有 p−12\\frac{p-1}{2}2p−1​ 个。 证明 x=0x=0x=0 对应了 n=0n=0n=0 的特殊情况，因此我们只用考虑 x∈[1,p−12]x \\in [1,\\frac{p-1}{2}]x∈[1,2p−1​] 的情况。 一个显然的性质是 (p−x)2≡x2(modp)(p-x)^2 \\equiv x^2 \\pmod p(p−x)2≡x2(modp)，那么当 x∈[1,p−12]x \\in [1,\\frac{p-1}{2}]x∈[1,2p−1​] 我们可以取到所有解。 接下来我们只需要证明当 x∈[1,p−12]x\\in[1,\\frac{p-1}{2}]x∈[1,2p−1​] 时 x2 mod px^2 \\bmod px2modp 两两不同。 运用反证法，假设存在不同的两个整数 x,y∈[1,p−12]x,y \\in [1,\\frac{p-1}{2}]x,y∈[1,2p−1​] 且 x2≡y2(modp)x^2 \\equiv y^2 \\pmod px2≡y2(modp)， 则有 (x+y)(x−y)≡0(modp)(x+y)(x-y) \\equiv 0 \\pmod p(x+y)(x−y)≡0(modp)， 显然 −p&lt;x+y&lt;p,−p&lt;x−y&lt;p,x+y≠0,x−y≠0-p&lt;x+y&lt;p,-p&lt;x-y&lt;p,x+y \\neq 0,x-y \\neq 0−p&lt;x+y&lt;p,−p&lt;x−y&lt;p,x+y​=0,x−y​=0，故假设不成立，原命题成立。 勒让德符号 (np)={1,n≡0(modp)且n是p的二次剩余−1,n是p的非二次剩余0,n≡0(modp)\\left(\\dfrac{n}{p}\\right)= \\begin{cases} 1,&amp;n \\not \\equiv 0 \\pmod p\\text{且}n\\text{是}p\\text{的二次剩余}\\\\ -1,&amp;n\\text{是}p\\text{的非二次剩余}\\\\ 0,&amp;n \\equiv 0 \\pmod p \\end{cases} (pn​)=⎩⎪⎨⎪⎧​1,−1,0,​n​≡0(modp)且n是p的二次剩余n是p的非二次剩余n≡0(modp)​ 通过勒让德符号可以判断一个数 nnn 是否为二次剩余，具体判断 nnn 是否为 ppp 的二次剩余，需要通过欧拉判别准则来实现。 下表为部分勒让德符号的值 欧拉判别准则 (np)≡np−12(modp)\\left(\\dfrac{n}{p}\\right) \\equiv {n^{\\frac{p-1}{2}}} \\pmod p (pn​)≡n2p−1​(modp) 若 nnn 是二次剩余，当且仅当 np−12≡1(modp)n^{\\frac{p-1}{2}} \\equiv 1 \\pmod pn2p−1​≡1(modp)。 若 nnn 是非二次剩余，当且仅当 np−12≡−1(modp)n^{\\frac{p-1}{2}} \\equiv -1 \\pmod pn2p−1​≡−1(modp)。 证明 根据费马小定理 np−1≡1(modp)n^{p-1} \\equiv 1 \\pmod pnp−1≡1(modp)，所以 (np−12+1)(np−12−1)≡0(modp)(n^{\\frac{p-1}{2}}+1)(n^{\\frac{p-1}{2}}-1) \\equiv 0 \\pmod p(n2p−1​+1)(n2p−1​−1)≡0(modp)。 即 np−12+1n^{\\frac{p-1}{2}}+1n2p−1​+1 与 np−12−1n^{\\frac{p-1}{2}}-1n2p−1​−1 中必有一个是 ppp 的倍数，所以 np−12n^{\\frac{p-1}{2}}n2p−1​ 模 ppp 的余数为 111 或 −1-1−1。 因为 ppp 为奇质数，所以关于 ppp 的原根存在，不妨设为 aaa，则 nnn 可以表示为 aja^jaj，其中 1≤j≤p−11 \\leq j \\leq p-11≤j≤p−1。于是就有 aj⋅p−12≡1(modp)a^{j \\cdot \\frac{p-1}{2}} \\equiv 1 \\pmod p aj⋅2p−1​≡1(modp) 又因为 ap−1≡1(modp)a^{p-1} \\equiv 1 \\pmod pap−1≡1(modp)，所以 jjj 为偶数。令 i=j2i=\\frac{j}{2}i=2j​，则 (ai)2=n(a^i)^2=n(ai)2=n。因此 nnn 是关于 ppp 的二次剩余。 Cipolla 算法 找到一个数 aaa 满足 a2−na^2-na2−n 是非二次剩余，至于为什么要找满足非二次剩余的数，在下文会给出解释。我们随机生成 aaa 并检验，由于非二次剩余的数量为 p−12\\frac{p-1}{2}2p−1​，期望约 2 次就可以找到这个数。 建立一个“复数域”，并不是实际意义上的复数域，而是根据复数域的概念建立的一个类似的域。在复数中 i2=−1i^2=-1i2=−1，这里定义 i2=a2−ni^2=a^2-ni2=a2−n，于是就可以将所有的数表达为 A+BiA+BiA+Bi 的形式，这里的 AAA 和 BBB 都是模意义下的数，类似复数中的实部和虚部。 在有了 iii 和 aaa 后可以直接得到答案，x2≡n(modp)x^2 \\equiv n \\pmod px2≡n(modp) 的解为 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​。 证明 引理1： (a+b)p≡ap+bp(modp)(a+b)^p \\equiv a^p + b^p \\pmod p(a+b)p≡ap+bp(modp) 二项式展开即可 引理2： ip≡−i(modp)i^p \\equiv -i \\pmod pip≡−i(modp) ip≡ip−1×i(modp)≡(i2)p−12×i(modp)≡(a2−n)p−12×i(modp)≡−i(modp)\\begin{aligned} i^p &amp;\\equiv i^{p-1} \\times i &amp;\\pmod p\\\\ &amp;\\equiv (i^2)^{\\frac{p-1}{2}} \\times i &amp;\\pmod p\\\\ &amp;\\equiv (a^2-n)^{\\frac{p-1}{2}} \\times i &amp;\\pmod p\\\\ &amp;\\equiv -i &amp;\\pmod p \\end{aligned} ip​≡ip−1×i≡(i2)2p−1​×i≡(a2−n)2p−1​×i≡−i​(modp)(modp)(modp)(modp)​ 所以可得 x≡(a+i)p+12(modp)≡((a+i)p+1)12(modp)≡((a+i)p×(a+i))12(modp)≡((ap+ip)×(a+i))12(modp)≡((a−i)(a+i))12(modp)≡(a2−i2)12(modp)≡(a2−(a2−n))12(modp)≡n12(modp)\\begin{aligned} x &amp;\\equiv (a+i)^{\\frac{p+1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv ((a+i)^{p+1})^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv ((a+i)^p \\times (a+i))^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv ((a^p+i^p) \\times (a+i))^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv ((a-i)(a+i))^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv (a^2-i^2)^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv (a^2-(a^2-n))^{\\frac{1}{2}} &amp;\\pmod p\\\\ &amp;\\equiv n^{\\frac{1}{2}} &amp;\\pmod p \\end{aligned} x​≡(a+i)2p+1​≡((a+i)p+1)21​≡((a+i)p×(a+i))21​≡((ap+ip)×(a+i))21​≡((a−i)(a+i))21​≡(a2−i2)21​≡(a2−(a2−n))21​≡n21​​(modp)(modp)(modp)(modp)(modp)(modp)(modp)(modp)​ 代码实现 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;random&gt; #include &lt;chrono&gt; using namespace std; mt19937 mt_rand(chrono::steady_clock::now().time_since_epoch().count()); uniform_int_distribution&lt;int&gt; Rand(1, 2147483647); int t, n, p, sqri; struct comp { int r, i; comp operator*(const comp b) const { return (comp){(int)(1LL * r * b.r % p + 1LL * i * b.i % p * sqri % p) % p, (int)(1LL * r * b.i % p + 1LL * i * b.r % p) % p}; } }; comp ksm(comp a, int b) { comp s = (comp){1, 0}; while (b) { if (b &amp; 1) { s = s * a; } a = a * a; b &gt;&gt;= 1; } return s; } int ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = 1LL * s * a % p; } a = 1LL * a * a % p; b &gt;&gt;= 1; } return s; } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;p); if (!n) { printf(&quot;0\\n&quot;); continue; } if (ksm(n, (p - 1) / 2) == p - 1) { printf(&quot;Hola!\\n&quot;); continue; } int a = Rand(mt_rand) % p + 1, ans1, ans2; while (ksm(((1LL * a * a - n) % p + p) % p, (p - 1) / 2) == 1) { a = Rand(mt_rand) % p + 1; } sqri = ((1LL * a * a - n) % p + p) % p; ans1 = ksm((comp){a, 1}, (p + 1) / 2).r; ans2 = p - ans1; if (ans1 &gt; ans2) { swap(ans1, ans2); } printf(&quot;%d&quot;, ans1); if (ans1 != ans2) { printf(&quot; %d&quot;, ans2); } printf(&quot;\\n&quot;); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-er-ci-sheng-yu/"},{"title":"【模板】杜教筛","content":"杜教筛可以在亚线性时间内筛积性函数前缀和。 杜教筛的主要思想就是构造一个 S(n)S(n)S(n) 关于 S(⌊ni⌋)S(\\left\\lfloor\\frac{n}{i}\\right\\rfloor)S(⌊in​⌋) 的递推式。因为对于一个数论函数 ggg，必然满足 ∑i=1n∑d∣if(d)g(id)=∑d=1n∑i=1⌊ni⌋g(d)f(i)=∑i=1ng(i)∑j=1⌊ni⌋f(j)=∑i=1ng(i)S(⌊ni⌋)\\begin{aligned} \\sum\\limits_{i=1}^n\\sum\\limits_{d \\mid i}f(d)g\\left(\\dfrac{i}{d}\\right)&amp;=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{i}\\rfloor}g(d)f(i)\\\\ &amp;=\\sum\\limits_{i=1}^ng(i)\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\ &amp;=\\sum\\limits_{i=1}^ng(i)S\\left(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\right) \\end{aligned} i=1∑n​d∣i∑​f(d)g(di​)​=d=1∑n​i=1∑⌊in​⌋​g(d)f(i)=i=1∑n​g(i)j=1∑⌊in​⌋​f(j)=i=1∑n​g(i)S(⌊in​⌋)​ 即 ∑i=1n(f∗g)(i)=∑i=1ng(i)S(⌊ni⌋)\\sum\\limits_{i=1}^n(f*g)(i)=\\sum\\limits_{i=1}^ng(i)S\\left(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\right) i=1∑n​(f∗g)(i)=i=1∑n​g(i)S(⌊in​⌋) 那么可以得到递推式 g(1)S(n)=∑i=1n(f∗g)(i)−∑i=2ng(i)S(⌊ni⌋)g(1)S(n)=\\sum\\limits_{i=1}^n(f*g)(i)-\\sum\\limits_{i=2}^ng(i)S\\left(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\right) g(1)S(n)=i=1∑n​(f∗g)(i)−i=2∑n​g(i)S(⌊in​⌋) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;unordered_map&gt; using namespace std; const int N = 1664512; int t, n, not_prime[N], p[150001], tot, mu[N]; long long phi[N]; unordered_map&lt;int, int&gt; summu; unordered_map&lt;int, long long&gt; sumphi; void init() { not_prime[1] = mu[1] = phi[1] = 1; for (int i = 2; i &lt; N; i++) { if (!not_prime[i]) { p[++tot] = i; mu[i] = -1; phi[i] = i - 1; } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt; N; j++) { not_prime[i * p[j]] = 1; if (!(i % p[j])) { mu[i * p[j]] = 0; phi[i * p[j]] = phi[i] * p[j]; break; } mu[i * p[j]] = -mu[i]; phi[i * p[j]] = phi[i] * (p[j] - 1); } } for (int i = 2; i &lt; N; i++) { mu[i] += mu[i - 1]; phi[i] += phi[i - 1]; } } int calc_mu(int x) { if (x &lt; N) { return mu[x]; } if (summu.count(x)) { return summu[x]; } int r, ans = 0; for (unsigned int l = 2; l &lt;= x; l = r + 1) { r = x / (x / l); ans += (r - l + 1) * calc_mu(x / l); } return summu[x] = 1 - ans; } long long calc_phi(int x) { if (x &lt; N) { return phi[x]; } if (sumphi.count(x)) { return sumphi[x]; } int r; long long ans = 0; for (unsigned int l = 2; l &lt;= x; l = r + 1) { r = x / (x / l); ans += (r - l + 1) * calc_phi(x / l); } return sumphi[x] = 1LL * x * (x + 1LL) / 2 - ans; } int main(int argc, char const *argv[]) { init(); scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d&quot;, &amp;n); printf(&quot;%lld %d\\n&quot;, calc_phi(n), calc_mu(n)); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-du-jiao-shai/"},{"title":"【模板】Pólya 定理","content":"Pólya 定理是 Burnside 引理在环上的特殊情况。 Burnside 引理： 设 GGG 是一个作用在集合 XXX 上的有限群。对 g∈Gg \\in Gg∈G，设 XgX^gXg 表示 XXX 中在 ggg 作用下的不动元素（也称轨道数），则表示 GGG 作用在 XXX 上产生的所有等价类的集合 X/GX/GX/G 满足: ∣X/G∣=1∣G∣∑g∈G∣Xg∣|X/G|=\\dfrac{1}{|G|}\\sum\\limits_{g \\in G}|X^g| ∣X/G∣=∣G∣1​g∈G∑​∣Xg∣ 容易发现，本质不同的 nnn 个点的环可以看作在群 GGG 为 {\\{{旋转 0 个，旋转 1 个，…\\ldots…，旋转 (n−1)(n−1)(n−1) 个}\\}} 这些置换作用下得到的等价类的数量。 我们知道对于每个置换 ggg，我们一定能把它表示成循环的形式。那么我们定义 LgL_gLg​ 为 ggg 的循环节数，kkk 为颜色数（这里 k=nk=nk=n），则有 kLg=∣Xg∣k^{L_g}=|X^g|kLg​=∣Xg∣。那么问题就转化为了求 LgL_gLg​。 这里的置换只有旋转，于是可以简单解决。首先我们设这是第 iii 次旋转（初始状态算第一次旋转），则有每个循环节长度为 lcm⁡(n,i)/i\\operatorname{lcm}(n,i)/ilcm(n,i)/i，那么 Lg=n/(lcm⁡(n,i)/i)L_g=n/(\\operatorname{lcm}(n,i)/i)Lg​=n/(lcm(n,i)/i)，即 Lg=gcd⁡(n,i)L_g=\\gcd(n,i)Lg​=gcd(n,i)。即： ans=1n∑i=1nkgcd⁡(n,i)\\textit{ans}=\\dfrac{1}{n}\\sum\\limits_{i=1}^nk^{\\gcd(n,i)} ans=n1​i=1∑n​kgcd(n,i) 剩下的就是莫比乌斯反演那一套的套路工作了: ans=1n∑i=1nkgcd⁡(n,i)=1n∑d∣nnd∑i=1nd[gcd⁡(i,nd)=1]=1n∑d∣nndφ(nd)\\begin{aligned} \\textit{ans}&amp;=\\dfrac{1}{n}\\sum\\limits_{i=1}^nk^{\\gcd(n,i)}\\\\ &amp;=\\dfrac{1}{n}\\sum\\limits_{d \\mid n}n^d\\sum\\limits_{i=1}^{\\frac{n}{d}}\\left[\\gcd\\left(i,\\dfrac{n}{d}\\right)=1\\right]\\\\ &amp;=\\dfrac{1}{n}\\sum\\limits_{d \\mid n}n^d\\varphi\\left(\\dfrac{n}{d}\\right) \\end{aligned} ans​=n1​i=1∑n​kgcd(n,i)=n1​d∣n∑​ndi=1∑dn​​[gcd(i,dn​)=1]=n1​d∣n∑​ndφ(dn​)​ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int MOD = 1e9 + 7; int t, n; int ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = 1LL * s * a % MOD; } a = 1LL * a * a % MOD; b &gt;&gt;= 1; } return s; } int phi(int x) { int ans = x; for (int i = 2; i * i &lt;= x; i++) { if (!(x % i)) { ans = ans / i * (i - 1); while (!(x % i)) { x /= i; } } } if (x &gt; 1) { ans = ans / x * (x - 1); } return ans; } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d&quot;, &amp;n); int ans = 0; for (int i = 1; i * i &lt;= n; i++) { if (!(n % i)) { ans = (ans + 1LL * ksm(n, i) * phi(n / i) % MOD) % MOD; if (n / i != i) { ans = (ans + 1LL * ksm(n, n / i) * phi(i) % MOD) % MOD; } } } ans = 1LL * ans * ksm(n, MOD - 2) % MOD; printf(&quot;%d\\n&quot;, ans); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-polya-ding-li/"},{"title":"提高组模拟赛 9「加法与乘法」题解","content":"提高组模拟赛 9「加法与乘法」题解 题意 有一个整数 SSS，你可以对它进行如下两种操作： S←S+aS \\gets S + aS←S+a S←S×bS \\gets S \\times bS←S×b 求将 SSS 变成 TTT 至少需要几次，如果不能，输出 −1-1−1。 解法 首先考虑普通的情况，我们可以用如下式子来表示这个过程： T=((S+t1×a)×bk1+t2×a)×bk2+⋯T=((S+t_1 \\times a) \\times b^{k_1}+t_2 \\times a) \\times b^{k_2}+\\cdots T=((S+t1​×a)×bk1​+t2​×a)×bk2​+⋯ 那如果我们先乘 bbb 再加 aaa，显然不如先加 aaa 再乘 bbb，可以确定这样的贪心是正确的。 但是我们不能确定乘法和加法的次数，因此我们需要枚举乘法的次数，考虑到 b&gt;1b&gt;1b&gt;1 的情况下乘法次数为 log⁡T\\log TlogT 级别的，每次贪心地将 SSS 加满 aaa 之后再乘 bbb 就可以解决问题了。 但这题主要问题在于有很多人特判不够写挂分了，因此我们需要对各种特殊情况进行处理，具体可以看代码。 事实上我在比赛时写了一个暴力 bfs 的代码进行对拍，并用 generator 造了一些特殊数据才找出 2 个错误。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long S, T, a, b, x[20]; void checkmin(long long &amp;x, long long y) { if (x &gt; y) { x = y; } } int main(int argc, char const *argv[]) { scanf(&quot;%lld%lld%lld%lld&quot;, &amp;S, &amp;T, &amp;a, &amp;b); if (S == T) { printf(&quot;0&quot;); return 0; } if (!b) { if (!T) { printf(&quot;1&quot;); return 0; } if (!a) { printf(&quot;-1&quot;); return 0; } if (T &gt;= S &amp;&amp; !((T - S) % a)) { printf(&quot;%lld&quot;, (T - S) / a); return 0; } if (!(T % a)) { printf(&quot;%lld&quot;, T / a + 1); return 0; } printf(&quot;-1&quot;); return 0; } if (T &lt; S) { printf(&quot;-1&quot;); return 0; } if (b == 1) { if (!a) { printf(&quot;-1&quot;); return 0; } if (!((T - S) % a)) { printf(&quot;%lld&quot;, (T - S) / a); return 0; } printf(&quot;-1&quot;); return 0; } if (!a) { if (!S) { printf(&quot;-1&quot;); return 0; } int cnt = 0; while (1) { if (T / S &lt; b) { break; } cnt++; S *= b; } if (S == T) { printf(&quot;%d&quot;, cnt); } else { printf(&quot;-1&quot;); } return 0; } long long tmp = T, ans = 5e18; int tot = 0; x[0] = T; while (tmp /= b) { x[++tot] = tmp; } for (int i = 0; i &lt;= tot &amp;&amp; x[i] &gt;= S; i++) { long long t = 0, now = S; for (int j = i; j &gt;= 1; j--) { t += (x[j] - now) / a + 1; now = (now + (x[j] - now) / a * a) * b; } if ((T - now) % a) { continue; } checkmin(ans, t + (T - now) / a); } if (ans == 5e18) { printf(&quot;-1&quot;); } else { printf(&quot;%lld&quot;, ans); } return 0; } ","link":"http://xyf007.ml/post/ti-gao-zu-mo-ni-sai-9-jia-fa-yu-cheng-fa-ti-jie/"},{"title":"【模板】线性基","content":"线性基是一种擅长处理异或问题的数据结构。 性质 通俗一点的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质： 线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。 线性基是满足性质 1 的最小的集合。 线性基没有异或和为 0 的子集。 线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。 线性基中每个元素的二进制最高位互不相同。 构建 构造线性基的方法如下： 对原集合的每个数 ppp 转为二进制，从高位向低位扫，对于第 xxx 位是 1 的，如果 axa_xax​ 不存在，那么令 ax=pa_x=pax​=p 并结束扫描，如果存在，令 p=pxor⁡axp=p \\operatorname{xor} a_xp=pxorax​。 用法 查询原集合内任意几个元素 xor 的最大值。 将线性基从高位向低位扫，若 xor 上当前扫到的 axa_xax​ 答案变大，就把答案异或上 axa_xax​。因为从高往低位扫，若当前扫到第 iii 位，意味着可以保证答案的第 iii 位为1，且后面没有机会改变第 iii 位。 查询原集合内任意几个元素 xor 的最小值。 线性基集合所有元素中最小的那个。 查询某个数是否能被异或出来。 类似于插入，如果最后插入的数 ppp 被异或成了0，则能被异或出来。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n; long long a[70]; int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { long long x; scanf(&quot;%lld&quot;, &amp;x); for (int j = 63; j &gt;= 0; j--) { if ((x &gt;&gt; j) &amp; 1) { if (!a[j]) { a[j] = x; break; } x ^= a[j]; } } } long long ans = 0; for (int i = 63; i &gt;= 0; i--) { if ((ans ^ a[i]) &gt; ans) { ans ^= a[i]; } } printf(&quot;%lld&quot;, ans); return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-xing-ji/"},{"title":"【模板】线段树合并","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int maxx, pos, ls, rs; } t[6000001]; struct edge { int to, nxt; edge(int to = 0, int nxt = -1) : to(to), nxt(nxt) {} } e[200001]; int n, m, E, head[100001], tot, dep[100001], fa[100001][21], lg[100001], root[100001], ans[100001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void init() { for (int i = 1; i &lt;= 100000; i++) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); } } void dfs(int u, int f) { dep[u] = dep[f] + 1; fa[u][0] = f; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i++) { fa[u][i] = fa[fa[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v != f) { dfs(v, u); } } } int lca(int u, int v) { if (dep[u] &lt; dep[v]) { swap(u, v); } while (dep[u] &gt; dep[v]) { u = fa[u][lg[dep[u] - dep[v]] - 1]; } if (u == v) { return u; } for (int i = lg[dep[u]] - 1; i &gt;= 0; i--) { if (fa[u][i] != fa[v][i]) { u = fa[u][i]; v = fa[v][i]; } } return fa[u][0]; } void pushup(int x) { t[x].maxx = max(t[t[x].ls].maxx, t[t[x].rs].maxx); t[x].pos = t[t[x].ls].maxx &gt;= t[t[x].rs].maxx ? t[t[x].ls].pos : t[t[x].rs].pos; } void modify(int p, int l, int r, int val, int x) { if (l == r) { t[x].maxx += val; t[x].pos = l; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { if (!t[x].ls) { t[x].ls = ++tot; } modify(p, l, mid, val, t[x].ls); } else { if (!t[x].rs) { t[x].rs = ++tot; } modify(p, mid + 1, r, val, t[x].rs); } pushup(x); } int merge(int l, int r, int x1, int x2) { if (!x1 || !x2) { return x1 + x2; } if (l == r) { t[x1].maxx += t[x2].maxx; if (t[x2].maxx &gt; t[x1].maxx) { t[x1].pos = t[x2].pos; } return x1; } int mid = (l + r) &gt;&gt; 1; t[x1].ls = merge(l, mid, t[x1].ls, t[x2].ls); t[x1].rs = merge(mid + 1, r, t[x1].rs, t[x2].rs); pushup(x1); return x1; } void dfs2(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } dfs2(v, u); merge(1, 100000, root[u], root[v]); } if (t[root[u]].maxx) { ans[u] = t[root[u]].pos; } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); add(v, u); } dfs(1, 0); for (int i = 1; i &lt;= 100000; i++) { root[i] = ++tot; } for (int i = 1; i &lt;= m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); modify(z, 1, 100000, 1, root[x]); modify(z, 1, 100000, 1, root[y]); modify(z, 1, 100000, -1, root[lca(x, y)]); modify(z, 1, 100000, -1, root[fa[lca(x, y)][0]]); } dfs2(1, 0); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d\\n&quot;, ans[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-duan-shu-he-bing/"},{"title":"【模板】LCT","content":"class LinkCutTree { private: int ch_[100001][2], fa_[100001], rev_[100001]; bool NotRoot(int); bool IsRson(int); void Pushup(int); void Reverse(int); void Pushdown(int); void PushdownAll(int); void Rotate(int); public: int sum_[100001]; LinkCutTree() {} void Splay(int); void Access(int); int FindRoot(int); void MakeRoot(int); void Split(int, int); void Link(int, int); void Cut(int, int); ~LinkCutTree() {} } T; bool LinkCutTree::NotRoot(int x) { return ch_[fa_[x]][0] == x || ch_[fa_[x]][1] == x; } bool LinkCutTree::IsRson(int x) { return ch_[fa_[x]][1] == x; } void LinkCutTree::Pushup(int x) { sum_[x] = sum_[ch_[x][0]] ^ sum_[ch_[x][1]] ^ a[x]; } void LinkCutTree::Reverse(int x) { std::swap(ch_[x][0], ch_[x][1]); rev_[x] ^= 1; } void LinkCutTree::Pushdown(int x) { if (rev_[x]) { if (ch_[x][0]) { Reverse(ch_[x][0]); } if (ch_[x][1]) { Reverse(ch_[x][1]); } rev_[x] = 0; } } void LinkCutTree::PushdownAll(int x) { if (NotRoot(x)) { PushdownAll(fa_[x]); } Pushdown(x); } void LinkCutTree::Rotate(int x) { int y = fa_[x], z = fa_[y], d1 = IsRson(x), d2 = IsRson(y), w = ch_[x][d1 ^ 1]; if (NotRoot(y)) { ch_[z][d2] = x; } ch_[x][d1 ^ 1] = y; ch_[y][d1] = w; if (w) { fa_[w] = y; } fa_[x] = z; fa_[y] = x; Pushup(y); Pushup(x); } void LinkCutTree::Splay(int x) { PushdownAll(x); while (NotRoot(x)) { int y = fa_[x]; if (NotRoot(y)) { Rotate(IsRson(x) == IsRson(y) ? y : x); } Rotate(x); } Pushup(x); } void LinkCutTree::Access(int x) { for (int y = 0; x; y = x, x = fa_[x]) { Splay(x); ch_[x][1] = y; Pushup(x); } } int LinkCutTree::FindRoot(int x) { Access(x); Splay(x); while (ch_[x][0]) { Pushdown(x); x = ch_[x][0]; } Splay(x); return x; } void LinkCutTree::MakeRoot(int x) { Access(x); Splay(x); Reverse(x); } void LinkCutTree::Split(int x, int y) { MakeRoot(x); Access(y); Splay(y); } void LinkCutTree::Link(int x, int y) { MakeRoot(x); if (FindRoot(y) != x) { fa_[x] = y; } } void LinkCutTree::Cut(int x, int y) { MakeRoot(x); if (FindRoot(y) == x &amp;&amp; fa_[y] == x &amp;&amp; !ch_[y][0]) { ch_[x][1] = fa_[y] = 0; Pushup(x); } } ","link":"http://xyf007.ml/post/mu-ban-lct/"},{"title":"【模板】扩展中国剩余定理（EXCRT）","content":"求解如下形式的一元线性同余方程组： {x≡a1(modb1)x≡a2(modb2)⋮x≡an(modbn)\\begin{cases} x &amp;\\equiv a_1 &amp;\\pmod {b_1}\\\\ x &amp;\\equiv a_2 &amp;\\pmod {b_2}\\\\ &amp;\\vdots\\\\ x &amp;\\equiv a_n &amp;\\pmod {b_n} \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​xxx​≡a1​≡a2​⋮≡an​​(modb1​)(modb2​)(modbn​)​ 设已经求出前 i−1i-1i−1 个方程组成的同余方程组的一个解为 x≡t(modM)x \\equiv t \\pmod Mx≡t(modM)，其中 M=lcm⁡(b1,b2,…,bi−1)M=\\operatorname{lcm}(b_1,b_2,\\ldots,b_{i-1})M=lcm(b1​,b2​,…,bi−1​)，那么对于加入第 iii 个方程后的方程组，我们就是要求一个正整数 kkk，使得 x+k∗M≡ai(modbi)x+k*M \\equiv a_i \\pmod {b_i}x+k∗M≡ai​(modbi​)，即 k∗M≡ai−x(modbi)k*M \\equiv a_i-x \\pmod {b_i}k∗M≡ai​−x(modbi​)，可以通过扩展欧几里得求解 kkk。若该同余式无解，则整个方程组无解；若有，则前 iii 个同余式组成的方程组的一个解解为 xi=x+k∗Mx_i=x+k*Mxi​=x+k∗M。 所以整个算法的思路就是求解 nnn 次扩展欧几里得。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long n, a[100001], b[100001]; long long mul(long long x, long long y, long long MOD) { return (x * y - (long long)((long double)x / MOD * y) * MOD + MOD) % MOD; } long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) { if (!b) { x = 1; y = 0; return a; } long long GCD = exgcd(b, a % b, x, y); long long tmp = x; x = y; y = tmp - a / b * y; return GCD; } long long excrt() { long long B = b[1], x, y, ans = a[1]; for (int i = 2; i &lt;= n; i++) { long long C = (a[i] - ans % b[i] + b[i]) % b[i], GCD = exgcd(B, b[i], x, y), bb = b[i] / GCD; if (C % GCD) { return -1; } x = mul(x, C / GCD, bb); ans += x * B; B *= bb; ans = (ans % B + B) % B; } return (ans + B) % B; } int main(int argc, char const *argv[]) { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld%lld&quot;, &amp;b[i], &amp;a[i]); } printf(&quot;%lld&quot;, excrt()); return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuo-zhan-zhong-guo-sheng-yu-ding-li/"},{"title":"【技术】如何挂梯子","content":"总结一些挂梯子的经验 最开始我使用蓝灯，后来学会了更好的翻墙方法 注：以下内容均为我现在在使用的方法 访问 Ghelper的主页或者蓝奏云下载 zip（国内浏览器如360、QQ 均使用 Chrome 内核，选择 Chrome的即可） 解压，根据其中的“中国大陆安装方法”进行安装 点击安装好的插件，会跳出登陆界面，注册登陆即可 访问 Chrome网上应用店，搜索 Astar VPN 并安装 点击 Astar 的图标，按下插件中的电源键就完成了 ","link":"http://xyf007.ml/post/ji-shu-ru-he-gua-ti-zi/"},{"title":"【模板】数论变换（NTT）","content":"NTT 的模板及学习笔记 前言 FFT 虽然能快速处理卷积，但是它也有很大的弊端。精度问题有时会导致一些错误。而且，有许多题目涉及了取模，比如 998244353，复数域下的 DFT 精度更是暴露无遗。于是考虑是否有模意义下的这种算法。于是，便出现了快速数论变换（FNT）。 考虑一下我们 FFT 时用了单位根的哪些性质 ωnn=1\\omega_n^n=1ωnn​=1 ωn1,ωn2,…,ωnn\\omega_n^1,\\omega_n^2,\\ldots,\\omega_n^nωn1​,ωn2​,…,ωnn​ 互不相同，满足了点值表示的条件 ωnk=ω2n2k,ωnk+n2=−ωnk\\omega_n^k=\\omega_{2n}^{2k},\\omega_n^{k+\\frac{n}{2}}=-\\omega_n^kωnk​=ω2n2k​,ωnk+2n​​=−ωnk​，这个是分治的基础 ωn−k=conj⁡(ωnk)\\omega_n^{-k}=\\operatorname{conj}(\\omega_n^k)ωn−k​=conj(ωnk​) ∑k=0n−1(ωnj−i){0(i≠j)n(i=j)\\sum_{k=0}^{n-1}(\\omega_n^{j-i}) \\begin{cases} 0&amp;(i \\neq j)\\\\ n&amp;(i=j) \\end{cases}∑k=0n−1​(ωnj−i​){0n​(i​=j)(i=j)​ 这个是 IDFT 的基础 原根 我们需要找满足上面的性质的整数，于是我们找到了原根。 对于一个质数 ppp，其原根满 ggg 足 g0,g1,g2,…,gp−2g^0,g^1,g^2,\\ldots,g^{p-2}g0,g1,g2,…,gp−2 在模 ppp 意义下两两不同。 可以发现，nnn 需要是 p−1p-1p−1 的因数，才能满足条件。由于 nnn 是 2 的幂，所以对 ppp 也有一定的要求。ppp 得是形如 r×2k+1r \\times 2^k+1r×2k+1 的素数，其中 2k≥n2^k \\geq n2k≥n。 有一些非常常见的 NTT 模数： 469762049=7×226+1469762049=7 \\times 2^{26}+1469762049=7×226+1，原根为 333 998244353=119×223+1998244353=119 \\times 2^{23}+1998244353=119×223+1，原根为 333 1004535809=479×221+11004535809=479 \\times 2^{21}+11004535809=479×221+1，原根为 333 更多 NTT 模数 现在我们来证明一下原根满足上面的那些性质。 令 gnn≡1(modp)g_n^n \\equiv 1 \\pmod pgnn​≡1(modp)（即 gn≡gr(modp)g_n \\equiv g^r \\pmod pgn​≡gr(modp)），等价于 ωn\\omega_nωn​。 ωnn=1\\omega_n^n=1ωnn​=1 根据定义，显然成立。 ωn1,ωn2,…,ωnn−1\\omega_n^1,\\omega_n^2,\\ldots,\\omega_n^{n-1}ωn1​,ωn2​,…,ωnn−1​ 互不相同 根据定义，也显然成立。 ωnk=ω2n2k,ωnk+n2=−ωnk\\omega_n^k=\\omega_{2n}^{2k},\\omega_n^{k+\\frac{n}{2}}=-\\omega_n^kωnk​=ω2n2k​,ωnk+2n​​=−ωnk​ 由于 gn≡gr(modp)g_n \\equiv g^r \\pmod pgn​≡gr(modp)，其中由于 n×r=p−1n \\times r=p-1n×r=p−1，当 nnn 取 n2\\frac{n}{2}2n​ 时，rrr 取 2r2r2r，所以 gn2≡g2r≡(gr)2≡gn2(modp)g_{\\frac{n}{2}} \\equiv g^{2r} \\equiv (g^r)^2 \\equiv g_n^2 \\pmod pg2n​​≡g2r≡(gr)2≡gn2​(modp)。 由费马小定理可得 gp−1−1≡(gp−12+1)(gp−12−1)g^{p-1}-1 \\equiv (g^{\\frac{p-1}{2}}+1)(g^{\\frac{p-1}{2}-1})gp−1−1≡(g2p−1​+1)(g2p−1​−1)，所以 gp−12≡±1(modp)g^{\\frac{p-1}{2}} \\equiv \\pm 1 \\pmod pg2p−1​≡±1(modp)。又由于 ggg 为原根，满足第 2 条性质。由于 g0≡1(modp)g^0 \\equiv 1 \\pmod pg0≡1(modp)，所以 gp−12≡−1(modp)g^{\\frac{p-1}{2}} \\equiv -1 \\pmod pg2p−1​≡−1(modp)。于是：gnn2≡gp−12≡−1(modp)g_n^{\\frac{n}{2}} \\equiv g^{\\frac{p-1}{2}} \\equiv -1 \\pmod pgn2n​​≡g2p−1​≡−1(modp) 即 gnk+n2≡gnk×gnn2≡−gnk(modp)g_n^{k+\\frac{n}{2}} \\equiv g_n^k \\times g_n^{\\frac{n}{2}} \\equiv -g_n^k \\pmod pgnk+2n​​≡gnk​×gn2n​​≡−gnk​(modp)。 ωn−k=conj⁡(ωnk)\\omega_n^{-k}=\\operatorname{conj}(\\omega_n^k)ωn−k​=conj(ωnk​) ∑k=0n−1(ωnj−i){0(i≠j)n(i=j)\\sum_{k=0}^{n-1}(\\omega_n^{j-i}) \\begin{cases} 0&amp;(i \\neq j)\\\\ n&amp;(i=j) \\end{cases}∑k=0n−1​(ωnj−i​){0n​(i​=j)(i=j)​ 由于 4 的第一项不是很重要，所以可以不管（直接逆元算算就好了）。 ∑k=1n−1gnk(j−i)≡{n(i=j)∑k=0n−1(gnj−i)k≡1−(gnj−i)n1−gnj−i≡0(i≠j)(modp)\\sum_{k=1}^{n-1}g_n^{k(j-i)} \\equiv \\begin{cases} n&amp;(i=j)\\\\ \\sum_{k=0}^{n-1}(g_n^{j-i})^k \\equiv \\dfrac{1-(g_n^{j-i})^n}{1-g_n^{j-i}} \\equiv 0&amp;(i \\neq j) \\end{cases} \\pmod p∑k=1n−1​gnk(j−i)​≡⎩⎨⎧​n∑k=0n−1​(gnj−i​)k≡1−gnj−i​1−(gnj−i​)n​≡0​(i=j)(i​=j)​(modp) 综上所述，原根满足了 FFT 要用到的单位根的性质，于是我们可以把单位复根替换成原根，再写个和 FFT 差不多的就可以了。 代码实现 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; constexpr int kMod = 998244353, kG = 3; int n, m, rev[4000001], a[4000001], b[4000001], g[4000001], ig[4000001]; int read() { char c = getchar(); int s = 0; while (c &lt; '0' || c &gt; '9') { c = getchar(); } s = c - 48; while ((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') { s = s * 10 + c - '0'; } return s; } int Ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = s * static_cast&lt;long long&gt;(a) % kMod; } a = a * static_cast&lt;long long&gt;(a) % kMod; b &gt;&gt;= 1; } return s; } void NTT(int *a, int n, int op) // op = 1: DFT, op = -1: IDFT { for (int i = 0; i &lt; n; i++) { if (i &lt; rev[i]) { std::swap(a[i], a[rev[i]]); } } for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { int wn = op == 1 ? g[mid &lt;&lt; 1] : ig[mid &lt;&lt; 1], a1, a2; for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) { int w = 1; for (int j = 0; j &lt; mid; j++) { a1 = a[i + j]; a2 = static_cast&lt;long long&gt;(w) * a[i + j + mid] % kMod; a[i + j] = (a1 + a2) % kMod; a[i + j + mid] = (a1 - a2 + kMod) % kMod; w = w * static_cast&lt;long long&gt;(wn) % kMod; } } } if (op == -1) { int inv = Ksm(n, kMod - 2); for (int i = 0; i &lt; n; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(inv) % kMod; } } } int main(int argc, char const *argv[]) { n = read(); m = read(); for (int i = 0; i &lt;= n; i++) { a[i] = read(); } for (int i = 0; i &lt;= m; i++) { b[i] = read(); } int len = 1, cnt = 0; while (len &lt;= n + m) { cnt++; len &lt;&lt;= 1; } for (int i = 0; i &lt; len; i++) { rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); } g[len] = Ksm(kG, (kMod - 1) &gt;&gt; cnt); ig[len] = Ksm(g[len], kMod - 2); for (int i = cnt - 1; i &gt;= 0; i--) { g[1 &lt;&lt; i] = g[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(g[1 &lt;&lt; (i + 1)]) % kMod; ig[1 &lt;&lt; i] = ig[1 &lt;&lt; (i + 1)] * static_cast&lt;long long&gt;(ig[1 &lt;&lt; (i + 1)]) % kMod; } NTT(a, len, 1); NTT(b, len, 1); for (int i = 0; i &lt; len; i++) { a[i] = a[i] * static_cast&lt;long long&gt;(b[i]) % kMod; } NTT(a, len, -1); for (int i = 0; i &lt;= n + m; i++) { std::cout &lt;&lt; a[i] &lt;&lt; ' '; } return 0; } 例题 [HEOI2016/TJOI2016]求和 计算这样一个函数的值： f(n)=∑i=0n∑j=0iS(i,j)⋅2j⋅j!f(n)=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^iS(i,j) \\cdot 2^j \\cdot j! f(n)=i=0∑n​j=0∑i​S(i,j)⋅2j⋅j! 其中S(i,j)S(i,j)S(i,j)表示第二类斯特林数 考虑j&gt;ij&gt;ij&gt;i时S(i,j)=0S(i,j)=0S(i,j)=0，于是原式可化为 f(n)=∑i=0n∑j=0nS(i,j)⋅2j⋅j!=∑j=0n2j⋅j!∑i=0nS(i,j)=∑j=0n2j⋅j!∑i=0n1j!∑k=0j(−1)k(jk)(j−k)n=∑j=0n2j⋅j!∑k=0j(−1)kk!(j−k)!∑i=0n(j−k)i=∑j=0n2j⋅j!∑k=0j(−1)kk!(j−k)!⋅(j−k)n+1−1j−k−1=∑j=0n2j⋅j!∑k=0n(−1)kk!⋅(j−k)n+1−1(j−k)!(j−k−1)\\begin{aligned} f(n)&amp;=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^nS(i,j) \\cdot 2^j \\cdot j!\\\\ &amp;=\\sum\\limits_{j=0}^n2^j \\cdot j!\\sum\\limits_{i=0}^nS(i,j)\\\\ &amp;=\\sum\\limits_{j=0}^n2^j \\cdot j!\\sum\\limits_{i=0}^n\\dfrac{1}{j!}\\sum\\limits_{k=0}^j(-1)^k\\binom{j}{k}(j-k)^n\\\\ &amp;=\\sum\\limits_{j=0}^n2^j \\cdot j!\\sum\\limits_{k=0}^j\\dfrac{(-1)^k}{k!(j-k)!}\\sum\\limits_{i=0}^n(j-k)^i\\\\ &amp;=\\sum\\limits_{j=0}^n2^j \\cdot j!\\sum\\limits_{k=0}^j\\dfrac{(-1)^k}{k!(j-k)!} \\cdot \\dfrac{(j-k)^{n+1}-1}{j-k-1}\\\\ &amp;=\\sum\\limits_{j=0}^n2^j \\cdot j!\\sum\\limits_{k=0}^n\\dfrac{(-1)^k}{k!} \\cdot \\dfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)} \\end{aligned} f(n)​=i=0∑n​j=0∑n​S(i,j)⋅2j⋅j!=j=0∑n​2j⋅j!i=0∑n​S(i,j)=j=0∑n​2j⋅j!i=0∑n​j!1​k=0∑j​(−1)k(kj​)(j−k)n=j=0∑n​2j⋅j!k=0∑j​k!(j−k)!(−1)k​i=0∑n​(j−k)i=j=0∑n​2j⋅j!k=0∑j​k!(j−k)!(−1)k​⋅j−k−1(j−k)n+1−1​=j=0∑n​2j⋅j!k=0∑n​k!(−1)k​⋅(j−k)!(j−k−1)(j−k)n+1−1​​ 于是就可以 NTT 卷积了。 DFT 就是将右边这个多项式的每一项的系数算出来，然后一次性带入，再 IDFT 转回去。（这里以前没有理解，以为是算出右边多项式的值） 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; const int MOD = 998244353, g = 3; int n, rev[400001], a[400001], b[400001], fac[400001], inv[400001], INV[400001], mul[400001]; int ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = 1LL * s * a % MOD; } a = 1LL * a * a % MOD; b &gt;&gt;= 1; } return s; } void NTT(int *a, int n, int inv) // DFT:inv=1 IDFT:inv=-1 { for (int i = 0; i &lt; n; i++) { if (i &lt; rev[i]) { swap(a[i], a[rev[i]]); } } for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { int wn = ksm(g, (MOD - 1) / (mid &lt;&lt; 1)); if (inv == -1) { wn = ksm(wn, MOD - 2); } for (int i = 0; i &lt; n; i += (mid &lt;&lt; 1)) { int w = 1, a1, a2; for (int j = 0; j &lt; mid; j++) { a1 = a[i + j]; a2 = 1LL * w * a[i + j + mid] % MOD; a[i + j] = (a1 + a2) % MOD; a[i + j + mid] = (a1 - a2 + MOD) % MOD; w = 1LL * w * wn % MOD; } } } if (inv == -1) { int inv = ksm(n, MOD - 2); for (int i = 0; i &lt; n; i++) { a[i] = 1LL * a[i] * inv % MOD; } } } int main() { scanf(&quot;%d&quot;, &amp;n); a[0] = b[0] = fac[0] = fac[1] = inv[1] = INV[1] = mul[0] = 1; mul[1] = 2; for (int i = 2; i &lt;= n; i++) { fac[i] = 1LL * i * fac[i - 1] % MOD; inv[i] = 1LL * (MOD - MOD / i) * inv[MOD % i] % MOD; INV[i] = 1LL * INV[i - 1] * inv[i] % MOD; mul[i] = 2LL * mul[i - 1] % MOD; } int f = -1; for (int i = 1; i &lt;= n; i++) { a[i] = (f * INV[i] % MOD + MOD) % MOD; f *= -1; } b[1] = n + 1; for (int i = 2; i &lt;= n; i++) { b[i] = 1LL * (ksm(i, n + 1) - 1) * INV[i] % MOD * inv[i - 1] % MOD; } int cnt = -1, len = 1; while (len &lt;= n + n) { len &lt;&lt;= 1; cnt++; } for (int i = 0; i &lt; len; i++) { rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1; if (i &amp; 1) { rev[i] |= (1 &lt;&lt; cnt); } } NTT(a, len, 1); NTT(b, len, 1); for (int i = 0; i &lt; len; i++) { a[i] = 1LL * a[i] * b[i] % MOD; } NTT(a, len, -1); int ans = 0; for (int i = 0; i &lt;= n; i++) { ans = (ans + 1LL * a[i] * mul[i] % MOD * fac[i] % MOD) % MOD; } printf(&quot;%d&quot;, ans); return 0; } ","link":"http://xyf007.ml/post/mu-ban-shu-lun-bian-huan-ntt/"},{"title":"【模板】扩展卢卡斯","content":"计算 Cnm mod pC_n^m \\bmod pCnm​modp（ppp 不为质数） 首先对于 ppp 进行质因数分解：p=∏pikip=\\prod p_i^{k_i}p=∏piki​​，则如果可以求出每个 Cnm≡ai(modpiki)C_n^m \\equiv a_i \\pmod {p_i^{k_i}}Cnm​≡ai​(modpiki​​)，那么对于同余方程组 {Cnm≡a1(modp1k1)Cnm≡a2(modp2k2)⋮Cnm≡an(modpnkn)\\begin{cases} C_n^m &amp;\\equiv a_1 &amp;\\pmod {p_1^{k_1}}\\\\ C_n^m &amp;\\equiv a_2 &amp;\\pmod {p_2^{k_2}}\\\\ &amp;\\vdots\\\\ C_n^m &amp;\\equiv a_n &amp;\\pmod {p_n^{k_n}} \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​Cnm​Cnm​Cnm​​≡a1​≡a2​⋮≡an​​(modp1k1​​)(modp2k2​​)(modpnkn​​)​ 使用中国剩余定理即可求出 CnmC_{n}^{m}Cnm​ 的值。 接下来考虑如何计算 Cnm mod ptC_n^m \\bmod p^tCnm​modpt。 首先由组合数的公式 Cnm=n!m!(n−m)!C_{n}^{m}=\\dfrac{n!}{m!(n-m)!}Cnm​=m!(n−m)!n!​，如果可以分别计算出 n!,m!,(n−m)!n!, m!, (n-m)!n!,m!,(n−m)! 在模 ptp^tpt 意义下的值，那么就可以得到答案。 比如，当 p=3,t=2,n=19p=3,t=2,n=19p=3,t=2,n=19 时，有： n!=1×2×3×⋯×19=(1×2×4×5×7×8×10×11×13×14×16×17×19)×(3×6×9×12×15×18)=(1×2×4×5×7×8×10×11×13×14×16×17×19)×36×(1×2×3×4×5×6)\\begin{aligned} n!&amp;=1 \\times 2 \\times 3 \\times \\cdots \\times 19\\\\ &amp;=(1 \\times 2 \\times 4 \\times 5 \\times 7 \\times 8 \\times 10 \\times 11 \\times 13 \\times 14 \\times 16 \\times 17 \\times 19) \\times (3 \\times 6 \\times 9 \\times 12 \\times 15 \\times 18)\\\\ &amp;=(1 \\times 2 \\times 4 \\times 5 \\times 7 \\times 8 \\times 10 \\times 11 \\times 13 \\times 14 \\times 16 \\times 17 \\times 19) \\times 3^6 \\times(1 \\times2 \\times3 \\times4 \\times5 \\times6) \\end{aligned} n!​=1×2×3×⋯×19=(1×2×4×5×7×8×10×11×13×14×16×17×19)×(3×6×9×12×15×18)=(1×2×4×5×7×8×10×11×13×14×16×17×19)×36×(1×2×3×4×5×6)​ 可以看到后面一部分在模意义下相当于 (n/p)!(n/p)!(n/p)!，于是可以递归进行计算。 前面一部分是以 ptp^tpt 为周期的，也就是 1×2×4×5×7×8≡10×11×13×14×16×17(mod32)1 \\times 2 \\times 4 \\times 5 \\times 7 \\times 8 \\equiv 10 \\times 11 \\times 13 \\times 14 \\times 16 \\times 17 \\pmod{3^2}1×2×4×5×7×8≡10×11×13×14×16×17(mod32)，所以只需要计算最后不满足一个周期的数是哪些就可以了（这个例子中就只要计算 191919）。显然，不满足一个周期的数的个数不超过 ptp^tpt 个。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; long long n, m, p; long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) { if (!b) { x = 1; y = 0; return a; } long long res = exgcd(b, a % b, x, y), t; t = x; x = y; y = t - a / b * y; return res; } long long ksm(long long a, long long b, long long p) { long long s = 1; while (b) { if (b &amp; 1) { s = s * a % p; } a = a * a % p; b &gt;&gt;= 1; } return s; } long long fac(long long n, long long pi, long long pk) { if (!n) { return 1; } long long res = 1; for (long long i = 2; i &lt;= pk; i++) { if (i % pi) { res = res * i % pk; } } res = ksm(res, n / pk, pk); for (long long i = 2; i &lt;= n % pk; i++) { if (i % pi) { res = res * i % pk; } } return res * fac(n / pi, pi, pk) % pk; } long long inv(long long n, long long p) { long long x, y; exgcd(n, p, x, y); return (x % p + p) % p; } long long CRT(long long b, long long mod) { return b * inv(p / mod, mod) % p * (p / mod) % p; } long long C(long long n, long long m, long long pi, long long pk) { long long sum = fac(n, pi, pk), d1 = fac(m, pi, pk), d2 = fac(n - m, pi, pk), k = 0; for (long long i = n; i; i /= pi) { k += i / pi; } for (long long i = m; i; i /= pi) { k -= i / pi; } for (long long i = n - m; i; i /= pi) { k -= i / pi; } return sum * inv(d1, pk) % pk * inv(d2, pk) % pk * ksm(pi, k, pk) % pk; } long long exlucas(long long n, long long m) { long long ans = 0, tmp = p, pk; for (int i = 2; i * i &lt;= tmp; i++) { if (!(tmp % i)) { pk = 1; while (!(tmp % i)) { pk *= i; tmp /= i; } ans = (ans + CRT(C(n, m, i, pk), pk)) % p; } } if (tmp &gt; 1) { ans = (ans + CRT(C(n, m, tmp, tmp), tmp)) % p; } return ans; } int main() { scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p); printf(&quot;%lld\\n&quot;, exlucas(n, m)); return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuo-zhan-lu-ka-si/"},{"title":"【模板】扩展 BSGS","content":"在 a,pa,pa,p 不互质的情况下求解 ax≡b(modp)a^x \\equiv b \\pmod pax≡b(modp) 当 gcd⁡(a,p)=1\\gcd(a,p)=1gcd(a,p)=1 时，在模 ppp 意义下 aaa 存在逆元，因此可以使用 BSGS 算法求解。于是我们想办法让他们变得互质。 设 d=gcd⁡(a,p)d=\\gcd(a,p)d=gcd(a,p)，如果 d∤bd \\nmid bd∤b 则无解，否则原方程变为 ad×ax−1≡bd(modpd)\\dfrac{a}{d} \\times a^{x-1} \\equiv \\dfrac{b}{d} \\pmod {\\dfrac{p}{d}}da​×ax−1≡db​(moddp​)，这样一直约分直到 a,pa,pa,p 互质 设此时一共递归了 cntcntcnt 次，这 cntcntcnt 次的 ddd 的乘积为 ∏i=1cntdi\\textstyle\\prod_{i=1}^{cnt}d_i∏i=1cnt​di​，原式变为 ax−cnt×acnt∏i=1cntdi≡b∏i=1cntdi(modp∏i=1cntdi)a^{x-cnt} \\times \\dfrac{a^{cnt}}{\\textstyle\\prod_{i=1}^{cnt}d_i} \\equiv \\dfrac{b}{\\textstyle\\prod_{i=1}^{cnt}d_i} \\pmod {\\dfrac{p}{\\textstyle\\prod_{i=1}^{cnt}d_i}} ax−cnt×∏i=1cnt​di​acnt​≡∏i=1cnt​di​b​(mod∏i=1cnt​di​p​) 那么跑一次 BSGS 就行了，答案还要再加上 cntcntcnt，而且，还有一个 acnt∏i=1cntdi\\dfrac{a^{cnt}}{\\textstyle\\prod_{i=1}^{cnt}d_i}∏i=1cnt​di​acnt​ 的系数要乘上，具体对应代码中的变量 c，要传参到 BSGS 的函数里，可以避免求逆元。 如果某一步 acnt∏i=1cntdi=b∏i=1cntdi\\dfrac{a^{cnt}}{\\textstyle\\prod_{i=1}^{cnt}d_i}=\\dfrac{b}{\\textstyle\\prod_{i=1}^{cnt}d_i}∏i=1cnt​di​acnt​=∏i=1cnt​di​b​ 了，直接返回枚举的 cntcntcnt，因为我们需要求最小自然数解。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;unordered_map&gt; using namespace std; int a, b, p; int ksm(int a, int b, int p) { int s = 1; while (b) { if (b &amp; 1) { s = 1LL * s * a % p; } a = 1LL * a * a % p; b &gt;&gt;= 1; } return s; } int BSGS(int a, int b, int p, int c) { unordered_map&lt;int, int&gt; mp; int t = sqrt(p), tmp = ksm(a, t, p), s = c; if (!tmp) { return -1; } for (int i = 0; i &lt; t; i++) { mp[1LL * b * ksm(a, i, p) % p] = i; } for (int i = 0; i &lt;= t; i++) { int j = mp.count(s) ? mp[s] : -1; if (j != -1 &amp;&amp; i * t - j &gt;= 0) { return i * t - j; } s = 1LL * s * tmp % p; } return -1; } int exBSGS(int a, int b, int p) { if (b == 1 || p == 1) { return 0; } int cnt = 0, d, c = 1; while ((d = __gcd(a, p)) != 1) { if (b % d) { return -1; } cnt++; b /= d; p /= d; c = 1LL * c * (a / d) % p; if (c == b) { return cnt; } } int ans = BSGS(a, b, p, c); if (ans == -1) { return -1; } return ans + cnt; } int main(int argc, char const *argv[]) { while (~scanf(&quot;%d%d%d&quot;, &amp;a, &amp;p, &amp;b) &amp;&amp; (a || b || p)) { int ans = exBSGS(a, b, p); if (ans == -1) { printf(&quot;No Solution\\n&quot;); } else { printf(&quot;%d\\n&quot;, ans); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuo-zhan-bsgs/"},{"title":"【模板】快速傅里叶变换（FFT）","content":"FFT 的模板及学习笔记 前置知识 多项式的系数表示法和点值表示法 系数表示法 一个 n−1n-1n−1 次 nnn 项多项式 f(x)f(x)f(x) 可以表示为 f(x)=∑i=0n−1aixif(x)=\\textstyle\\sum_{i=0}^{n-1}a_ix_if(x)=∑i=0n−1​ai​xi​，也可以用每一项的系数来表示 f(x)f(x)f(x)，即 f(x)={a0,a1,a2,…,an−1}f(x)=\\{a_0,a_1,a_2,\\ldots,a_{n−1}\\}f(x)={a0​,a1​,a2​,…,an−1​}。 点值表示法 把多项式放到平面直角坐标系里面，看成一个函数，把 nnn 个不同的 xxx 代入，会得出 nnn 个不同的 yyy，在坐标系内就是 nnn 个不同的点，那么这 nnn 个点唯一确定该多项式。也就是有且仅有一个多项式满足 ∀k,f(xk)=yk\\forall k, f(x_k)=y_k∀k,f(xk​)=yk​。 那么 f(x)f(x)f(x) 还可以用 f(x)={(x0,f(x0)),(x1,f(x1)),(x2,f(x2)),…,(xn−1,f(xn−1))}f(x)=\\{(x_0,f(x_0)),(x_1,f(x_1)),(x_2,f(x_2)),\\ldots,(x_{n−1},f(x_{n−1}))\\}f(x)={(x0​,f(x0​)),(x1​,f(x1​)),(x2​,f(x2​)),…,(xn−1​,f(xn−1​))} 来表示。 FFT 其实是一个用 O(nlog⁡n)O(n \\log n)O(nlogn) 的时间将一个用系数表示的多项式转换成它的点值表示的算法。 朴素系数转点值的算法叫 DFT（离散傅里叶变换），点值转系数叫 IDFT（离散傅里叶逆变换）。 DFT 一定注意从这里开始所有的 nnn 都默认为 2 的整数次幂。 复数运算的重要知识 模长相乘，极角相加！ 单位根 对于任意系数多项式转点值，当然可以随便取任意 nnn 个 xxx 值代入计算，但是暴力计算 x0k,x1k,…,xn−1k(k∈[0,n))x_0^k,x_1^k,\\ldots,x_{n−1}^k(k \\in [0,n))x0k​,x1k​,…,xn−1k​(k∈[0,n)) 当然是 O(n2)O(n^2)O(n2) 的时间。 其实可以代入一组神奇的 xxx，代入以后不用做那么多的次方运算。 这些 xxx 当然不是乱取的，而且取这些 xxx 值应该就是傅里叶的主意了。 考虑一下，如果我们代入一些 xxx，使每个 xxx 的若干次方等于 1，我们就不用做全部的次方运算了。 ±1\\pm 1±1 是可以的，考虑虚数的话 ±i\\pm i±i 也可以，但只有这四个数远远不够。 以原点为圆心，画一个半径为 1 的单位圆，那么单位圆上所有的点都可以经过若干次次方得到 1，每个点均为单位根。 数学上，nnn 次单位根是 nnn 次幂为 111 的复数。它们位于复平面的单位圆上，构成正多边形的顶点，但最多只可有两个顶点同时标在实数线上。——Wikipedia 记编号为 kkk 的点代表的复数值为 ωnk\\omega_n^kωnk​，那么由模长相乘，极角相加可知 (ωn1)k=ωnk(\\omega_n^1)^k=\\omega_n^k(ωn1​)k=ωnk​。 其中 ωn1\\omega_n^1ωn1​ 称为 nnn 次单位根，而且每一个 ω\\omegaω 都可以按照如下公式求出： ωnk=cos⁡kn2π+isin⁡kn2π\\omega_n^k=\\cos\\dfrac{k}{n}2\\pi+i\\sin\\dfrac{k}{n}2\\pi ωnk​=cosnk​2π+isinnk​2π 那么 ωn0,ωn1,…,ωnn−1\\omega_n^0,\\omega_n^1,\\ldots,\\omega_n^{n-1}ωn0​,ωn1​,…,ωnn−1​ 即为要代入的 x0,x1,…,xn−1x_0,x_1,\\ldots,x_{n-1}x0​,x1​,…,xn−1​。 单位根的性质 ωnk=ω2n2k\\omega_n^k=\\omega_{2n}^{2k}ωnk​=ω2n2k​ ωnk+n2=−ωnk\\omega_n^{k+\\frac{n}{2}}=-\\omega_n^kωnk+2n​​=−ωnk​ FFT 递归版 虽然 DFT 搞出来一堆很牛逼的 ω\\omegaω 作为代入多项式的 x 值，但只是代入这类特殊 x 值法的变换叫做 DFT 而已，还是要代入单位根暴力计算。 DFT 还是暴力 O(n2)O(n^2)O(n2) 的。 但 DFT 可以分治来做，于是 FFT（快速傅里叶变换）就出来了。 首先设一个多项式 A(x)A(x)A(x) A(x)=∑i=0n−1aixi=a0+a1x+a2x2+…+an−1xn−1A(x)=\\sum\\limits_{i=0}^{n-1}a_ix^i=a_0+a_1x+a_2x^2+\\ldots+a_{n-1}x^{n-1} A(x)=i=0∑n−1​ai​xi=a0​+a1​x+a2​x2+…+an−1​xn−1 按 A(x)A(x)A(x) 下标的奇偶性把 A(x)A(x)A(x) 分成两半，右边再提一个 xxx A(x)=(a0+a2x2+…+an−2xn−2)+(a1x+a3x3+…+ax−1xx−1)=(a0+a2x2+…+an−2xn−2)+x(a1+a3x2+…+an−1xn−2)\\begin{aligned} A(x)&amp;=(a_0+a_2x^2+\\ldots+a_{n-2}x^{n-2})+(a_1x+a_3x^3+\\ldots+a_{x-1}x^{x-1})\\\\ &amp;=(a_0+a_2x^2+\\ldots+a_{n-2}x^{n-2})+x(a_1+a_3x^2+\\ldots+a_{n-1}x^{n-2}) \\end{aligned} A(x)​=(a0​+a2​x2+…+an−2​xn−2)+(a1​x+a3​x3+…+ax−1​xx−1)=(a0​+a2​x2+…+an−2​xn−2)+x(a1​+a3​x2+…+an−1​xn−2)​ 两边好像非常相似，于是再设两个多项式 A1(x),A2(x)A_1(x),A_2(x)A1​(x),A2​(x)，令 A1(x)=a0+a2x+a4x2+…+an−2xn2−1A_1(x)=a_0+a_2x+a_4x^2+\\ldots+a_{n-2}x^{\\frac{n}{2}-1} A1​(x)=a0​+a2​x+a4​x2+…+an−2​x2n​−1 A2(x)=a1+a3x+a5x2+…+an−1xn2−1A_2(x)=a_1+a_3x+a_5x^2+\\ldots+a_{n-1}x^{\\frac{n}{2}-1} A2​(x)=a1​+a3​x+a5​x2+…+an−1​x2n​−1 显然 A(x)=A1(x2)+xA2(x2)A(x)=A_1(x^2)+xA_2(x^2) A(x)=A1​(x2)+xA2​(x2) 再设 k&lt;n2k&lt;\\dfrac{n}{2}k&lt;2n​，把 ωnk\\omega_n^kωnk​ 代替 xxx 代入 A(x)A(x)A(x) 得 A(ωnk)=A1((ωnk)2)+ωnkA2((ωnk)2)=A1(ωn2k)+ωnkA2(ωn2k)=A1(ωn2k)+ωnkA2(ωn2k)\\begin{aligned} A(\\omega_n^k)&amp;=A_1((\\omega_n^k)^2)+\\omega_n^kA_2((\\omega_n^k)^2)\\\\ &amp;=A_1(\\omega_n^{2k})+\\omega_n^kA_2(\\omega_n^{2k})\\\\ &amp;=A_1(\\omega_{\\frac{n}{2}}^k)+\\omega_n^kA_2(\\omega_{\\frac{n}{2}}^k) \\end{aligned} A(ωnk​)​=A1​((ωnk​)2)+ωnk​A2​((ωnk​)2)=A1​(ωn2k​)+ωnk​A2​(ωn2k​)=A1​(ω2n​k​)+ωnk​A2​(ω2n​k​)​ 再把 ωnk+n2\\omega_n^{k+\\frac{n}{2}}ωnk+2n​​ 代入得 A(ωnk+n2)=A1((ωnk+n2)2)+ωnk+n2A2((ωnk+n2)2)=A1(ωn2k+n)+ωnk+n2A2(ωn2k+n)=A1(ωn2kωnn)−ωnkA2(ωn2kωnn)=A1(ωn2k)−ωnkA2(ωn2k)\\begin{aligned} A(\\omega_n^{k+\\frac{n}{2}})&amp;=A_1((\\omega_n^{k+\\frac{n}{2}})^2)+\\omega_n^{k+\\frac{n}{2}}A_2((\\omega_n^{k+\\frac{n}{2}})^2)\\\\ &amp;=A_1(\\omega_n^{2k+n})+\\omega_n^{k+\\frac{n}{2}}A_2(\\omega_n^{2k+n})\\\\ &amp;=A_1(\\omega_n^{2k}\\omega_n^n)-\\omega_n^kA_2(\\omega_n^{2k}\\omega_n^n)\\\\ &amp;=A_1(\\omega_{\\frac{n}{2}}^k)-\\omega_n^kA_2(\\omega_{\\frac{n}{2}}^k) \\end{aligned} A(ωnk+2n​​)​=A1​((ωnk+2n​​)2)+ωnk+2n​​A2​((ωnk+2n​​)2)=A1​(ωn2k+n​)+ωnk+2n​​A2​(ωn2k+n​)=A1​(ωn2k​ωnn​)−ωnk​A2​(ωn2k​ωnn​)=A1​(ω2n​k​)−ωnk​A2​(ω2n​k​)​ 发现了什么？ A(ωnk)A(\\omega_n^k)A(ωnk​) 和 A(ωnk+n2)A(\\omega_n^{k+\\frac{n}{2}})A(ωnk+2n​​) 两个多项式后面的东西只有符号不同！ 也就是说，如果已知 A1(ωn2k)A_1(\\omega_{\\frac{n}{2}}^k)A1​(ω2n​k​) 和 A2(ωn2k)A_2(\\omega_{\\frac{n}{2}}^k)A2​(ω2n​k​) 的值，我们就可以同时知道 A(ωnk)A(\\omega_n^k)A(ωnk​) 和 A(ωnk+n2)A(\\omega_n^{k+\\frac{n}{2}})A(ωnk+2n​​) 的值。 现在我们就可以递归分治来做 FFT 了。 每一次回溯时只扫当前前面一半的序列，即可得出后面一半序列的答案。 n=1n=1n=1 时只有一个常数项，直接return。 时间复杂度 O(nlog⁡n)O(n \\log n)O(nlogn)。 迭代版 递归版 FFT 常数大，需要优化。 这个很容易发现点什么吧？ 每个位置分治后的最终位置为其二进制翻转后得到的位置。 这样的话就可以 O(n)O(n)O(n) 预处理第 iii 位最终的位置 rev[i]rev[i]rev[i]。 IFFT 想一下，我们不仅要会 FFT，还要会 IFFT。 我们把两个多项式相乘（也叫求卷积），做完两遍 FFT 也知道了积的多项式的点值表示。 可我们平时用系数表示的多项式，点值表示没有意义。 怎么把点值表示的多项式快速转回系数表示法？ IDFT 暴力 O(n2)O(n^2)O(n2) 做？ 其实也可以 FFT 用 O(nlog⁡n)O(n \\log n)O(nlogn) 的时间搞。 只用记住一个结论： 一个多项式在分治的过程中乘上单位根的共轭复数，分治完的每一项除以 nnn 即为原多项式的每一项系数。 三次变两次优化 按照一般的做法，如果我们要求出 F(x)F(x)F(x) 和 G(x)G(x)G(x) 的卷积，会把它们分别 FFT，然后对应每项乘起来，最后再 IFFT 回来，一共进行了三次FFT，感觉这样是很不优的。 考虑到 (a+bi)2=(a2−b2)+2abi(a+bi)^2=(a^2-b^2)+2abi(a+bi)2=(a2−b2)+2abi，我们可以把 G(x)G(x)G(x) 放到 F(x)F(x)F(x) 的虚部上去，求出 F(x)2F(x)^2F(x)2，然后把 F(x)F(x)F(x) 的虚部取出来除以 222 就是答案了。 代码实现 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; const double pi = acos(-1.0); struct cp { double x, y; cp(double a = 0, double b = 0) { x = a; y = b; } cp operator+(cp b) { return cp(x + b.x, y + b.y); } cp operator-(cp b) { return cp(x - b.x, y - b.y); } cp operator*(cp b) { return cp(x * b.x - y * b.y, x * b.y + y * b.x); } } a[4000001]; int n, m, rev[4000001]; void FFT(cp *a, int n, int inv) // DFT:inv=1 IDFT:inv=-1 { for (int i = 0; i &lt; n; i++) { if (i &lt; rev[i]) { swap(a[i], a[rev[i]]); } } for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { cp wn(cos(pi / mid), inv * sin(pi / mid)), a1, a2; for (int i = 0; i &lt; n; i += (mid &lt;&lt; 1)) { cp w(1, 0); for (int j = 0; j &lt; mid; j++) { a1 = a[i + j]; a2 = w * a[i + j + mid]; a[i + j] = a1 + a2; a[i + j + mid] = a1 - a2; w = w * wn; } } } if (inv == -1) { for (int i = 0; i &lt; n; i++) { a[i].x /= n, a[i].y /= n; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) { scanf(&quot;%lf&quot;, &amp;a[i].x); } for (int i = 0; i &lt;= m; i++) { scanf(&quot;%lf&quot;, &amp;a[i].y); } int cnt = -1, len = 1; while (len &lt;= n + m) { len &lt;&lt;= 1; cnt++; } for (int i = 0; i &lt; len; i++) { rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1; if (i &amp; 1) { rev[i] |= (1 &lt;&lt; cnt); } } FFT(a, len, 1); for (int i = 0; i &lt; len; i++) { a[i] = a[i] * a[i]; } FFT(a, len, -1); for (int i = 0; i &lt;= n + m; i++) { printf(&quot;%d &quot;, (int)(a[i].y / 2 + 0.5)); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuai-su-fu-li-xie-bian-huan-fft/"},{"title":"【模板】中国剩余定理（CRT）","content":"求解如下形式的一元线性同余方程组（其中 b1,b2,…,bnb_1,b_2,\\ldots,b_nb1​,b2​,…,bn​ 两两互质）： {x≡a1(modb1)x≡a2(modb2)⋮x≡an(modbn)\\begin{cases} x &amp;\\equiv a_1 &amp;\\pmod {b_1}\\\\ x &amp;\\equiv a_2 &amp;\\pmod {b_2}\\\\ &amp;\\vdots\\\\ x &amp;\\equiv a_n &amp;\\pmod {b_n} \\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​xxx​≡a1​≡a2​⋮≡an​​(modb1​)(modb2​)(modbn​)​ 计算所有模数的积 mulmulmul； 对于第 iii 个方程： 计算 m=mulbim=\\dfrac{mul}{b_i}m=bi​mul​； 计算 mmm 在模 bib_ibi​ 意义下的逆元 m−1m^{-1}m−1； 计算 ci=mimi−1c_i=m_im_i^{-1}ci​=mi​mi−1​（不要对 nin_ini​ 取模）。 方程组的唯一解为：x=∑i=1naici(modmul)x=\\textstyle\\sum_{i=1}^na_ic_i \\pmod {mul}x=∑i=1n​ai​ci​(modmul)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long n, mul, a[11], b[11]; void exgcd(long long a, long long b, long long &amp;x, long long &amp;y) { if (!b) { x = 1; y = 0; return; } exgcd(b, a % b, x, y); long long tmp = x; x = y; y = tmp - a / b * y; } int main(int argc, char const *argv[]) { scanf(&quot;%lld&quot;, &amp;n); mul = 1; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld%lld&quot;, &amp;a[i], &amp;b[i]); mul *= a[i]; } long long ans = 0; for (int i = 1; i &lt;= n; i++) { long long m = mul / a[i], x, y; exgcd(m, a[i], x, y); ans = (ans + b[i] * m * x) % mul; } printf(&quot;%lld&quot;, (ans + mul) % mul); return 0; } ","link":"http://xyf007.ml/post/mu-ban-zhong-guo-sheng-yu-ding-li-crt/"},{"title":"【模板】Baby-Step Giant-Step","content":"求解 ax≡b(modp)a^x \\equiv b \\pmod pax≡b(modp)。 令 x=i×t−jx=i \\times t - jx=i×t−j，其中 t=⌈p⌉,0≤j≤p−1t=\\lceil\\sqrt{p}\\rceil,0 \\leq j \\leq p-1t=⌈p​⌉,0≤j≤p−1，则方程变为 ai×t−j≡b(modp)a^{i \\times t-j} \\equiv b \\pmod pai×t−j≡b(modp)，即(at)i≡b×aj(modp)(a^t)^i \\equiv b \\times a^j \\pmod p(at)i≡b×aj(modp)。 对于所有的 j∈[0,t−1]j \\in [0,t-1]j∈[0,t−1]，把 b×aj mod pb \\times a^j \\bmod pb×ajmodp 插入一个 Hash 表。 枚举 iii 的所有可能取值，即 i∈[0,t]i \\in [0,t]i∈[0,t]，计算出 (at)i mod p(a^t)^i \\bmod p(at)imodp，在 Hash 表中查找是否存在对应的 jjj，更新答案即可。 时间复杂度为 O(p)O(\\sqrt{p})O(p​)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;map&gt; using namespace std; int p, a, b; map&lt;int, int&gt; mp; int ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = 1LL * s * a % p; } a = 1LL * a * a % p; b &gt;&gt;= 1; } return s; } int main(int argc, char const *argv[]) { scanf(&quot;%d%d%d&quot;, &amp;p, &amp;a, &amp;b); int t = sqrt(p), tmp = ksm(a, t), s = 1; if (!tmp) { printf(&quot;no solution&quot;); return 0; } for (int i = 0; i &lt; t; i++) { mp[1LL * b * ksm(a, i) % p] = i; } for (int i = 0; i &lt;= t; i++) { int j = mp.count(s) ? mp[s] : -1; if (j != -1 &amp;&amp; i * t - j &gt;= 0) { printf(&quot;%d&quot;, i * t - j); return 0; } s = 1LL * s * tmp % p; } printf(&quot;no solution&quot;); return 0; } ","link":"http://xyf007.ml/post/mu-ban-baby-step-giant-step/"},{"title":"【模板】后缀自动机（SAM）","content":"后缀自动机（SAM） SAM 可以解决常见的几乎所有的字符串问题，极其强劲。 直观上，字符串的 SAM 可以理解为给定字符串的所有子串的压缩形式。对于一个长度为 nnn 的字符串，它的空间复杂度仅为 O(n)O(n)O(n)。此外，构造 SAM 的时间复杂度仅为 O(n)O(n)O(n)。准确地说，一个 SAM 最多有 2n−12n-12n−1 个节点和 3n−43n-43n−4 条转移边。它的 parent 树是原字符串的反串的后缀树。 好工具：SAM 绘制器-SAM Drawer 定义 字符串 sss 的 SAM 是一个接受 sss 的所有后缀的最小 DFA（确定性有限自动机或确定性有限状态自动机）。 换句话说： SAM 是一张有向无环图。结点被称作状态，边被称作状态间的转移。 图存在一个源点 t0t_0t0​，称作初始状态，其他各结点均可从 t0t_0t0​ 出发到达。 每个转移都标有一些字母，从一个结点出发的所有转移均不同。 存在一个或多个终止状态。如果我们从初始状态 t0t_0t0​ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 sss 的一个后缀。sss 的每个后缀均可用一条从 t0t_0t0​ 到某个终止状态的路径构成。 在所有满足上述条件的自动机中，SAM 的结点数是最少的。 性质 SAM 最简单、也最重要的性质是，它包含关于字符串 sss 的所有子串的信息。任意从初始状态 t0t_0t0​ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 sss 的一个子串。反之每个 sss 的子串对应从 t0t_0t0​ 开始的某条路径。 为了简化表达，我们称子串对应一条路径（从 t0t_0t0​ 开始、由一些标号构成这个子串）。反过来，我们说任意一条路径对应它的标号构成的字符串。 到达某个状态的路径可能不止一条，因此我们说一个状态对应一些字符串的集合，这个集合的每个元素对应这些路径。 一些概念 结束位置 endpos⁡\\operatorname{endpos}endpos 考虑字符串 sss 的任意非空子串 ttt，我们记 endpos⁡(t)\\operatorname{endpos}(t)endpos(t) 为在字符串 sss 中 ttt 的所有结束位置。例如，对于字符串 abcbc\\texttt{abcbc}abcbc，我们有 endpos⁡(bc)={2,4}\\operatorname{endpos}(\\texttt{bc})=\\{2,4\\}endpos(bc)={2,4}。可能有很多子串的 endpos⁡\\operatorname{endpos}endpos 相同，可以根据 endpos⁡\\operatorname{endpos}endpos 将它们划分为若干等价类。 SAM 的每个状态都对应了这样一个等价类，故 SAM 的总状态数为等价类的数量加一（初始状态）。 由 endpos⁡\\operatorname{endpos}endpos 的值我们可以得到一些重要结论： 引理 1： 字符串 sss 的两个非空子串 uuu 和 www（∣u∣≤∣w∣|u| \\leq |w|∣u∣≤∣w∣）的 endpos⁡\\operatorname{endpos}endpos 相同，当且仅当字符串 uuu 在 sss 中的每次出现，都是以 www 后缀的形式存在的。 显然成立。 引理 2： 考虑两个非空子串 uuu 和 www（∣u∣≤∣w∣|u| \\leq |w|∣u∣≤∣w∣），要么 endpos⁡(u)∩endpos⁡(w)=∅\\operatorname{endpos}(u) \\cap \\operatorname{endpos}(w)=\\varnothingendpos(u)∩endpos(w)=∅，要么 endpos⁡(w)⊆endpos⁡(u)\\operatorname{endpos}(w) \\subseteq \\operatorname{endpos}(u)endpos(w)⊆endpos(u)，取决于 uuu 是否为 www 的一个后缀： {endpos⁡(w)⊆endpos⁡(u)if u is a suffix of wendpos⁡(w)∩endpos⁡(u)=∅otherwise\\begin{cases} \\operatorname{endpos}(w) \\subseteq \\operatorname{endpos}(u) &amp; \\text{if }u\\text{ is a suffix of }w\\\\ \\operatorname{endpos}(w) \\cap \\operatorname{endpos}(u) = \\varnothing &amp; \\text{otherwise} \\end{cases} {endpos(w)⊆endpos(u)endpos(w)∩endpos(u)=∅​if u is a suffix of wotherwise​ 如果集合 endpos⁡(u)\\operatorname{endpos}(u)endpos(u) 与 endpos⁡(w)\\operatorname{endpos}(w)endpos(w) 有至少一个公共元素，那么由于字符串 uuu 与 www 在相同位置结束，uuu 是 www 的一个后缀。所以在每次 www 出现的位置，子串 uuu 也会出现。所以 endpos⁡(w)⊆endpos⁡(u)\\operatorname{endpos}(w)\\subseteq \\operatorname{endpos}(u)endpos(w)⊆endpos(u)。 引理 3： 考虑一个 endpos⁡\\operatorname{endpos}endpos 等价类，将类中的所有子串按长度非递增的顺序排序。每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀。 换句话说，对于同一等价类的任意两子串，较短者为较长者的后缀，且该等价类中的子串长度递减排列恰好覆盖一个区间。 如果 endpos⁡\\operatorname{endpos}endpos 等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 111 的等价类。 由引理 1，两个不同的 endpos⁡\\operatorname{endpos}endpos 等价的字符串中，较短者总是较长者的真后缀。因此，等价类中没有等长的字符串。 记 www 为等价类中最长的字符串、uuu 为等价类中最短的字符串。由引理 1，字符串 uuu 是字符串 www 的真后缀。现在考虑长度在区间 [∣u∣,∣w∣][|u|,|w|][∣u∣,∣w∣] 中的 www 的任意后缀。容易看出，这个后缀也在同一等价类中，因为更短的后缀 uuu 在 sss 中只以 www 的后缀的形式存在。因此，由引理 1，这个后缀和字符串 www 的 endpos⁡\\operatorname{endpos}endpos 相同。 后缀链接 link⁡\\operatorname{link}link 考虑 SAM 中某个不是 t0t_0t0​ 的状态 vvv。我们已经知道，状态 vvv 对应于具有相同 endpos⁡\\operatorname{endpos}endpos 的等价类。我们如果定义 www 为这些字符串中最长的一个，则所有其他的字符串都是 www 的后缀。 我们还知道字符串 www 的前几个后缀（按长度降序考虑）全部包含于这个等价类，且所有其他后缀（至少有一个——空后缀）在其他的等价类中。我们记 ttt 为最长的这样的后缀，然后将 vvv 的后缀链接连到 ttt 上。 换句话说，一个后缀链接 link⁡(v)\\operatorname{link}(v)link(v) 连接到 www 的最长的，属于另一个 endpos⁡\\operatorname{endpos}endpos 等价类的后缀所在的状态。 引理 4： 所有后缀链接构成一棵根节点为 t0t_0t0​ 的树。 显然成立。 引理 5： 通过 endpos⁡\\operatorname{endpos}endpos 集合构造的树（每个子节点的子集都包含在父节点的子集中）与通过后缀链接 link⁡\\operatorname{link}link 构造的树相同。 由引理 2，任意一个 SAM 的 endpos⁡\\operatorname{endpos}endpos 集合形成了一棵树（因为两个集合要么完全没有交集要么其中一个是另一个的子集）。 考虑任意不是 t0t_0t0​ 的状态 vvv，其后缀链接 link⁡(v)\\operatorname{link}(v)link(v) 是它的后缀，所以 endpos⁡(v)⊆endpos⁡(link⁡(v))\\operatorname{endpos}(v) \\subseteq \\operatorname{endpos}(\\operatorname{link}(v))endpos(v)⊆endpos(link(v))。 因此，后缀链接构成的树本质上是 endpos⁡\\operatorname{endpos}endpos 集合构成的一棵树。这棵树就是 parent 树。 小结 每当感到迷惑时，请重新阅读此部分！ 在学习算法本身前，我们总结一下之前学过的知识，并引入一些辅助记号。 sss 的子串可以根据它们结束的位置 endpos⁡\\operatorname{endpos}endpos 被划分为多个等价类。 SAM 由初始状态 t0t_0t0​ 和与每一个 endpos⁡\\operatorname{endpos}endpos 等价类对应的状态组成。 对于每一个状态 vvv，一个或多个子串与之匹配。我们记 longest⁡(v)\\operatorname{longest}(v)longest(v) 为其中最长的一个字符串，记 len⁡(v)\\operatorname{len}(v)len(v) 为它的长度。类似地，记 shortest⁡(v)\\operatorname{shortest}(v)shortest(v) 为最短的子串，它的长度为 minlen⁡(v)\\operatorname{minlen}(v)minlen(v)。那么对应这个状态的所有字符串都是字符串 longest⁡(v)\\operatorname{longest}(v)longest(v) 的不同的后缀，且所有字符串的长度恰好覆盖区间 [minlen⁡(v),len⁡(v)][\\operatorname{minlen}(v),\\operatorname{len}(v)][minlen(v),len(v)] 中的每一个整数。 对于任意不是 t0t_0t0​ 的状态 vvv，定义后缀链接为连接到对应字符串 longest⁡(v)\\operatorname{longest}(v)longest(v) 的长度为 minlen⁡(v)−1\\operatorname{minlen}(v)-1minlen(v)−1 的后缀的一条边。从根节点 t0t_0t0​ 出发的后缀链接可以形成一棵树。这棵树（parent 树）也表示 endpos⁡\\operatorname{endpos}endpos 集合间的包含关系。 对于 t0t_0t0​ 以外的状态 vvv，minlen⁡(v)=len⁡(link⁡(v))+1\\operatorname{minlen}(v)=\\operatorname{len}(\\operatorname{link}(v))+1minlen(v)=len(link(v))+1。 如果我们从任意状态 v0v_0v0​ 开始顺着后缀链接遍历，总会到达初始状态 t0t_0t0​。这种情况下我们可以得到一个互不相交的区间 [minlen⁡(vi),len⁡(vi)][\\operatorname{minlen}(v_i),\\operatorname{len}(v_i)][minlen(vi​),len(vi​)] 的序列，且它们的并集形成了连续的区间 [0,len⁡(v0)][0,\\operatorname{len}(v_0)][0,len(v0​)]。 构建 SAM 这是一个在线算法，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护 SAM。 这里会先给出构建过程，再进行详细地解释。 算法流程 一开始 SAM 只包含一个状态 t0t_0t0​，编号为 000（其他状态的编号为 1,2,…1,2,\\ldots1,2,…）。为了方便，对于状态 t0t_0t0​ 我们指定 len=0\\textit{len}=0len=0、link=−1\\textit{link}=-1link=−1（−1-1−1 表示虚拟状态）。 我们用 last\\textit{last}last 表示目前为止整个字符串对应的状态，初值为 000。 接下来是添加一个字符 ccc 的过程： 创建一个新的状态 cur\\textit{cur}cur，并将 len⁡(cur)\\operatorname{len}(\\textit{cur})len(cur) 赋值为 len⁡(last)+1\\operatorname{len}(\\textit{last})+1len(last)+1，表示新加入 ccc 后整个串对应的状态。 现在我们从状态 last\\textit{last}last 开始遍历后缀链接上的每一个状态 ppp。如果 ppp 还没有到字符 ccc 的转移，我们就添加一个到状态 cur\\textit{cur}cur 的转移；如果 ppp 已经存在到字符 ccc 的转移，我们就停下来。 如果没有找到这样的状态 ppp，我们就到达了虚拟状态 −1-1−1，我们将 link⁡(cur)\\operatorname{link}(\\textit{cur})link(cur) 赋值为 000 并退出。 假设现在我们找到了一个状态 ppp，其可以通过字符 ccc 转移到状态 qqq，那么需要根据 len⁡(p)\\operatorname{len}(p)len(p) 和 len⁡(q)\\operatorname{len}(q)len(q) 的关系分类讨论两种情况。 如果 len⁡(p)+1=len⁡(q)\\operatorname{len}(p)+1=\\operatorname{len}(q)len(p)+1=len(q)，我们只要将 link⁡(cur)\\operatorname{link}(\\textit{cur})link(cur) 赋值为 qqq 并退出。 否则就会有些复杂，需要复制状态 qqq：我们创建一个新的状态 clone\\textit{clone}clone，复制 qqq 的除了 len⁡\\operatorname{len}len 的值以外的所有信息（后缀链接和转移）。我们将 len⁡(clone)\\operatorname{len}(\\textit{clone})len(clone) 赋值为 len⁡(p)+1\\operatorname{len}(p)+1len(p)+1。复制之后，我们将后缀链接从 cur\\textit{cur}cur 指向 clone\\textit{clone}clone，也从 qqq 指向 clone\\textit{clone}clone。最终我们需要从状态 ppp 开始继续遍历后缀链接，只要存在一条通过 ppp 到状态 qqq 的转移，就将该转移重定向到状态 clone\\textit{clone}clone。 在完成这个过程之后，我们将 last\\textit{last}last 的值更新为状态 cur\\textit{cur}cur。 具体解释 为什么走到第一个有 ccc 转移边的状态前要修改路径上的所有转移边？ SAM 本身作为 DAWG 是进行单词匹配的，显然要加入这样的转移。 为什么找到有 ccc 转移边的状态后要停下来？ 考虑找到第一个有 ccc 转移边之前的所有状态前，我们做了什么：将沿着 link⁡\\operatorname{link}link 跳到的所有状态对应的字符串结尾加上 ccc，然后加入 cur\\textit{cur}cur。所以 cur\\textit{cur}cur 对应了一些第一次出现的子串。 每一个子串必然只能出现在一个状态里（不同状态 endpos⁡\\operatorname{endpos}endpos 不同），如果遇到已经有转移边的状态，表明我们现在遇到了一些已经出现过的子串，它的 endpos⁡\\operatorname{endpos}endpos 与 cur\\textit{cur}cur 中这些第一次出现的子串显然不同，因此我们要停下来。 为什么 len⁡(q)=len⁡(p)+1\\operatorname{len}(q)=\\operatorname{len}(p)+1len(q)=len(p)+1 时就可以把 cur\\textit{cur}cur 连到 qqq 上？ 当我们找到 ppp 的时候，minlen⁡(cur)=len⁡(p)+2\\operatorname{minlen}(\\textit{cur})=\\operatorname{len}(p)+2minlen(cur)=len(p)+2（我们还加了一个字符 ccc）。因此 cur\\textit{cur}cur 将要连到一个 len⁡(q)=minlen⁡(cur)−1=len⁡(p)+1\\operatorname{len}(q)=\\operatorname{minlen}(\\textit{cur})-1=\\operatorname{len}(p)+1len(q)=minlen(cur)−1=len(p)+1 的点。 后面复制的那一段令人迷惑。 我们可以如图所示形象地表示状态 qqq。 cur\\textit{cur}cur 需要链接到 qqq 的下半部分，因此我们需要将 qqq 拆成两个部分。根据定义，连接 link⁡(q)=clone\\operatorname{link}(q)=\\textit{clone}link(q)=clone，如图： 注意到我们是拆开了状态 qqq，因此 clone\\textit{clone}clone 保存的信息应该与 qqq 相同。 最后一步我们将所有原来到 qqq 的转移改到 clone\\textit{clone}clone。 时间复杂度为 O(n)O(n)O(n)，空间复杂度为 O(n∣Σ∣)O(n|\\Sigma|)O(n∣Σ∣)。 代码实现 class SuffixAutomaton { public: SuffixAutomaton() { t_[0].link = -1; } void Expand(char c) { int cur = ++sz_, p = last_; t_[cur].len = t_[p].len + 1; while (p != -1 &amp;&amp; !t_[p].nxt[c - 'a']) { t_[p].nxt[c - 'a'] = cur; p = t_[p].link; } if (p == -1) { t_[cur].link = 0; } else { int q = t_[p].nxt[c - 'a']; if (t_[q].len == t_[p].len + 1) { t_[cur].link = q; } else { int nq = ++sz_; t_[nq].len = t_[p].len + 1; t_[nq].link = t_[q].link; std::memcpy(t_[nq].nxt, t_[q].nxt, sizeof(t_[q].nxt)); while (p != -1 &amp;&amp; t_[p].nxt[c - 'a'] == q) { t_[p].nxt[c - 'a'] = nq; p = t_[p].link; } t_[cur].link = t_[q].link = nq; } } last_ = cur; } void Build(const char *s) { for (std::size_t i = 0, n = std::strlen(s); i &lt; n; i++) Expand(s[i]); } ~SuffixAutomaton() {} private: struct Node { int len, link, nxt[26]; } t_[1000001]; int sz_, last_; }; 更多性质 尽管 SAM 本身由 nxt 组成，但 SAM 构造算法中作为辅助变量的 link 和 len 在应用中常常比 nxt 重要，甚至可以抛开 nxt 单独使用。 设字符串的长度为 nnn，考虑 Expand 操作中 cur 变量的值，这个节点对应的状态是执行 Expand 操作时的当前字符串，即字符串的一个前缀，每个前缀有一个终点。这样得到的 nnn 个节点，对应了 nnn 个不同的终点。设第 iii 个节点为 viv_ivi​，对应的是 S[1:i]S[1:i]S[1:i]，终点是 iii。姑且把这些节点称之为“终点节点”。 考虑给 SAM 赋予树形结构，树的根为 000，且其余节点 vvv 的父亲为 link⁡(v)\\operatorname{link}(v)link(v)。则这棵树与原 SAM 的关系是：每个节点的终点集合等于其子树内所有终点节点对应的终点的集合，每个状态的出现次数等于其子树内所有终点节点的总数。 证明：考虑每一个子串，我们在所有的包含它的后缀处统计它，这样不重不漏。而包含它的后缀所在的状态都在它的子树里。 这些字符串满足的性质是：如果节点 A 是 B 的祖先，则节点 A 对应的字符串是节点 B 对应的字符串的后缀。 这条性质把字符串所有前缀组成了一棵树，且有许多符合直觉的树的性质。例如，S[1:p]S[1:p]S[1:p] 和 S[1:q]S[1:q]S[1:q] 的最长公共后缀对应的字符串就是 vpv_pvp​ 和 vqv_qvq​ 对应的 LCA 的字符串。 每个状态 iii 对应的子串数量是 len⁡(i)−len⁡(link⁡(i))\\operatorname{len}(i)-\\operatorname{len}(\\operatorname{link}(i))len(i)−len(link(i))（节点 000 例外）。注意到 link⁡(i)\\operatorname{link}(i)link(i) 对应的字符串是 iii 对应的字符串的一个后缀，这些子串就是 iii 对应字符串的所有后缀，去掉被父亲“抢掉”的那部分，即 link⁡(i)\\operatorname{link}(i)link(i) 对应字符串的所有后缀。 例题 检查字符串是否出现 给一个文本串 TTT 和多个模式串 PPP ，我们要检查字符串 PPP 是否作为 TTT 的一个子串出现。 对 TTT 建 SAM，直接在上面沿着转移边跑就行了。 不同子串个数 给一个字符串 SSS ，计算不同子串的个数。 每个 SSS 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 t0t_0t0​ 为起点的不同路径的条数。在 DAWG 上 DP 或者利用 parent 树，每个节点对应的子串数量是 len⁡(i)−len⁡(link⁡(i))\\operatorname{len}(i)-\\operatorname{len}(\\operatorname{link}(i))len(i)−len(link(i))，对所有节点求和即可（在线算法不用计算复制节点，离线建完统计时则需要计算复制的节点）。 例题：【模板】后缀自动机，SDOI2016 生成魔咒。 字典序第 kkk 大子串 给定一个字符串 SSS。多组询问，每组询问给定一个数 kkk ，查询 SSS 的所有子串中字典序第 kkk 大的子串。 解决这个问题的思路可以从解决前两个问题的思路发展而来。字典序第 kkk 大的子串对应于 SAM 中字典序第 kkk 大的路径，因此在计算每个状态的路径数后，我们可以很容易地从 SAM 的根开始找到第 kkk 大的路径。 预处理的时间复杂度为 O(∣S∣)O(|S|)O(∣S∣)，单次查询的复杂度为 O(∣ans∣×∣Σ∣)O(|ans| \\times |\\Sigma|)O(∣ans∣×∣Σ∣)（其中 ansansans 是查询的答案，∣Σ∣|\\Sigma|∣Σ∣ 为字符集的大小）。 两个字符串的最长公共子串 给定两个字符串 SSS 和 TTT，求出最长公共子串。 先对 SSS 建 SAM，接着我们对于 TTT 的每一个前缀 T[1:i]T[1:i]T[1:i]，匹配这个前缀最长的后缀。 具体过程类似 KMP，设匹配完 T[1:i−1]T[1:i-1]T[1:i−1] 时的状态为 ppp，已经匹配的长度为 lll，如果存在 T[i]T[i]T[i] 的转移，那么只要转移并让 lll 加一即可。否则 ppp 跳到 link⁡(p)\\operatorname{link}(p)link(p) 继续尝试匹配。 总复杂度 O(∣S∣+∣T∣)O(|S|+|T|)O(∣S∣+∣T∣)。 例题：SPOJ Longest Common Substring ","link":"http://xyf007.ml/post/mu-ban-hou-zhui-zi-dong-ji-sam/"},{"title":"【模板】拉格朗日插值","content":"f(k)=∑i=0nyi∏i≠jk−xjxi−xjf(k)=\\sum_{i=0}^ny_i\\prod_{i \\neq j}\\dfrac{k-x_j}{x_i-x_j} f(k)=i=0∑n​yi​i​=j∏​xi​−xj​k−xj​​ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const long long MOD = 998244353; long long n, k, x[2001], y[2001]; long long ksm(long long a, long long b) { long long s = 1; while (b) { if (b &amp; 1) { s = s * a % MOD; } a = a * a % MOD; b &gt;&gt;= 1; } return s; } int main(int argc, char const *argv[]) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } long long ans = 0; for (int i = 1; i &lt;= n; i++) { long long tmp = 1; for (int j = 1; j &lt;= n; j++) { if (i == j) { continue; } tmp = tmp * (k - x[j]) % MOD * ksm(x[i] - x[j], MOD - 2) % MOD; } ans = (ans + y[i] * tmp % MOD) % MOD; } printf(&quot;%lld&quot;, (ans + MOD) % MOD); return 0; } ","link":"http://xyf007.ml/post/mu-ban-la-ge-lang-ri-cha-zhi/"},{"title":"【7-17浙大ACM集训】总结","content":"比赛(补题)链接 比赛过程 wh 写了 A，我写了 B，然后 D 和 F 都假了。。。 题解 A 题意 给定长度为 nnn 的正整数数列 {an}\\{a_n\\}{an​}，每次可执行以下两个操作之一： 将某个数翻倍，即对于某个 iii，令 ai=2aia_i=2a_iai​=2ai​； 将所有数减一，即对于所有 iii，令 ai=ai−1a_i=a_i-1ai​=ai​−1。 求使数列全部变为零所需要的最少操作次数。 数据规模：1≤T≤105,1≤n≤1051 \\leq T \\leq 10^5,1 \\leq n \\leq 10^51≤T≤105,1≤n≤105。 分析 注意到本题有以下两个性质。 第二个操作次数至少为 max⁡{ai}\\max\\{a_i\\}max{ai​}。 所有数必须同时减到零。 易知进行减一后再加倍不会优于先加倍再减一，所以思路就是找到序列最大值，在没进行任何一次“减一”操作时，每个数不断翻倍，尽可能向最大值靠近。 通过翻倍恰好等于最大值的数自然不用再处理；如果无法恰好等于最大值，那么它一定会在若干次减一后恰好等于最大值的一半，此时再翻倍即可。 时间复杂度 O(nlog⁡max⁡{ai})O(n \\log \\max\\{a_i\\})O(nlogmax{ai​}) 注意事项 WA 了很多次后要想想是不是思路错了。 当前元素等于最大值时候就不要加倍了，所以while里面写&lt;而不是&lt;=。 用 O(nlog⁡n)O(n \\log n)O(nlogn) 做法时需要注意向上取整（好像没人这么写）。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; typedef long long ll; typedef unsigned un; typedef std::string str; typedef std::pair&lt;ll,ll&gt; pll; ll read(){ll x=0,f=1;char c=getchar();while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();}return f*x;} ll max(ll a,ll b){return a&gt;b?a:b;} ll min(ll a,ll b){return a&lt;b?a:b;} void umax(ll&amp; a,ll t){if(t&gt;a)a=t;} bool umin(ll&amp; a,ll t){if(t&lt;a)return a=t,1;return 0;} const ll INF=1ll&lt;&lt;58; #define MAXN 1000011 ll a[MAXN]; std::vector&lt;ll&gt;b; int main() { ll maxv=0,n=read(),ans=0; for(ll i=1;i&lt;=n;++i)a[i]=read(),umax(maxv,a[i]); for(ll i=1;i&lt;=n;++i) { while((a[i]&lt;&lt;1)&lt;=maxv)a[i]&lt;&lt;=1,++ans; if(a[i]&lt;maxv)b.push_back(a[i]); } std::sort(b.begin(),b.end()); ll delta=0; while(b.size()) { ans+=(b.back()- maxv+b.back()-delta)+1; delta=b.back()- maxv+b.back(); b.pop_back(); } printf(&quot;%lld&quot;,ans+(maxv-delta)); return 0; } B 题意 平面上 nnn 个点，连不在中间相交的线段使得三角形数最多 分析 令凸包上的点数为 kkk，显然，ans=k−2+(n−k)×3=3×n−2×k−2ans=k-2+(n-k)\\times 3=3\\times n-2\\times k-2ans=k−2+(n−k)×3=3×n−2×k−2 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { double x, y; bool operator&lt;(const node a) const { if (x == a.x) { return y &lt; a.y; } return x &lt; a.x; } } a[100001]; int n, st[100001], top; double get_slope(node a, node b) { if (a.x == b.x) { return 1e18; } return (b.y - a.y) / (b.x - a.x); } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lf%lf&quot;, &amp;a[i].x, &amp;a[i].y); } sort(a + 1, a + n + 1); int ans = 0; st[++top] = 1; st[++top] = 2; for (int i = 3; i &lt;= n; i++) { while (top &gt;= 2 &amp;&amp; get_slope(a[st[top - 1]], a[st[top]]) &lt; get_slope(a[st[top]], a[i])) { top--; } st[++top] = i; } ans = top; memset(st, 0, sizeof(st)); top = 0; st[++top] = n; st[++top] = n - 1; for (int i = n - 2; i &gt;= 1; i--) { while (top &gt;= 2 &amp;&amp; get_slope(a[st[top - 1]], a[st[top]]) &lt; get_slope(a[st[top]], a[i])) { top--; } st[++top] = i; } ans += top - 2; printf(&quot;%d&quot;, 3 * n - 2 * ans - 2); return 0; } C 题面 本质是求每个点与距离该点 wiw_iwi​ 近的监视器间的距离 分析 注意到 wiw_iwi​ 只有20 每个点只取第 wiw_iwi​ 小的距离作为判断依据，因此只需要存储前 max⁡{wi}\\max\\{w_i\\}max{wi​} 小的值 考虑把 kkk 个 dijkstra 压到一起跑，将每个点的 dis 数组加厚到 max⁡{wi}\\max\\{w_i\\}max{wi​} 层即可 最后将询问排序，二分一下即可 注意更新 dis 答案时记录下当前的源，避免某个点被同一个监视器反复横跳多次更新，从而保证 dis 数组的 wiw_iwi​ 层的源各不相同。 时间复杂度 O(k2(n+m)log⁡(n+m)+nlog⁡t)O(k^2(n+m)\\log(n+m)+n\\log t)O(k2(n+m)log(n+m)+nlogt)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;set&gt; using namespace std; struct edge { int to, nxt, cost; edge(int to = 0, int nxt = -1, int cost = 0) : to(to), nxt(nxt), cost(cost) {} } e[2000001]; struct node { int from, now; long long d; bool operator&lt;(const node x) const { return d &gt; x.d; } }; int n, m, k, t, maxw, E, head[500001], w[500001], c[500001], id[21][500001]; long long dis[21][500001], r[500001]; set&lt;int&gt; vis[500001]; void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } void dijkstra() { memset(dis, 0x3f, sizeof(dis)); priority_queue&lt;node&gt; q; for (int i = 1; i &lt;= k; i++) { q.push((node){c[i], c[i], 0}); dis[1][c[i]] = 0; id[1][c[i]] = c[i]; } while (!q.empty()) { node tmp = q.top(); q.pop(); int f = tmp.from, u = tmp.now; if (vis[u].count(f) || tmp.d &gt; dis[maxw][u]) { continue; } vis[u].insert(f); for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v].count(f)) { continue; } bool f0 = 1; for (int j = 1; j &lt;= maxw; j++) { if (id[j][v] == f) { if (dis[j][v] &gt; tmp.d + e[i].cost) { for (int l = j; l &lt; maxw; l++) { dis[l][v] = dis[l + 1][v]; id[l][v] = id[l + 1][v]; } dis[maxw][v] = 0x3f3f3f3f3f3f3f3f; id[maxw][v] = 0; } else { f0 = 0; } break; } } if (!f0) { continue; } for (int j = 1; j &lt;= maxw; j++) { if (tmp.d + e[i].cost &lt; dis[j][v]) { for (int l = maxw; l &gt; j; l--) { dis[l][v] = dis[l - 1][v]; id[l][v] = id[l - 1][v]; } dis[j][v] = tmp.d + e[i].cost; id[j][v] = f; q.push((node){f, v, tmp.d + e[i].cost}); break; } } } } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); add(u, v, c); add(v, u, c); } scanf(&quot;%d&quot;, &amp;k); for (int i = 1; i &lt;= k; i++) { scanf(&quot;%d&quot;, &amp;c[i]); } for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;w[i]); checkmax(maxw, w[i]); } maxw=20; dijkstra(); scanf(&quot;%d&quot;, &amp;t); for (int i = 1; i &lt;= t; i++) { scanf(&quot;%lld&quot;, &amp;r[i]); } sort(r + 1, r + t + 1); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, lower_bound(r + 1, r + t + 1, dis[w[i]][i]) - r - 1); } return 0; } D 题面 分析 我们考虑对于某个球袋 kkk 求答案，那么我们可以枚举斜率(n,mn,mn,m 此时默认减一，直着打出去的特殊计算)，那么答案可以写成 ∑i=1n∑j=1m[gcd⁡(i,j)=1]fk(i,j)\\textstyle\\sum_{i=1}^n\\textstyle\\sum_{j=1}^m\\left[\\gcd(i,j)=1\\right]f_k(i,j)∑i=1n​∑j=1m​[gcd(i,j)=1]fk​(i,j)，其中 fk(i,j)f_k(i,j)fk​(i,j) 代表以斜率 (i,j)(i,j)(i,j) 打出去是否能落入袋中，根据反射的原理，做对称就可以知道，我们找到最小的一组 p,qp,qp,q 满足 pnqm=ij\\dfrac{pn}{qm}=\\dfrac{i}{j}qmpn​=ji​，即 p=migcd⁡(nj,mi),q=njgcd⁡(nj,mi)p=\\dfrac{mi}{\\gcd(nj,mi)},q=\\dfrac{nj}{\\gcd(nj,mi)}p=gcd(nj,mi)mi​,q=gcd(nj,mi)nj​，那么 fk(i,j)f_k(i,j)fk​(i,j) 只和 p,qp,qp,q 的奇偶性有关，记作 g(p,q)g(p,q)g(p,q)。 原式莫比乌斯反演，然后就变成了 ∑d=1nμ(d)∑i=1⌊nd⌋∑j=1⌊md⌋g(p,q)\\textstyle\\sum_{d=1}^n\\mu(d)\\textstyle\\sum_{i=1}^{\\left\\lfloor\\frac{n}{d}\\right\\rfloor}\\textstyle\\sum_{j=1}^{\\left\\lfloor\\frac{m}{d}\\right\\rfloor}g(p,q)∑d=1n​μ(d)∑i=1⌊dn​⌋​∑j=1⌊dm​⌋​g(p,q)，这里 p,qp,qp,q 不变，是因为 p(i,j)=p(di,dj)=,q(i,j)=q(di,dj)p(i,j)=p(di,dj)=,q(i,j)=q(di,dj)p(i,j)=p(di,dj)=,q(i,j)=q(di,dj)，而 p,qp,qp,q 奇偶性之间的关系，显然和 nj,minj,minj,mi 因子 2 的幂次有关，不妨设 s(x)=max⁡{w,2w∣x}s(x)=\\max\\{w,2^w|x\\}s(x)=max{w,2w∣x}，那么我们求出 i≤⌊nd⌋,j≤⌊md⌋i \\leq\\left\\lfloor\\frac{n}{d}\\right\\rfloor,j \\leq\\left\\lfloor\\frac{m}{d}\\right\\rfloori≤⌊dn​⌋,j≤⌊dm​⌋ 的所有 s(i),s(j)=1,2,…,log⁡ns(i),s(j)=1,2,\\ldots,\\log ns(i),s(j)=1,2,…,logn 的个数，就可以快速计算了。 用杜教筛加这部分就可以做到复杂度 O(n23+nlog⁡n)O(n^{\\frac{2}{3}}+\\sqrt{n}\\log n)O(n32​+n​logn) #include &lt;algorithm&gt; #include &lt;cassert&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #define m_p make_pair #define sz(x) (int)x.size() #define out(x) cerr&lt;&lt;#x&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;&quot; &quot; #define outln(x) cerr&lt;&lt;#x&lt;&lt;&quot; = &quot;&lt;&lt;x&lt;&lt;endl #define outarr(x,l,r) cerr&lt;&lt;#x&quot;[&quot;&lt;&lt;l&lt;&lt;&quot;-&quot;&lt;&lt;r&lt;&lt;&quot;] = &quot;; for (int _i=l;_i&lt;=r;++_i) cerr&lt;&lt;x[_i]&lt;&lt;&quot; &quot;;cerr&lt;&lt;endl; using namespace std; #define int long long typedef long long ll; typedef pair&lt;int,int&gt; pii; #define gc() getchar() //char buf[1&lt;&lt;23],*p1=buf,*p2=buf; //#define gc() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++) template &lt;class T&gt; void read(T &amp;x) { x=0; char c=gc(); int flag=0; while (c&lt;'0'||c&gt;'9') flag|=(c=='-'),c=gc(); while (c&gt;='0'&amp;&amp;c&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc(); if (flag) x=-x; } template &lt;class T&gt; T _max(T a,T b){return a&gt;b ? a : b;} template &lt;class T&gt; T _min(T a,T b){return a&lt;b ? a : b;} template &lt;class T&gt; bool checkmax(T &amp;a,T b){return b&gt;a ? a=b,1 : 0;} template &lt;class T&gt; bool checkmin(T &amp;a,T b){return b&lt;a ? a=b,1 : 0;} const int mod=998244353,inv2=(mod+1)/2; //int Add(int a,int b){a+=b; return a&gt;=mod ? a-mod : a;} //int Sub(int a,int b){a-=b; return a&gt;=0 ? a : a+mod;} int Add(int a,int b){a=(a%mod+mod)%mod,b=(b%mod+mod)%mod; a+=b; return a&gt;=mod ? a-mod : a;} int Sub(int a,int b){a=(a%mod+mod)%mod,b=(b%mod+mod)%mod; a-=b; return a&gt;=0 ? a : a+mod;} int Mul(int a,int b){return 1LL*a*b%mod;} void add(int &amp;a,int b){a=Add(a,b);} void sub(int &amp;a,int b){a=Sub(a,b);} void mul(int &amp;a,int b){a=Mul(a,b);} int qpow(int a,int b) { int ans=1; while (b) { if (b&amp;1) mul(ans,a); mul(a,a); b&gt;&gt;=1; } return ans; } const int N=3000000; ll n,m; int nn,mm; bool flag[N+5]; int prime[N+5],tot=0; int mu[N+5],musum[N+5]; unordered_map&lt;ll,int&gt; ans_mu; void pre_calc() { mu[1]=1; for (int i=2;i&lt;=N;++i) { if (!flag[i]) { prime[++tot]=i; mu[i]=mod-1; } for (int j=1,lim=N/i;j&lt;=tot&amp;&amp;prime[j]&lt;=lim;++j) { flag[i*prime[j]]=1; if (i%prime[j]==0) { mu[i*prime[j]]=0; break; } else { mu[i*prime[j]]=Sub(0,mu[i]); } } } musum[0]=0; for (int i=1;i&lt;=N;++i) { musum[i]=Add(musum[i-1],mu[i]); } } int calc(ll x) { int cnt=0; while (x%2==0) { x/=2; ++cnt; } return cnt; } void init() { read(n); read(m); --n; --m; pre_calc(); nn=calc(n); mm=calc(m); } int sum_mu(ll x) { if (x&lt;=N) return musum[x]; if (ans_mu[x]) return ans_mu[x]; int tmp=1; for (ll l=2,r;l&lt;=x;l=r+1) { r=x/(x/l); sub(tmp,Mul((r-l+1)%mod,sum_mu(x/l))); } tmp%=mod; return ans_mu[x]=tmp; } int mark(ll lim,int x) { ll tmp=(1LL&lt;&lt;x); return ((lim/tmp+1LL)/2)%mod; } const int LOG=34,M=400005; int pre[M][LOG+1],O[M],L[M]; void solve() { int A=0,B=1,C=1,D=0,cnt=0; for (ll l=1,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+1) { r=_min(n/(n/l),m/(m/l)); ++cnt; L[cnt]=l; O[cnt]=Sub(sum_mu(r),sum_mu(l-1)); for (int q=0;q&lt;=LOG;++q) { int now=mark(m/l,q); if (q) pre[cnt][q]=pre[cnt][q-1]; add(pre[cnt][q],now); } } for (int q=0;q&lt;=LOG;++q) { int s=q+mm-nn; for (int i=1;i&lt;=cnt;++i) { int now=Mul(O[i],mark(n/L[i],q)); if (0&lt;=s&amp;&amp;s&lt;=LOG) { add(D,Mul(now,mark(m/L[i],s))); } if (s&gt;=1) { add(C,Mul(now,pre[i][_min(s-1,LOG)])); } if (s&lt;LOG) { int tmp=_max(0LL,s+1); if (tmp) add(B,Mul(now,Sub(pre[i][LOG],pre[i][tmp-1]))); else add(B,Mul(now,pre[i][LOG])); } } } cout&lt;&lt;A&lt;&lt;endl&lt;&lt;B&lt;&lt;endl&lt;&lt;C&lt;&lt;endl&lt;&lt;D&lt;&lt;endl; } #undef int int main() { //freopen(&quot;data.in&quot;,&quot;r&quot;,stdin); init(); solve(); return 0; } E 题意 对于约束 ∑i=1naixi≤P≤∑i=1nbixi(xi∈{0,1})\\textstyle\\sum_{i=1}^na_ix_i \\leq P \\leq \\textstyle\\sum_{i=1}^nb_ix_i(x_i\\in\\{0,1\\})∑i=1n​ai​xi​≤P≤∑i=1n​bi​xi​(xi​∈{0,1})，寻找一组 xix_ixi​ 使得 ∑i=1ncixi\\textstyle\\sum_{i=1}^nc_ix_i∑i=1n​ci​xi​ 取到最小值。 分析 考虑 dp(i,k)dp(i,k)dp(i,k) 表示前 iii 个已确定选择，且 ∑j&lt;iajxj≤k≤∑j&lt;ibjxj\\textstyle\\sum_{j&lt;i}a_jx_j \\leq k \\leq \\textstyle\\sum_{j&lt;i}b_jx_j∑j&lt;i​aj​xj​≤k≤∑j&lt;i​bj​xj​ 时，答案的最小值。 那么转移就是 dp(i,k)=min⁡(dp(i−1,k),min⁡k−bi≤j≤k−ai{dp(i−1,j)+ci})dp(i,k)=\\min(dp(i-1,k),\\min\\limits_{k-b_i \\leq j \\leq k-a_i}\\{dp(i-1,j)+c_i\\})dp(i,k)=min(dp(i−1,k),k−bi​≤j≤k−ai​min​{dp(i−1,j)+ci​})。 后一项是定长区间的最小值，可以用单调队列来求。 由于 [L−ai,R−bi][L-a_i,R-b_i][L−ai​,R−bi​] 上的每个 dpi−1dp_{i-1}dpi−1​ 都可以转移到 [L,R][L,R][L,R] 上的 dpidp_idpi​，因此这个转移是正确的。 时间复杂度为 O(nP)O(nP)O(nP)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;deque&gt; using namespace std; int t, n, p, a[1001], b[1001], c[1001], dp[1001][10001]; deque&lt;int&gt; q; void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;p); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;b[i]); } for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;c[i]); } memset(dp, 0x3f, sizeof(dp)); dp[0][0] = 0; for (int i = 1; i &lt;= n; i++) { q.clear(); int r = 0; for (int j = 0; j &lt;= p; j++) { dp[i][j] = dp[i - 1][j]; while (r &lt;= min(j - a[i], p)) { if (dp[i - 1][r] != 0x3f3f3f3f) { while (!q.empty() &amp;&amp; dp[i - 1][r] &lt;= dp[i - 1][q.back()]) { q.pop_back(); } q.push_back(r); } r++; } while (!q.empty() &amp;&amp; q.front() &lt; j - b[i]) { q.pop_front(); } if (!q.empty()) { checkmin(dp[i][j], dp[i - 1][q.front()] + c[i]); } } } if (dp[n][p] == 0x3f3f3f3f) { printf(&quot;-1\\n&quot;); } else { printf(&quot;%d\\n&quot;, dp[n][p]); } } return 0; } F 题意 给串 AAA 和若干个串 BiB_iBi​，问是否能将这些 BiB_iBi​拼成一个串 SSS 使得把 SSS 和 AAA 无限复制后两个串一样。 分析 先找到 AAA 的最小循环节，这部分可以用 hash / kmp / 直接暴力，设最小循环节长度为 ddd。 然后可以建一个 ddd 个点的图，每个点代表串的一个前缀，每个串 BiB_iBi​ 就可以变成图上的一条长度为 1 的边。 比如，最小循环节为 aabca\\texttt{aabca}aabca，那么对于串 Bi=caaB_i=\\texttt{caa}Bi​=caa，他可以变成 aab\\texttt{aab}aab 到 a\\texttt{a}a 的一条边。 问题就变成了求这个图上的最小环。 建边部分可以使用 hash / kmp / trie树。 跑个 Floyd 即可。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int base = 499; int n, m, len, t, dis[501][501]; unsigned long long hasha[1001], hashb[501], fac[501]; char a[1001], b[501]; void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } void init() { fac[0] = 1; for (int i = 1; i &lt;= 500; i++) { fac[i] = fac[i - 1] * base; } } unsigned long long get(int l, int r) { return hasha[r] - fac[r - l + 1] * hasha[l - 1]; } int main(int argc, char const *argv[]) { init(); scanf(&quot;%s%d&quot;, a + 1, &amp;m); n = strlen(a + 1); for (int i = 1; i &lt;= n; i++) { hasha[i] = hasha[i - 1] * base + a[i]; } len = 1; while (len &lt;= n) { if (n % len) { len++; continue; } bool f = 1; for (int i = 1; i + 2 * len - 1 &lt;= n; i += len) { if (get(i, i + len - 1) != get(i + len, i + 2 * len - 1)) { f = 0; break; } } if (f) { break; } len++; } if (len == n) { for (int i = 1; i &lt;= n; i++) { a[i + n] = a[i]; } for (int i = n + 1; i &lt;= 2 * n; i++) { hasha[i] = hasha[i - 1] * base + a[i]; } n &lt;&lt;= 1; } memset(dis, 0x3f, sizeof(dis)); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, b + 1); t = strlen(b + 1); for (int j = 1; j &lt;= t; j++) { hashb[j] = hashb[j - 1] * base + b[j]; } for (int i = 1; i &lt;= len; i++) { if (get(i, i + t - 1) == hashb[t]) { dis[i][(i + t) % len ? (i + t) % len : len] = 1; } } } for (int k = 1; k &lt;= len; k++) { for (int i = 1; i &lt;= len; i++) { for (int j = 1; j &lt;= len; j++) { checkmin(dis[i][j], dis[i][k] + dis[k][j]); } } } int ans = 0x3f3f3f3f; for (int i = 1; i &lt;= len; i++) { checkmin(ans, dis[i][i]); } if (ans == 0x3f3f3f3f) { printf(&quot;-1&quot;); } else { printf(&quot;%d&quot;, ans); } return 0; } ","link":"http://xyf007.ml/post/7-17-zhe-da-acm-ji-xun-zong-jie/"},{"title":"【7-15浙大ACM集训】总结","content":"比赛(补题)链接 比赛过程 A 题是原题，5min 贺完是 rank1，然后感觉 D，E 可做，结果 hcy 搞了 3h 也没成功，后来发现是复杂度假了，wh E 题也没调出来 题解 A 题面 hdu 原题，最小生成树和最大生成树之间有没有斐波那契数即可 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int father[100005], n, m, t, sum, cases; long long a[101]; struct edge { int from, to, cost; bool operator&lt;(const edge x) const { return this-&gt;cost &lt; x.cost; } } E[2000005]; inline int find(int x) { if (father[x] == x) return x; return father[x] = find(father[x]); } inline void merge(int x, int y) { x = find(x); y = find(y); father[y] = x; } inline bool judge(int x, int y) { if (find(x) == find(y)) return 1; else return 0; } inline void init() { for (int i = 1; i &lt;= n; i++) father[i] = i; sum = 0; } int main() { a[1] = 1; a[2] = 2; for (int i = 3; i &lt;= 90; i++) a[i] = a[i - 1] + a[i - 2]; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); memset(E, 0, sizeof(E)); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;E[i].from, &amp;E[i].to, &amp;E[i].cost); sort(E + 1, E + m + 1); int cnt = 0; for (int i = 1; i &lt;= m; i++) if (!judge(E[i].from, E[i].to)) { sum += E[i].cost; merge(E[i].from, E[i].to); cnt++; } if (cnt != n - 1) { printf(&quot;No\\n&quot;); return 0; } int temp = sum; init(); for (int i = m; i &gt;= 1; i--) if (!judge(E[i].from, E[i].to)) { sum += E[i].cost; merge(E[i].from, E[i].to); } for (int i = 1; i &lt;= 90; i++) if (a[i] &gt;= temp &amp;&amp; a[i] &lt;= sum) { printf(&quot;Yes\\n&quot;); return 0; } printf(&quot;No\\n&quot;); return 0; } B 题意 给定一个长度为 10510^5105、字符集为大写字母的字符串 SSS。 小 Z 和小 Y 玩游戏，轮流操作，小 Z 先手，谁无法操作谁输。 每个回合，都有一个由 SSS 的若干个子序列构成的集合 TTT。最初，TTT 中仅含一个空字符串。 每个回合内的操作规则：操作方要选择一个 TTT 中的字符串 sss，将 sss 从 TTT 中删除，并将至少一个形如 s+cs+cs+c、且 s+cs+cs+c 仍然为 TTT 的子序列的字符串加入中。 分析 先构建子序列自动机，以 S=ABAABS=\\texttt{ABAAB}S=ABAAB 为例： 规则：最初，空白点有一个石子。每一回合，操作一方可以选择一个石子，将其移除，并在其后继中放至少一个石子。 记 sg(i)sg(i)sg(i) 表示最初点 iii 上放一个石子的局面的 SG 值，答案即为 sg(0)sg(0)sg(0)。 sg(x)=mex⁡T⊂succ(x)(⊗k∈Tsg(x))sg(x)=\\operatorname{mex}_{T \\subset succ(x)}(\\otimes_{k \\in T} sg(x)) sg(x)=mexT⊂succ(x)​(⊗k∈T​sg(x)) 容易发现 SG 值只可能是 0,20,21,22,…0,2^0,2^1,2^2,\\ldots0,20,21,22,…。 按拓扑序逆序归纳： 对没有后继的点，sg=0sg=0sg=0 对点 xxx，其后继的 sgsgsg 值若没有 000，其 SG 值为 000，否则假设 20,21,…,2i2^0,2^1,\\ldots,2^i20,21,…,2i 都存在，2i+12^{i+1}2i+1 不存在，那么 2i+12^{i+1}2i+1 是它不能通过子集异或得到的最小的数，所以 sg=2i+1sg=2^{i+1}sg=2i+1 将其重标号为 0,1,2,3,…0,1,2,3,\\ldots0,1,2,3,…，再来考虑上述求 SG 的方法，每次相当于对所有后继的重标号取 mex，并特殊考虑有两个数 mex 值相同的情况。 鸽了 C 题意 从 nnn 个数中选取最多 mmm 个不相交的子段，将其中所有数 ×x\\times x×x 后求新数组的最大子段和 分析 考虑最终选取的子段，一定是这样的形式： 其中红色表示被改变的数。 那么我们可以将这些数分组，每一组包含两部分：被改变的和未改变的，注意第0组只有未改变的。 令 dp(i,j,0/1)dp(i,j,0/1)dp(i,j,0/1) 表示前 iii 个中有 jjj 段 ×x\\times x×x，第 iii 个是否选择的最大子段和，则 dp(i,j,0)=max⁡(max⁡(dp(i−1,j,0),dp(i−1,j,1),0)+a[i];dp(i,j,0)=\\max(\\max(dp(i-1,j,0),dp(i-1,j,1),0)+a[i]; dp(i,j,0)=max(max(dp(i−1,j,0),dp(i−1,j,1),0)+a[i]; dp(i,j,1)=max⁡(max⁡(dp(i−1,j−1,0),dp(i−1,j,1),0)+a[i]×x;dp(i,j,1)=\\max(\\max(dp(i-1,j-1,0),dp(i-1,j,1),0)+a[i] \\times x; dp(i,j,1)=max(max(dp(i−1,j−1,0),dp(i−1,j,1),0)+a[i]×x; #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, x, a[300001]; long long dp[300001][31][2]; void checkmax(long long &amp;x, long long y) { if (x &lt; y) { x = y; } } int main(int argc, char const *argv[]) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;x); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } memset(dp, 0xcf, sizeof(dp)); long long ans = 0xcfcfcfcfcfcfcfcf; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { dp[i][j][0] = max(max(dp[i - 1][j][0], dp[i - 1][j][1]), 0LL) + a[i]; checkmax(ans, dp[i][j][0]); if (j) { dp[i][j][1] = max(max(dp[i - 1][j - 1][0], dp[i - 1][j][1]), 0LL) + a[i] * x; checkmax(ans, dp[i][j][1]); } } } printf(&quot;%lld&quot;, ans); return 0; } D 题意 求 ∑i=1n∑j=1nφ(gcd⁡(i,j))\\sum_{i=1}^n\\sum_{j=1}^n\\varphi(\\gcd(i,j))∑i=1n​∑j=1n​φ(gcd(i,j)) 分析 整除分块+杜教筛板子题然而我不会 ∑i=1n∑j=1nφ(gcd⁡(i,j))=∑p=1nφ(p)∑i=1n∑j=1n[gcd⁡(i,j)==p]=∑p=1nφ(p)(2∑i=1⌊np⌋φ(i)−1)=∑p=1nφ(p)(2S(⌊np⌋)−1)\\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^n\\varphi(\\gcd(i,j)) &amp;= \\sum_{p=1}^n\\varphi(p)\\sum_{i=1}^n\\sum_{j=1}^n\\left[\\gcd(i,j)==p\\right]\\\\ &amp;= \\sum_{p=1}^n\\varphi(p)\\left(2\\sum_{i=1}^{\\left\\lfloor\\frac{n}{p}\\right\\rfloor}\\varphi(i)-1\\right)\\\\ &amp;= \\sum_{p=1}^n\\varphi(p)\\left(2S\\left(\\left\\lfloor\\dfrac{n}{p}\\right\\rfloor\\right)-1\\right) \\end{aligned} i=1∑n​j=1∑n​φ(gcd(i,j))​=p=1∑n​φ(p)i=1∑n​j=1∑n​[gcd(i,j)==p]=p=1∑n​φ(p)⎝⎜⎛​2i=1∑⌊pn​⌋​φ(i)−1⎠⎟⎞​=p=1∑n​φ(p)(2S(⌊pn​⌋)−1)​ 鸽了 E 题意 设 f(i)f(i)f(i) 为以 iii 为根的树上逆序对之和，求 ∑f(i)\\sum f(i)∑f(i) 分析 首先考虑求 f(i)f(i)f(i)，对于每个点 iii，对 1 的贡献是其子树内权值小于它的点的个数，加起来即可。 采用 DFS 统计答案，从 iii 转移到 jjj 时，f(j)=f(i)−lf+lsf(j)=f(i)-lf+lsf(j)=f(i)−lf+ls，其中 lflflf 为以 jjj 为根的子树内权值小于 aia_iai​ 的点数，lslsls 为除了以 jjj 为根的子树外权值小于 aja_jaj​ 的点数。 在 DFS 序上对所有点权建立可持久化线段树。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int ls, rs, sum; } t[10000001]; struct edge { int to, nxt; edge(int to = 0, int nxt = -1) : to(to), nxt(nxt) {} } e[600001]; int n, a[300001], b[300001], c[300001], E, head[300001], tot, root[300001], dfn[300001], cnt, sz[300001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void pushup(int x) { t[x].sum = t[t[x].ls].sum + t[t[x].rs].sum; } int modify(int x, int l, int r, int p, int val) { int xx = ++tot; t[xx] = t[x]; if (l == r) { t[xx].sum += val; return xx; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { t[xx].ls = modify(t[x].ls, l, mid, p, val); } else { t[xx].rs = modify(t[x].rs, mid + 1, r, p, val); } pushup(xx); return xx; } int query(int l, int r, int p, int x1, int x2) { if (!p) { return 0; } if (l == r) { return t[x2].sum - t[x1].sum; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { return query(l, mid, p, t[x1].ls, t[x2].ls); } else { return t[t[x2].ls].sum - t[t[x1].ls].sum + query(mid + 1, r, p, t[x1].rs, t[x2].rs); } } void dfs(int u, int fa) { dfn[u] = ++cnt; b[cnt] = a[u]; sz[u] = 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } dfs(v, u); sz[u] += sz[v]; } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); c[i] = a[i]; } sort(c + 1, c + n + 1); int nn = unique(c + 1, c + n + 1) - c - 1; for (int i = 1; i &lt;= n; i++) { a[i] = lower_bound(c + 1, c + nn + 1, a[i]) - c; } for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); add(v, u); } dfs(1, 0); for (int i = 1; i &lt;= n; i++) { root[i] = modify(root[i - 1], 1, nn, b[i], 1); } long long ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = head[i]; j != -1; j = e[j].nxt) { int v = e[j].to; if (dfn[v] &lt; dfn[i]) { ans += 1LL * (query(1, nn, a[i] - 1, 0, root[dfn[i] - 1]) + query(1, nn, a[i] - 1, root[dfn[i] + sz[i] - 1], root[n])) * sz[i]; } else { ans += 1LL * query(1, nn, a[i] - 1, root[dfn[v] - 1], root[dfn[v] + sz[v] - 1]) * (n - sz[v]); } } } printf(&quot;%lld&quot;, ans); return 0; } F 题面 考虑构造出这样的解：不仅满足题意，还满足左边一半的最大值&lt;&lt;&lt;右边一半的最小值。 假如我们要求解的长度为 nnn: 假设我们已经求出满足条件的长度为 ⌊n2⌋\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor⌊2n​⌋ 的数组 bbb 和长度为 n−⌊n2⌋n-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloorn−⌊2n​⌋ 的数组 ccc，将它们按这样的方式拼接： b⌊n2⌋,…,b1,cn−⌊n2⌋+⌊n2⌋,…,c1+⌊n2⌋b_{\\left\\lfloor\\frac{n}{2}\\right\\rfloor},\\ldots,b_1,c_{n-\\left\\lfloor\\frac{n}{2}\\right\\rfloor}+\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor,\\ldots,c_1+\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor b⌊2n​⌋​,…,b1​,cn−⌊2n​⌋​+⌊2n​⌋,…,c1​+⌊2n​⌋ 就得到了长度为 nnn 的解。（如果把它看成四部分，ccc 的左边 &gt;c&gt;c&gt;c 的右边 &gt;b&gt;b&gt;b 的左边 &gt;b&gt;b&gt;b 的右边）所以任意跨过中间的限制一定能被满足。 类似 FFT 中的蝴蝶变换 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, a[50001], t1[50001], t2[50001]; void solve(int l, int r) { if (l == r) { return; } int len1 = 0, len2 = 0; for (int i = l; i &lt;= r; i++) { if ((i - l) &amp; 1) { t1[++len1] = a[i]; } else { t2[++len2] = a[i]; } } for (int i = 0; i &lt; len1; i++) { a[l + i] = t1[i + 1]; } for (int i = 0; i &lt; len2; i++) { a[l + len1 + i] = t2[i + 1]; } solve(l, l + len1 - 1); solve(l + len1, r); } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { a[i] = i; } solve(1, n); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, a[i]); } return 0; } ","link":"http://xyf007.ml/post/7-15-zhe-da-acm-ji-xun-zong-jie/"},{"title":"【7-14浙大ACM集训】总结","content":"比赛(补题)链接 低级错误😓 wh A 题2次交错文件 比赛过程 整场比赛只有 A、D 可做，hcy 开 C 题，结果假了。D 题题目看不懂1个小时，看懂后秒了。A 题开始只能想到倍增，后面用 wh 用 map 碾过去了，但是他交错代码，交了两发 A + B Problem。 题解 A 题面 注意到对任何一个数它的不同的 gcd 的数量都是 log⁡n\\log nlogn 级别的那么我们就可以用 map 或者数组进行一边读入一边处理数据（读入新数的时候，每次读入的复杂度是 log⁡2n\\log^2 nlog2n 级，共 nnn 次） #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;map&gt; typedef long long ll; typedef unsigned un; typedef std::string str; typedef std::pair&lt;ll,ll&gt; pll; ll read(){ll x=0,f=1;char c=getchar();while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();}return f*x;} ll max(ll a,ll b){return a&gt;b?a:b;} ll min(ll a,ll b){return a&lt;b?a:b;} void umax(ll&amp; a,ll t){if(t&gt;a)a=t;} const ll INF=1ll&lt;&lt;28; #define MAXN 4000011 ll n,a[MAXN]; std::map&lt;ll,ll&gt;pre,now,ans; ll gcd(ll a,ll b) { if(!b)return a; return gcd(b,a%b); } ll b[MAXN]; int main() { n=read(); for(ll i=1;i&lt;=n;++i) { now.clear(); a[i]=read(); std::map&lt;ll,ll&gt;::iterator it; for(it=pre.begin();it!=pre.end();++it)now[gcd(it-&gt;first,a[i])]+=it-&gt;second; ++now[a[i]]; for(it=now.begin();it!=now.end();++it)ans[it-&gt;first]+=it-&gt;second; std::swap(pre,now); } ll query=read(); for(ll i=1;i&lt;=query;++i)b[i]=read(); for(ll i=1;i&lt;=query;++i)printf(&quot;%lld\\n&quot;,ans[b[i]]); return 0; } B 题面 广义sam正确姿势 鸽了 C 鸽了 D 题目大意 n×nn \\times nn×n 棋盘上的 (n+1)2(n+1)^2(n+1)2 个点，从 (0,0)(0,0)(0,0) 出发的直线，恰好通过 mmm 个点的方案数。定义两个方案是不同的，当且仅当存在一个点属于方案 A 不属于方案 B。 即：求有多少符合条件的数对 (i,j)(i,j)(i,j)，满足 i,ji,ji,j 互质且 ⌊nmax⁡(i,j)⌋+1=m\\left\\lfloor\\dfrac{n}{\\max(i,j)}\\right\\rfloor+1=m⌊max(i,j)n​⌋+1=m。 分析 O(Tn)O(Tn)O(Tn) 枚举 t=max⁡(i,j)t=\\max(i,j)t=max(i,j)，当 ⌊nt⌋+1=m\\left\\lfloor\\dfrac{n}{t}\\right\\rfloor+1=m⌊tn​⌋+1=m 时，对答案的贡献为 2φ(t)2\\varphi(t)2φ(t)。 O(n+T)O(n+T)O(n+T) 对于每一个询问，符合条件的 ttt 落在一个区间 [l,r][l,r][l,r] 内。对 2φ(t)2\\varphi(t)2φ(t) 求前缀和 sumsumsum，答案为 sum[r]−sum[l−1]sum[r]-sum[l-1]sum[r]−sum[l−1]。 l=⌊nm⌋+1,r=⌊nm−1⌋l=\\left\\lfloor\\dfrac{n}{m}\\right\\rfloor+1,r=\\left\\lfloor\\dfrac{n}{m-1}\\right\\rfloor l=⌊mn​⌋+1,r=⌊m−1n​⌋ 细节：m=1m=1m=1 时，ans=1ans=1ans=1；m=n+1m=n+1m=n+1 时，ans=3ans=3ans=3。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long t, n, m; #define MAXM 5000011 bool vis[MAXM]; long long pri[MAXM], phi[MAXM], sum[MAXM]; void init() { int cnt = 0; for (int i = 2; i &lt; MAXM; ++i) { if (!vis[i]) { pri[++cnt] = i, phi[i] = i - 1; } for (int j = 1; j &lt;= cnt &amp;&amp; 1ll * i * pri[j] &lt; MAXM; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j]; break; } phi[i * pri[j]] = phi[i] * phi[pri[j]]; } } phi[1] = 1; for (int i = 1; i &lt; MAXM; i++) { sum[i] = sum[i - 1] + phi[i]; } } int main(int argc, const char *argv[]) { init(); scanf(&quot;%lld&quot;, &amp;t); while (t--) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (m == 1) { printf(&quot;1\\n&quot;); continue; } if (m == n + 1) { printf(&quot;3\\n&quot;); continue; } int r = n / (m - 1), l = n / m + 1; printf(&quot;%lld\\n&quot;, 2 * (sum[r] - sum[l - 1])); } return 0; } E 题面 很妙的视频1 很妙的视频2 O(Tnk)O(Tnk)O(Tnk) 做法：打表找规律，发现无论初值如何，经过多次迭代后都会收敛到一些吸引子上（下图横轴为 x0x_0x0​，分别为 μ=3.4\\mu=3.4μ=3.4 时迭代10000次与10001次的结果）。 容易发现每个吸引子对应的区间长度较长，所以可以选择小步长采样或随机采样模拟。 O(Tk)O(Tk)O(Tk) 做法：发现所给的 xnx_nxn​ 是吸引子，找出其变化的周期（下图横轴为 μ\\muμ，纵轴为吸引子的值）。 错误做法： 以为周期为2，按 nnn 的奇偶性处理 xnx_nxn​。 直接解 nnn 个二次方程。每个方程对应两个取值，如果随便选的话可能会收敛到0或者 nan。 细节：需要考虑 corner case 即 xn=0x_n=0xn​=0 的情形。 其他： 不要盲目调参，要思考思路是不是正确的。 这种数据较简单的题目可以本地生成一些数据跑跑看 #include &lt;bits/stdc++.h&gt; #define eps 1e-3 #define int long long using namespace std; int q,n,w; double u,x,ok[50000]; inline double fabs(double x){return((x&lt;0)?-x:x);} int ran(int l,int r) { return 1ll*rand()*rand()*rand()%(r-l+1)+l; } double get(double x) { w=0; for (int i=1;i&lt;=4000;i++) x=u*x*(1-x),ok[++w]=x; for (int len=2;len&lt;=4;len++) { if (fabs(ok[w-len]-ok[w])&lt;=eps) { for (int i=0;i&lt;len;i++) { if (n%len==(w+i)%len) return ok[w-len+i]; } } } return 0; } signed main() { srand(time(0)); scanf(&quot;%lld&quot;,&amp;q); while (q--) { scanf(&quot;%lld%lf%lf&quot;,&amp;n,&amp;u,&amp;x); if (x==0) { printf(&quot;0.00000\\n&quot;); continue; } for (int ti=1;ti&lt;=500;ti++) { double num=1.0*ran(1,999999999)/1000000000.0; if (fabs(get(num)-x)&lt;=eps) { printf(&quot;%.9lf\\n&quot;,num); break; } } } } F 大模拟 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int A, B, C, D, E; }; int t, a[10], b[10], c[10], a_to_choose[10], b_to_choose[10], cnt; bool vis[101]; int get_id(string s) { int t1, t2; switch (s[0]) { case 'S': t1 = 0; break; case 'H': t1 = 1; break; case 'D': t1 = 2; break; default: t1 = 3; break; } switch (s[1]) { case 'T': t2 = 10; break; case 'J': t2 = 11; break; case 'Q': t2 = 12; break; case 'K': t2 = 13; break; case 'A': t2 = 1; break; default: t2 = s[1] - '0'; break; } return 13 * t1 + t2; } int get_Hand(int a, int b, int c, int d, int e) { int C[5] = {(a - 1) / 13, (b - 1) / 13, (c - 1) / 13, (d - 1) / 13, (e - 1) / 13}, D[5] = {a % 13, b % 13, c % 13, d % 13, e % 13}; for (int i = 0; i &lt; 5; i++) { if (!D[i]) { D[i] = 13; } } sort(C, C + 5); sort(D, D + 5); if (C[0] == C[1] &amp;&amp; C[1] == C[2] &amp;&amp; C[2] == C[3] &amp;&amp; C[3] == C[4]) { if ((D[0] == 1 &amp;&amp; D[1] == 10 &amp;&amp; D[2] == 11 &amp;&amp; D[3] == 12 &amp;&amp; D[4] == 13)) { return 1; } else { if (D[0] == D[1] - 1 &amp;&amp; D[1] == D[2] - 1 &amp;&amp; D[2] == D[3] - 1 &amp;&amp; D[3] == D[4] - 1) { return 2; } else { return 5; } } } if ((D[1] == D[2] &amp;&amp; D[2] == D[3]) &amp;&amp; (D[0] == D[1] || D[3] == D[4])) { return 3; } if ((D[0] == D[1] &amp;&amp; D[3] == D[4]) &amp;&amp; (D[2] == D[1] || D[2] == D[3])) { return 4; } if ((D[0] == D[1] - 1 &amp;&amp; D[1] == D[2] - 1 &amp;&amp; D[2] == D[3] - 1 &amp;&amp; D[3] == D[4] - 1) || (D[0] == 1 &amp;&amp; D[1] == 10 &amp;&amp; D[2] == 11 &amp;&amp; D[3] == 12 &amp;&amp; D[4] == 13)) { return 6; } if ((D[0] == D[1] &amp;&amp; D[1] == D[2]) || (D[1] == D[2] &amp;&amp; D[2] == D[3]) || (D[2] == D[3] &amp;&amp; D[3] == D[4])) { return 7; } if ((D[0] == D[1] &amp;&amp; D[2] == D[3]) || (D[0] == D[1] &amp;&amp; D[3] == D[4]) || (D[1] == D[2] &amp;&amp; D[3] == D[4])) { return 8; } if (D[0] == D[1] || D[1] == D[2] || D[2] == D[3] || D[3] == D[4]) { return 9; } return 10; } bool compare(node a, node b, int type) { int A1, A11, A12, A2, A22, A3, A4, B1, B11, B12, B2, B22, B3, B4, t1[5] = {a.A % 13, a.B % 13, a.C % 13, a.D % 13, a.E % 13}, t2[5] = {b.A % 13, b.B % 13, b.C % 13, b.D % 13, b.E % 13}; for (int i = 0; i &lt; 5; i++) { if (!t1[i]) { t1[i] = 13; } if (!t2[i]) { t2[i] = 13; } } sort(t1, t1 + 5); sort(t2, t2 + 5); if ((type != 2 &amp;&amp; type != 6) || (type == 6 &amp;&amp; t1[1] == 10)) { for (int i = 0; i &lt; 5; i++) { if (t1[i] == 1) { t1[i] = 14; } } sort(t1, t1 + 5); } if ((type != 2 &amp;&amp; type != 6) || (type == 6 &amp;&amp; t2[1] == 10)) { for (int i = 0; i &lt; 5; i++) { if (t2[i] == 1) { t2[i] = 14; } } sort(t2, t2 + 5); } switch (type) { case 1: return 0; case 2: case 6: return t1[4] &gt; t2[4]; case 3: A1 = t1[0] == t1[1] ? t1[4] : t1[0]; A4 = t1[1]; B1 = t2[0] == t2[1] ? t2[4] : t2[0]; B4 = t2[1]; return A4 == B4 ? A1 &gt; B1 : A4 &gt; B4; case 4: A2 = t1[1] == t1[2] ? t1[3] : t1[0]; A3 = t1[2]; B2 = t2[1] == t2[2] ? t2[3] : t2[0]; B3 = t2[2]; return A3 == B3 ? A2 &gt; B2 : A3 &gt; B3; case 5: case 10: if (t1[4] == t2[4]) { if (t1[3] == t2[3]) { if (t1[2] == t2[2]) { if (t1[1] == t2[1]) { return t1[0] &gt; t2[0]; } return t1[1] &gt; t2[1]; } return t1[2] &gt; t2[2]; } return t1[3] &gt; t2[3]; } return t1[4] &gt; t2[4]; case 7: A1 = t1[3] == t1[4] ? t1[1] : t1[4]; A11 = t1[3] == t1[4] ? t1[0] : (t1[2] == t1[3] ? t1[0] : t1[3]); A3 = t1[2]; B1 = t2[3] == t2[4] ? t2[1] : t2[4]; B11 = t2[3] == t2[4] ? t2[0] : (t2[2] == t2[3] ? t2[0] : t2[3]); B3 = t2[2]; if (A3 == B3) { if (A1 == B1) { return A11 &gt; B11; } return A1 &gt; B1; } return A3 &gt; B3; case 8: if (t1[3] == t1[4]) { A2 = t1[3]; if (t1[1] == t1[2]) { A22 = t1[1]; A1 = t1[0]; } else { A22 = t1[0]; A1 = t1[2]; } } else { A2 = t1[2]; A22 = t1[0]; A1 = t1[4]; } if (t2[3] == t2[4]) { B2 = t2[3]; if (t2[1] == t2[2]) { B22 = t2[1]; B1 = t2[0]; } else { B22 = t2[0]; B1 = t2[2]; } } else { B2 = t2[2]; B22 = t2[0]; B1 = t2[4]; } if (A2 == B2) { if (A22 == B22) { return A1 &gt; B1; } return A22 &gt; B22; } return A2 &gt; B2; default: if (t1[0] == t1[1]) { A2 = t1[0]; A1 = t1[4]; A11 = t1[3]; A12 = t1[2]; } else { if (t1[1] == t1[2]) { A2 = t1[1]; A1 = t1[4]; A11 = t1[3]; A12 = t1[0]; } else { if (t1[2] == t1[3]) { A2 = t1[2]; A1 = t1[4]; A11 = t1[1]; A12 = t1[0]; } else { A2 = t1[3]; A1 = t1[2]; A11 = t1[1]; A12 = t1[0]; } } } if (t2[0] == t2[1]) { B1 = t2[4]; B2 = t2[0]; B11 = t2[3]; B12 = t2[2]; } else { if (t2[1] == t2[2]) { B2 = t2[1]; B1 = t2[4]; B11 = t2[3]; B12 = t2[0]; } else { if (t2[2] == t2[3]) { B2 = t2[2]; B1 = t2[4]; B11 = t2[1]; B12 = t2[0]; } else { B2 = t2[3]; B1 = t2[2]; B11 = t2[1]; B12 = t2[0]; } } } if (A2 == B2) { if (A1 == B1) { if (A11 == B11) { return A12 &gt; B12; } return A11 &gt; B11; } return A1 &gt; B1; } return A2 &gt; B2; } } void solve() { int mina = 11, minb = 11, d; node aa = {0, 0, 0, 0, 0}, bb = {0, 0, 0, 0, 0}; if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[2], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[1], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[1], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[1], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[0], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[0], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[0], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[0], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5])) &lt; mina) { mina = d; aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } else { if (d == mina) { if (compare((node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}, aa, d)) { aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5]}; } } } if ((d = get_Hand(a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[3], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[1], a_to_choose[2], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[1], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6])) &lt; mina) { mina = d; aa = (node){a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } else { if (d == mina) { if (compare((node){a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}, aa, d)) { aa = (node){a_to_choose[2], a_to_choose[3], a_to_choose[4], a_to_choose[5], a_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[2], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[1], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[1], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[1], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[0], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[0], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[0], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[0], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5])) &lt; minb) { minb = d; bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } else { if (d == minb) { if (compare((node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}, bb, d)) { bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5]}; } } } if ((d = get_Hand(b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[3], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[1], b_to_choose[2], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[1], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if ((d = get_Hand(b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6])) &lt; minb) { minb = d; bb = (node){b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } else { if (d == minb) { if (compare((node){b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}, bb, d)) { bb = (node){b_to_choose[2], b_to_choose[3], b_to_choose[4], b_to_choose[5], b_to_choose[6]}; } } } if (mina &lt; minb) { cnt++; } else { if (mina == minb &amp;&amp; compare(aa, bb, mina)) { cnt++; } } } int main(int argc, const char *argv[]) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t--) { cnt = 0; memset(vis, 0, sizeof(vis)); string s; for (int i = 0; i &lt; 2; i++) { cin &gt;&gt; s; a[i] = get_id(s); a_to_choose[i] = a[i]; vis[a[i]] = 1; } for (int i = 0; i &lt; 2; i++) { cin &gt;&gt; s; b[i] = get_id(s); b_to_choose[i] = b[i]; vis[b[i]] = 1; } for (int i = 0; i &lt; 3; i++) { cin &gt;&gt; s; c[i] = get_id(s); a_to_choose[i + 2] = b_to_choose[i + 2] = c[i]; vis[c[i]] = 1; } for (int i = 1; i &lt;= 52; i++) { if (!vis[i]) { vis[i] = 1; a_to_choose[5] = b_to_choose[5] = i; for (int j = i + 1; j &lt;= 52; j++) { if (!vis[j]) { vis[j] = 1; a_to_choose[6] = b_to_choose[6] = j; solve(); vis[j] = 0; } } vis[i] = 0; } } if (!cnt) { cout &lt;&lt; &quot;0/1&quot; &lt;&lt; endl; } else { int GCD = __gcd(cnt, 990); cout &lt;&lt; cnt / GCD &lt;&lt; &quot;/&quot; &lt;&lt; 990 / GCD &lt;&lt; endl; } } return 0; } ","link":"http://xyf007.ml/post/7-14-zhe-da-acm-ji-xun-zong-jie/"},{"title":"【7-13浙大ACM集训】总结","content":"比赛(补题)链接 低级错误😓 wh B 题忘记写多组数据 我 A 题调试语句忘删 比赛过程 先开 B 题，一开始没仔细想，认为是 n!n!n!，幸好 hcy 及时发现是 n×(n−1)×(n−2)n \\times (n-1) \\times (n-2)n×(n−1)×(n−2)，wh 先写，结果没写多组数据 WA 了一发。我先开 A 题，就是一个简单 DP，结果交的时候没删调试语句，又 WA 了一发。不过 wh 快速秒了 C，形式很好。然后就是搞 F，我口胡了一个随机化算法（居然是正解），然后 hcy 就开始疯狂白给写，不知道是什么原因一直 WA，不同的人暴力结果开始还不一样，然后就 WA 了 8 发，后面我也开始写，写完直接交（反正不担心罚时了），然后，就 A 了？！其他题想了一会儿发现不可做，想了一会儿就去吃饭了。 题解 A 题面 就是一个简单的 DP #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long n, a[1000001], t[1000001], p1, p2, p3, dp[1000001][3]; int main(int argc, char const *argv[]) { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;t[i]); } scanf(&quot;%lld%lld%lld&quot;, &amp;p1, &amp;p2, &amp;p3); dp[1][1] = dp[1][2] = a[1]; for (int i = 2; i &lt;= n; i++) { dp[i][0] = max(max(dp[i - 1][0], dp[i - 1][1]), dp[i - 1][2]); dp[i][1] = max(dp[i - 1][0] + a[i], dp[i - 1][2] + a[i] * (t[i - 1] &lt; t[i] ? p1 : 100) / 100); dp[i][2] = max(max(dp[i - 1][0] + a[i], dp[i - 1][1] + a[i] * (t[i - 1] &gt; t[i] ? p2 : 100) / 100), dp[i - 1][2] + a[i] * p3 / 100); } printf(&quot;%lld\\n&quot;, max(max(dp[n][0], dp[n][1]), dp[n][2])); return 0; } B 题目大意 TTT 组数据，每组数据给定 nnn。求平面上 nnn 条直线至多构成多少对同旁内角。答案对 109+710^9+7109+7 取模。 数据规模：1≤T≤105,1≤n≤1091 \\leq T \\leq 10^5,1 \\leq n \\leq 10^91≤T≤105,1≤n≤109。 分析 对于任意一对同旁内角，与其相关的直线有且仅有 3 条，而对于三条直线，他们至多形成 6 对同旁内角（如图，三条直线构成的三角形中内角三对、外角三对）。故当 n 条直线两两相交且不存在三线共点时，同旁内角对数最多，为 6Cn36C_n^36Cn3​。 （如果通过规定三条直线的顺序来确定一对同旁内角的话，得到的答案是 An3A_n^3An3​，如 lmnlmnlmn 确定 ∠1\\angle 1∠1 和 ∠2\\angle 2∠2，lnmlnmlnm 确定 ∠3\\angle 3∠3 和 ∠4\\angle 4∠4） 那么，“nnn 条直线两两相交且不存在三线共点”的情况一定存在吗？ 一定存在。 假设“n−1n-1n−1 条直线两两相交且不存在三线共点”的情况存在，由于一定能找出一条直线与已知的 n−1n-1n−1 条直线不平行，选取这条直线，则可以证明“nnn 条直线两两相交且不存在三线共点”的情况存在。 时间复杂度 O(T)O(T)O(T)。 另一种做法 本题也可以求出递推式，然后用矩阵快速幂去做。所以在此讲讲递推的做法。 一种递推是：设答案为 ana_nan​。考虑在 nnn 条直线的基础上添加第 n+1n+1n+1 条直线（设为 lll），那么原来的 nnn 条直线构成 ana_nan​ 对与 lll 无关的同旁内角，与 lll 有关的同旁内角中，lll 作截线的有 2Cn22C_n^22Cn2​ 对，lll 不作截线的有 4Cn24C_n^24Cn2​ 对，所以得到递推式 an+1=an+6Cn2a_{n+1}=a_n+6C_n^2an+1​=an​+6Cn2​。 考虑到 Cn+12=Cn1+Cn2=n+Cn2C_{n+1}^2=C_n^1+C_n^2=n+C_n^2Cn+12​=Cn1​+Cn2​=n+Cn2​，我们可以用矩阵来表示 ana_nan​、Cn2C_n^2Cn2​、nnn 的递推，进而用矩阵快速幂来快速计算答案。 时间复杂度为 O(Tlog⁡n)O(T \\log n)O(Tlogn)。 注意事项 nnn 的值很大，所以要用long long。 nnn 的值很大，所以不要写成 n×(n−1)×(n−2) mod 1000000007n \\times (n-1) \\times (n-2) \\bmod 1000000007n×(n−1)×(n−2)mod1000000007。真的有很多人这样 WA 了。。。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; typedef long long ll; typedef unsigned un; typedef std::string str; typedef std::pair&lt;ll,ll&gt; pll; ll read(){ll x=0,f=1;char c=getchar();while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();}return f*x;} ll max(ll a,ll b){return a&gt;b?a:b;} ll min(ll a,ll b){return a&lt;b?a:b;} void umax(ll&amp; a,ll t){if(t&gt;a)a=t;} void umin(ll&amp; a,ll t){if(t&lt;a)a=t;} const ll INF=1ll&lt;&lt;58; const ll yg=ll(1e9)+7; int main() { ll task=read(); while(task--) { ll n=read(); printf(&quot;%lld\\n&quot;,n*(n-1)%yg*(n-2)%yg); } return 0; } C 题意 空图，多次操作，每次加边或询问两点距离是否恰好为 2。 分析 暴力做法： 哈希表维护邻接表，每次 for 一 for。 正解做法： 以下称度数小于 m\\sqrt{m}m​ 的点为小点，其余点为大点。 询问时有一个小点则暴力 for 小点的邻接表查大点是否与对应的点相邻。 再维护一个 m×m\\sqrt{m} \\times \\sqrt{m}m​×m​ 的表格表示所有两个大点形成的点对之间的答案，一边加边一边更新。 小点变成大点时 for 一遍这个点的邻接表，更新它和所有大点之间的答案。 时间复杂度 O(mm)O(m \\sqrt{m})O(mm​)，空间复杂度 O(n+m)O(n+m)O(n+m)。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;set&gt; #include &lt;bitset&gt; using namespace std; struct edge { int to, nxt; edge(int to = 0, int nxt = -1) : to(to), nxt(nxt) {} } e[240001]; struct operation { int op, u, v; } a[120001]; int n, m, E, head[120001], sz[120001], id[120001], tot; set&lt;pair&lt;int, int&gt;&gt; s; bitset&lt;120001&gt; g[501]; bool vis[120001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i].op, &amp;a[i].u, &amp;a[i].v); if (a[i].u &gt; a[i].v) { swap(a[i].u, a[i].v); } if (a[i].op == 1) { sz[a[i].u]++; sz[a[i].v]++; } } int B = sqrt(m); for (int i = 1; i &lt;= n; i++) { if (sz[i] &gt;= B) { id[i] = ++tot; } } for (int i = 1; i &lt;= m; i++) { int u = a[i].u, v = a[i].v; if (a[i].op == 1) { s.insert(make_pair(u, v)); if (sz[u] &gt;= B) { g[id[u]][v] = 1; } else { add(u, v); } if (sz[v] &gt;= B) { g[id[v]][u] = 1; } else { add(v, u); } } else { if (s.count(make_pair(u, v))) { printf(&quot;No\\n&quot;); continue; } if (sz[u] &lt; B) { if (sz[v] &lt; B) { bool f = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { vis[e[i].to] = 1; } for (int i = head[v]; i != -1; i = e[i].nxt) { if (vis[e[i].to]) { f = 1; break; } } for (int i = head[u]; i != -1; i = e[i].nxt) { vis[e[i].to] = 0; } if (f) { printf(&quot;Yes\\n&quot;); } else { printf(&quot;No\\n&quot;); } } else { bool f = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { if (g[id[v]][e[i].to]) { f = 1; break; } } if (f) { printf(&quot;Yes\\n&quot;); } else { printf(&quot;No\\n&quot;); } } } else { if (sz[v] &lt; B) { bool f = 0; for (int i = head[v]; i != -1; i = e[i].nxt) { if (g[id[u]][e[i].to]) { f = 1; break; } } if (f) { printf(&quot;Yes\\n&quot;); } else { printf(&quot;No\\n&quot;); } } else { if ((g[id[u]] &amp; g[id[v]]).any()) { printf(&quot;Yes\\n&quot;); } else { printf(&quot;No\\n&quot;); } } } } } return 0; } D 题面 首先用容斥原理，可得由字符串集合 AAA 构成的 Trie 的节点数可以表示为 ∑S∈A(−1)∣S∣+1LCP⁡(S)\\textstyle\\sum_{S \\in A}{(-1)^{\\left\\vert S \\right\\vert+1}\\operatorname{LCP}(S)}∑S∈A​(−1)∣S∣+1LCP(S)，因为字符串是均匀随机的，所以 LCP 只和字符串数量有关，所以我们直接枚举数量 ∑i=1nCni(−1)i+1f(i)\\textstyle\\sum_{i=1}^nC_n^i(-1)^{i+1}f(i)∑i=1n​Cni​(−1)i+1f(i)，其中 f(i)f(i)f(i) 代表 iii 个满足上述条件的串的 LCP 的期望，这个式子是可以直接 NTT 的，A(x)=∑i=1n(−1)if(i)i!xi,B(x)=∑i=0n1i!xi,C(x)=A(x)B(x)A(x)=\\textstyle\\sum_{i=1}^n\\dfrac{(-1)^if(i)}{i!}x^i,B(x)=\\textstyle\\sum_{i=0}^n\\dfrac{1}{i!}x^i,C(x)=A(x)B(x)A(x)=∑i=1n​i!(−1)if(i)​xi,B(x)=∑i=0n​i!1​xi,C(x)=A(x)B(x)，接下来考虑怎么求 f(i)f(i)f(i)，我们枚举第 jjj 个字符出现在在 LCP 中的期望，那么固定一个字符串后，剩下的 i−1i-1i−1 个字符串只要满足前 jjj 位都和第一个相同即可，所以期望是 (1c)(i−1)j(\\dfrac{1}{c})^{(i-1)j}(c1​)(i−1)j，那么 f(i)=∑j=1L(1c)(i−1)jf(i)=\\textstyle\\sum_{j=1}^L(\\dfrac{1}{c})^{(i-1)j}f(i)=∑j=1L​(c1​)(i−1)j，i≠1i \\neq 1i​=1 时，这个是等比数列求和，那么可以 O(log⁡L+log⁡c)O(\\log L + \\log c)O(logL+logc) 求，所以复杂度就是 O(n(log⁡n+log⁡L+log⁡c))O(n(\\log n + \\log L + \\log c))O(n(logn+logL+logc))。 把问题看成一棵 LLL 层的完全 ccc 叉树，从根走到叶子，一共出发 nnn 次，求经过的节点个数期望，那么我们按层枚举所有节点，计算至少到达一次该节点的概率，也就是完全不到达该节点的概率的补集，那么就是 ∑i=1Lci(1−(1−1ci)n)\\textstyle\\sum_{i=1}^Lc^i(1-(1-\\dfrac{1}{c^i})^n)∑i=1L​ci(1−(1−ci1​)n)，考虑求 ∑i=1Lci(1−1ci)n\\textstyle\\sum_{i=1}^Lc^i(1-\\dfrac{1}{c^i})^n∑i=1L​ci(1−ci1​)n，二项式展开，∑i=1Lci∑j=0nCni(−1)j(1ci)j\\textstyle\\sum_{i=1}^Lc^i\\textstyle\\sum_{j=0}^nC_n^i(-1)^j(\\dfrac{1}{c^i})^j∑i=1L​ci∑j=0n​Cni​(−1)j(ci1​)j，交换一下求和顺序就可以得到和另一种做法一样的式子 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; typedef long long ll; typedef unsigned un; typedef std::string str; typedef std::pair&lt;ll,ll&gt; pll; ll read(){ll x=0,f=1;char c=getchar();while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}while(c&gt;='0'&amp;&amp;c&lt;='9'){x=x*10+c-'0';c=getchar();}return f*x;} ll max(ll a,ll b){return a&gt;b?a:b;} ll min(ll a,ll b){return a&lt;b?a:b;} void umax(ll&amp; a,ll t){if(t&gt;a)a=t;} void umin(ll&amp; a,ll t){if(t&lt;a)a=t;} const ll INF=1ll&lt;&lt;58; const ll yg=998244353; #define mod yg ll Qpow(ll a,ll p) { ll res=1; while(p) { if(p&amp;1)res=res*a%mod; a=a*a%mod,p&gt;&gt;=1; } return res; } ll Inv(ll x){return Qpow(x,mod-2);} ll upd(ll x){return (x%mod+mod)%mod;} #define MAXN 400011 namespace NTT { ll a[MAXN],b[MAXN],status[MAXN]; void NTT(ll* a,ll len,ll type) { for(ll i=0;i&lt;len;++i) if(status[i]&gt;i)std::swap(a[status[i]],a[i]); for(ll cur=1;cur&lt;len;cur&lt;&lt;=1) { ll root=Qpow(3,(mod-1)/(cur&lt;&lt;1)); if(type==-1)root=Qpow(root,mod-2); for(ll j=0;j&lt;len;j+=(cur&lt;&lt;1)) { ll w=1; for(ll k=0;k&lt;cur;++k,w=(w*root)%mod) { ll x=a[j+k],y=w*a[j+cur+k]; a[j+k]=(x+y)%mod; a[j+cur+k]=((x-y)%mod+mod)%mod; } } } } void Mul(ll* a,ll* b,ll n) { ll len=1,dep=0; while(len&lt;=n+n)len&lt;&lt;=1,++dep; for(ll i=0;i&lt;len;++i) status[i]=(status[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(dep-1)); NTT(a,len,1); NTT(b,len,1); for(ll i=0;i&lt;len;++i)a[i]=(a[i]*b[i])%mod; NTT(a,len,-1); ll inv=Qpow(len,mod-2); for(ll i=0;i&lt;=n+n;++i)a[i]=a[i]*inv%mod; } } ll f[MAXN],g[MAXN],fac[MAXN],inv[MAXN]; ll n,L,c; int main() { n=read(),L=read(),c=read(); if(c%mod==1) { for(ll i=1;i&lt;=n;++i)printf(&quot;%lld\\n&quot;,L%mod ); return 0; } fac[0]=inv[0]=1; for(ll i=1;i&lt;=n;++i)fac[i]=fac[i-1]*i%mod,inv[i]=Inv(fac[i]); ll t1=1,t2=1; for(ll i=0;i&lt;=n;++i) { f[i]=Qpow(mod-1,i)*inv[i]%mod; if(t1==1)f[i]=(f[i]*(L+1))%mod; else f[i]=(f[i]*upd(t2-1)%mod*Inv(upd(t1-1)))%mod; t1=(t1*Inv(c))%mod,t2=(t2*Qpow(Inv(c),L+1))%mod; } NTT::Mul(f,inv,n); ll ans=-1; for(ll i=0;i&lt;n;++i)ans=(ans+f[i]*fac[i])%mod,printf(&quot;%lld\\n&quot;,ans ); return 0; } E 题面 被完全包含的区间价值恒 ≤\\leq≤ 包含他的区间的价值，因此去掉包含关系后，可以将所有区间排序，使得区间左右端点严格递增。 有个性质是：对于左右端点同时递增的区间序列，他去覆盖一个长为 nnn 的数值序列，覆盖的数不同的区间只有 O(n)O(n)O(n) 种，每种对应区间序列上连续的一段。 对于覆盖的数相同的区间，价值最大的显然是最长的区间。 于是对于每个询问就可以直接做了，具体实现有两种做法： 第一种是 O(nlog⁡m)O(n \\log m)O(nlogm) 的，对于数值序列的每个数，二分找到第一个和最后一个覆盖了他的区间，然后可以在数值序列上维护一个双指针搞，询问一段区间最长的可以用线段树或者 rmq。 第二种是 O(nlog⁡m(log⁡n+log⁡m))O(n \\log m(\\log n + \\log m))O(nlogm(logn+logm)) 的，由于每种对应连续的一段区间，先在区间序列上二分这一段的最右边那个区间，然后在数值序列上二分找到这个区间覆盖的数，来判断是不是同一种区间。 数据没有卡 log⁡2\\log^2log2 的做法，应该两种做法都能过 F 题意 给 nnn 个点，求是否存在一条直线上点数大于总点数的 p%p\\%p%，保证 ppp 不太小 分析 随机化真的是妙啊，看脸的题。 重复多次，每次随机找两个点，判断两点连线上点数是否大于总点数的 p%p\\%p%。 如果答案是 possible，那么每次有一个不太小的概率使得随机的两个点都在这条直线上，因此重复多次有很大概率正确。 时间复杂度 O(Tn)O(Tn)O(Tn) #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; using namespace std; long long n, p, x[100001], y[100001], ans; int main(int argc, char const *argv[]) { srand(time(0)); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); } if (n == 1) { printf(&quot;possible\\n&quot;); return 0; } long long t = 10000000 / n; while (t--) { int i = 1LL * rand() * rand() % n + 1, j = 1LL * rand() * rand() % n + 1, cnt = 2; while (i == j) { j = 1LL * rand() * rand() % n + 1; } for (int k = 1; k &lt;= n; k++) { if (k == i || k == j) { continue; } if ((x[k] - x[i]) * (y[k] - y[j]) == (y[k] - y[i]) * (x[k] - x[j])) { cnt++; } } if (100LL * cnt &gt;= n * p) { printf(&quot;possible\\n&quot;); return 0; } } printf(&quot;impossible\\n&quot;); return 0; } ","link":"http://xyf007.ml/post/7-13-zhe-da-acm-ji-xun-zong-jie/"},{"title":"【模板】树链剖分","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct edge { int to, nxt; } e[200001]; int n, m, root, p, E, head[100001], a[100001], b[100001], sz[100001], dep[100001], son[100001], f[100001], top[100001], dfn[100001], cnt; long long sum[400001], Add[400001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void dfs1(int u, int fa) { sz[u] = 1; f[u] = fa; dep[u] = dep[fa] + 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } dfs1(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[son[u]]) { son[u] = v; } } } void dfs2(int u, int t) { top[u] = t; dfn[u] = ++cnt; b[cnt] = a[u]; if (!son[u]) { return; } dfs2(son[u], t); for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == f[u] || v == son[u]) { continue; } dfs2(v, v); } } void pushup(int x) { sum[x] = (sum[x + x] + sum[x + x + 1]) % p; } void pushdown(int l, int r, int x) { if (Add[x]) { int mid = (l + r) &gt;&gt; 1; Add[x + x] = (Add[x + x] + Add[x]) % p; Add[x + x + 1] = (Add[x + x + 1] + Add[x]) % p; sum[x + x] = (sum[x + x] + Add[x] * (mid - l + 1) % p) % p; sum[x + x + 1] = (sum[x + x + 1] + Add[x] * (r - mid) % p) % p; Add[x] = 0; } } void build(int l, int r, int x) { if (l == r) { sum[x] = b[l]; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, x + x); build(mid + 1, r, x + x + 1); pushup(x); } void modify(int L, int R, int l, int r, int val, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { Add[x] = (Add[x] + val) % p; sum[x] = (sum[x] + val * (r - l + 1) % p) % p; return; } pushdown(l, r, x); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) { modify(L, R, l, mid, val, x + x); } if (R &gt; mid) { modify(L, R, mid + 1, r, val, x + x + 1); } pushup(x); } long long query(int L, int R, int l, int r, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { return sum[x]; } pushdown(l, r, x); int mid = (l + r) &gt;&gt; 1; long long ret = 0; if (L &lt;= mid) { ret = (ret + query(L, R, l, mid, x + x)) % p; } if (R &gt; mid) { ret = (ret + query(L, R, mid + 1, r, x + x + 1)) % p; } return ret; } void change_route(int x, int y, int z) { while (top[x] != top[y]) { if (dep[top[x]] &lt; dep[top[y]]) { swap(x, y); } modify(dfn[top[x]], dfn[x], 1, n, z, 1); x = f[top[x]]; } if (dep[x] &gt; dep[y]) { swap(x, y); } modify(dfn[x], dfn[y], 1, n, z, 1); } long long query_route(int x, int y) { long long ans = 0; while (top[x] != top[y]) { if (dep[top[x]] &lt; dep[top[y]]) { swap(x, y); } ans = (ans + query(dfn[top[x]], dfn[x], 1, n, 1)) % p; x = f[top[x]]; } if (dep[x] &gt; dep[y]) { swap(x, y); } ans = (ans + query(dfn[x], dfn[y], 1, n, 1)) % p; return ans; } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;root, &amp;p); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i] %= p; } for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); add(v, u); } dfs1(root, 0); dfs2(root, root); build(1, n, 1); for (int i = 1; i &lt;= m; i++) { int op, x, y, z; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); switch (op) { case 1: scanf(&quot;%d%d&quot;, &amp;y, &amp;z); z %= p; change_route(x, y, z); break; case 2: scanf(&quot;%d&quot;, &amp;y); printf(&quot;%lld\\n&quot;, query_route(x, y)); break; case 3: scanf(&quot;%d&quot;, &amp;z); z %= p; modify(dfn[x], dfn[x] + sz[x] - 1, 1, n, z, 1); break; default: printf(&quot;%lld\\n&quot;, query(dfn[x], dfn[x] + sz[x] - 1, 1, n, 1)); break; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-shu-lian-pou-fen/"},{"title":"【模板】树套树","content":" 树状数组套权值线段树 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int ls, rs, sz; } t[4000001]; int n, m, op[50001], l[50001], r[50001], k[50001], a[50001], b[50001], tot, root[50001], cnt, x[50001], y[50001], tmp1, tmp2; void pushup(int x) { t[x].sz = t[t[x].ls].sz + t[t[x].rs].sz; } void modify(int l, int r, int p, int val, int &amp;x) { if (!x) { x = ++cnt; } if (l == r) { t[x].sz += val; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { modify(l, mid, p, val, t[x].ls); } else { modify(mid + 1, r, p, val, t[x].rs); } pushup(x); } int query_rank(int L, int R, int l, int r, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { return t[x].sz; } int mid = (l + r) &gt;&gt; 1, ans = 0; if (L &lt;= mid) { ans += query_rank(L, R, l, mid, t[x].ls); } if (R &gt; mid) { ans += query_rank(L, R, mid + 1, r, t[x].rs); } return ans; } int query_kth(int l, int r, int k) { if (l == r) { return l; } int mid = (l + r) &gt;&gt; 1, sum = 0; for (int i = 1; i &lt;= tmp1; i++) { sum -= t[t[x[i]].ls].sz; } for (int i = 1; i &lt;= tmp2; i++) { sum += t[t[y[i]].ls].sz; } if (k &lt;= sum) { for (int i = 1; i &lt;= tmp1; i++) { x[i] = t[x[i]].ls; } for (int i = 1; i &lt;= tmp2; i++) { y[i] = t[y[i]].ls; } return query_kth(l, mid, k); } else { for (int i = 1; i &lt;= tmp1; i++) { x[i] = t[x[i]].rs; } for (int i = 1; i &lt;= tmp2; i++) { y[i] = t[y[i]].rs; } return query_kth(mid + 1, r, k - sum); } } void Modify(int x, int val) { for (int i = x; i &lt;= n; i += i &amp; -i) { modify(1, tot, a[x], val, root[i]); } } int Rank(int l, int r, int k) { int ans = 0; for (int i = r; i &gt; 0; i -= i &amp; -i) { ans += query_rank(1, k - 1, 1, tot, root[i]); } for (int i = l - 1; i &gt; 0; i -= i &amp; -i) { ans -= query_rank(1, k - 1, 1, tot, root[i]); } return ans + 1; } int Kth(int l, int r, int k) { tmp1 = tmp2 = 0; for (int i = l - 1; i &gt; 0; i -= i &amp; -i) { x[++tmp1] = root[i]; } for (int i = r; i &gt; 0; i -= i &amp; -i) { y[++tmp2] = root[i]; } return b[query_kth(1, tot, k)]; } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); b[i] = a[i]; } for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;op[i], &amp;l[i]); switch (op[i]) { case 3: scanf(&quot;%d&quot;, &amp;k[i]); break; default: scanf(&quot;%d%d&quot;, &amp;r[i], &amp;k[i]); break; } b[n + i] = k[i]; } sort(b + 1, b + n + m + 1); tot = unique(b + 1, b + n + m + 1) - b - 1; for (int i = 1; i &lt;= n; i++) { a[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b; Modify(i, 1); } for (int i = 1; i &lt;= m; i++) { int now; switch (op[i]) { case 1: k[i] = lower_bound(b + 1, b + tot + 1, k[i]) - b; printf(&quot;%d\\n&quot;, Rank(l[i], r[i], k[i])); break; case 2: printf(&quot;%d\\n&quot;, Kth(l[i], r[i], k[i])); break; case 3: Modify(l[i], -1); a[l[i]] = lower_bound(b + 1, b + tot + 1, k[i]) - b; Modify(l[i], 1); break; case 4: k[i] = lower_bound(b + 1, b + tot + 1, k[i]) - b; now = Rank(l[i], r[i], k[i]); if (now == 1) { printf(&quot;-2147483647\\n&quot;); } else { printf(&quot;%d\\n&quot;, Kth(l[i], r[i], now - 1)); } break; default: k[i] = lower_bound(b + 1, b + tot + 1, k[i]) - b; if (k[i] == tot) { printf(&quot;2147483647\\n&quot;); break; } now = Rank(l[i], r[i], k[i] + 1); if (now == r[i] - l[i] + 2) { printf(&quot;2147483647\\n&quot;); break; } else { printf(&quot;%d\\n&quot;, Kth(l[i], r[i], now)); } break; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-shu-tao-shu/"},{"title":"【模板】后缀数组","content":"#include &lt;iostream&gt; #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, p, sa[1000001], rk[1000001], trk[1000001], sum[1000001], height[1000001]; char s[1000001]; void Sort() { for (int i = 1; i &lt;= m; i++) { sum[i] = 0; } for (int i = 1; i &lt;= n; i++) { sum[rk[i]]++; } for (int i = 2; i &lt;= m; i++) { sum[i] += sum[i - 1]; } for (int i = n; i &gt;= 1; i--) { sa[sum[rk[trk[i]]]--] = trk[i]; } } void get_SA() { for (int i = 1; i &lt;= n; i++) { rk[i] = s[i]; sum[rk[i]]++; trk[i] = i; } Sort(); for (int len = 1; len &lt;= n; len &lt;&lt;= 1) { p = 0; for (int i = n - len + 1; i &lt;= n; i++) { trk[++p] = i; } for (int i = 1; i &lt;= n; i++) { if (sa[i] &gt; len) { trk[++p] = sa[i] - len; } } Sort(); memcpy(trk, rk, sizeof(rk)); p = rk[sa[1]] = 1; for (int i = 2; i &lt;= n; i++) { rk[sa[i]] = trk[sa[i]] == trk[sa[i - 1]] &amp;&amp; trk[sa[i] + len] == trk[sa[i - 1] + len] ? p : ++p; } if (p == n) { break; } m = p; } } void get_height() { int k = 0; for (int i = 1; i &lt;= n; i++) { rk[sa[i]] = i; } for (int i = 1; i &lt;= n; i++) { if (rk[i] == 1) { continue; } if (k) { k--; } int j = sa[rk[i] - 1]; while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) { k++; } height[rk[i]] = k; } } int main(int argc, char const *argv[]) { scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); m = 200; get_SA(); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, sa[i]); } // puts(&quot;&quot;); // get_height(); // for (int i = 1; i &lt;= n; i++) // { // printf(&quot;%d &quot;, height[i]); // } return 0; } ","link":"http://xyf007.ml/post/mu-ban-hou-zhui-shu-zu/"},{"title":"【模板】可持久化并查集","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int ls, rs, fa, dep; } t[6000001]; int n, m, root[200001], tot; int build(int l, int r) { int x = ++tot; if (l == r) { t[x].fa = l; return x; } int mid = (l + r) &gt;&gt; 1; t[x].ls = build(l, mid); t[x].rs = build(mid + 1, r); return x; } int modify(int x, int l, int r, int p, int val) { int xx = ++tot; t[xx].ls = t[x].ls; t[xx].rs = t[x].rs; if (l == r) { t[xx].fa = val; t[xx].dep = t[x].dep; return xx; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { t[xx].ls = modify(t[x].ls, l, mid, p, val); } else { t[xx].rs = modify(t[x].rs, mid + 1, r, p, val); } return xx; } void update(int x, int l, int r, int p) { if (l == r) { t[x].dep++; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { update(t[x].ls, l, mid, p); } else { update(t[x].rs, mid + 1, r, p); } } int query(int x, int l, int r, int p) { if (l == r) { return x; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { return query(t[x].ls, l, mid, p); } else { return query(t[x].rs, mid + 1, r, p); } } int find(int ver, int x) { int y = query(root[ver], 1, n, x); if (t[y].fa == x) { return y; } return find(ver, t[y].fa); } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); root[0] = build(1, n); for (int i = 1; i &lt;= m; i++) { int op, x, y, fx, fy; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); root[i] = root[i - 1]; switch (op) { case 1: scanf(&quot;%d&quot;, &amp;y); fx = find(i, x); fy = find(i, y); if (t[fx].fa == t[fy].fa) { continue; } if (t[fx].dep &gt; t[fy].dep) { swap(fx, fy); } root[i] = modify(root[i - 1], 1, n, t[fx].fa, t[fy].fa); if (t[fx].dep == t[fy].dep) { update(root[i], 1, n, t[fy].fa); } break; case 2: root[i] = root[x]; break; default: scanf(&quot;%d&quot;, &amp;y); fx = find(i, x); fy = find(i, y); if (t[fx].fa == t[fy].fa) { printf(&quot;1\\n&quot;); } else { printf(&quot;0\\n&quot;); } break; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-ke-chi-jiu-hua-bing-cha-ji/"},{"title":"【模板】有理数取余","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #define int long long using namespace std; const int MOD = 19260817; int a, b; int ksm(int a, int b) { int s = 1; while (b) { if (b &amp; 1) { s = s * a % MOD; } a = a * a % MOD; b &gt;&gt;= 1; } return s; } #undef int int main(int argc, char const *argv[]) { #define int long long char c = getchar(); while (isdigit(c)) { a = (a * 10 + c - '0') % MOD; c = getchar(); } c = getchar(); c = getchar(); while (isdigit(c)) { b = (b * 10 + c - '0') % MOD; c = getchar(); } if (!b) { printf(&quot;Angry!&quot;); return 0; } printf(&quot;%lld&quot;, a * ksm(b, MOD - 2) % MOD); return 0; } ","link":"http://xyf007.ml/post/mu-ban-you-li-shu-qu-yu/"},{"title":"【模板】乘法逆元","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; using namespace std; int n, p, k, a[5000001], pre[5000001], suf[5000002]; inline int read() { int x = 0, f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') { f = -1; } c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); } return x * f; } inline int ksm(int a, int b) { int sum = 1; while (b) { if (b &amp; 1) { sum = 1LL * sum * a % p; } a = 1LL * a * a % p; b &gt;&gt;= 1; } return sum; } int main(int argc, char const *argv[]) { n = read(); p = read(); k = read(); pre[0] = suf[n + 1] = 1; for (register int i = 1; i &lt;= n; i++) { a[i] = read(); pre[i] = 1LL * pre[i - 1] * a[i] % p; } for (register int i = n; i &gt;= 1; i--) { suf[i] = 1LL * suf[i + 1] * a[i] % p; } int tmp = 1, sum = 0; for (register int i = 1; i &lt;= n; i++) { tmp = 1LL * tmp * k % p; sum = (sum + 1LL * tmp * pre[i - 1] % p * suf[i + 1] % p) % p; } printf(&quot;%lld&quot;, 1LL * sum * ksm(pre[n], p - 2) % p); return 0; } ","link":"http://xyf007.ml/post/mu-ban-cheng-fa-ni-yuan/"},{"title":"【模板】单调栈","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, a[3000001], ans[3000001], s[3000001], top; int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); while (top &amp;&amp; a[i] &gt; a[s[top]]) { ans[s[top--]] = i; } s[++top] = i; } for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, ans[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dan-diao-zhan/"},{"title":"ZJOI2020 游记","content":"前情提要 CSP–S Day1T2 由于数据过水，导致我本来 RE 的代码 A 了，多出 40 分，321-&gt;361，获得了省选爆零的机会。 Day0 由于是初三，而且能力不够，于是就打算去打打酱油。赛前也没背板子，就看了看一些省选内容。 Day1 根据前人提供的经验，ZJOI 应该先开 T2，结果是期望题。。。于是去看 T1，想了一会儿发现 qqq 是 2e5 级别的，如果真的每一组数据都是 2e5 的话连 O(nq)O(nq)O(nq) 都只有10分，只能写正解。于是猜想前面的部分是 qqq 比较小的，哈希一下再 O(n2)O(n^2)O(n2) 预处理，O(n2)O(n^2)O(n2) 查询，预计 20~40pts。 然后去看 T3，粗看是一道水题，但仔细一看发现确实很难，感觉暴力都没有思路，想了大概 20min 直接放弃，接着去肝 T2。先发现 k=1k=1k=1 的情况算一下贡献就行了，码了一会儿就好了。接下来想办法写其他情况。发现 70 分都是 k≤109k \\leq 10^9k≤109 级别的，如果 DP 的话不能放在状态里面，使劲想了大概半小时发现自己水平不够，只能暴力 DP。尝试滚动数组来卡，但是推概率出了问题。一开始只算了打标记的概率，大概 1h 后才发现标记是否下传的概率和是否打标记的概率是不一样的，这时又感到很饿，于是一边吃一边想，但一直调不对。到最后 30min 才发现把标记下传的概率算错了，直到结束也没有调出来。 Day1 估分:30 + 10 + 0 = 40 Day2 开始解压文件的时候老师报错了密码，所幸 5min 后改正了。一开题发现 T1、T3 题面都很长，T1 有各种奇怪的性质但是我都写不出来，先写了链的情况，然后去想 T3。认真读完题又放弃了，随机的 bbb 还有模 ppp 意义下的一堆东西我显然做不出来，又回去写 T1 的环的情况，总共写了 300 多行，估计最多 10 分-_-||，尝试去推树的情况，结果推不出来。转而做 T2，想了很长时间才想到怎么做 10 分的状压 DP，不过码出来了。看到后面的大数据，感觉连 O(n3)O(n^3)O(n3) 的方法都毫无头绪，T1 又推不出来，于是彻底放弃希望，最终也没有增加分数。 Day2 估分:10 + 10 + 0 = 20 第一次参加 ZJOI，体会到了最难比赛的难度，反正是打酱油，成绩也无所谓了 ","link":"http://xyf007.ml/post/zjoi2020-you-ji/"},{"title":"【模板】负环","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; struct edge { int to, nxt, cost; } e[6001]; int t, n, m, E, head[2001], dis[2001], in[2001]; bool vis[2001]; void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } bool spfa() { memset(vis, 0, sizeof(vis)); memset(in, 0, sizeof(in)); memset(dis, 0x3f, sizeof(dis)); dis[1] = 0; queue&lt;int&gt; q; q.push(1); vis[1] = 1; in[1] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (dis[u] + e[i].cost &lt; dis[v]) { dis[v] = dis[u] + e[i].cost; if (!vis[v]) { q.push(v); vis[v] = 1; in[v]++; if (in[v] &gt; m) { return 1; } } } } } return 0; } int main(int argc, const char* argv[]) { scanf(&quot;%d&quot;, &amp;t); while (t--) { memset(head, -1, sizeof(head)); E = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); if (w &gt;= 0) { add(v, u, w); } } if (spfa()) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-fu-huan/"},{"title":"【模板】单调队列","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;deque&gt; using namespace std; int n, k, a[1000001]; deque&lt;int&gt; q; int main(int argc, const char* argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; i++) { while (!q.empty() &amp;&amp; a[q.back()] &gt; a[i]) { q.pop_back(); } q.push_back(i); while (i - q.front() &gt;= k) { q.pop_front(); } if (i &gt;= k) { printf(&quot;%d &quot;, a[q.front()]); } } printf(&quot;\\n&quot;); q.clear(); for (int i = 1; i &lt;= n; i++) { while (!q.empty() &amp;&amp; a[q.back()] &lt; a[i]) { q.pop_back(); } q.push_back(i); while (i - q.front() &gt;= k) { q.pop_front(); } if (i &gt;= k) { printf(&quot;%d &quot;, a[q.front()]); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dan-diao-dui-lie/"},{"title":"【模板】点分治","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; struct Edge { int to, nxt, cost; } e[20001]; int n, m, E, head[10001], sz[10001], SZ, maxp[10001], root, q[101], a[10001], b[10001], tot, dis[10001]; bool vis[10001], f[101]; void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } void get_root(int u, int fa) { sz[u] = 1; maxp[u] = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) { continue; } get_root(v, u); sz[u] += sz[v]; checkmax(maxp[u], sz[v]); } checkmax(maxp[u], SZ - sz[u]); if (!root || maxp[u] &lt; maxp[root]) { root = u; } } void get_dis(int u, int fa, int d, int id) { a[++tot] = u; b[u] = id; dis[u] = d; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) { continue; } get_dis(v, u, d + e[i].cost, id); } } void Calc(int u) { a[tot = 1] = u; dis[u] = 0; b[u] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v]) { continue; } get_dis(v, u, e[i].cost, v); } std::sort(a + 1, a + tot + 1, [](const int &amp;x, const int &amp;y) -&gt; bool { return dis[x] &lt; dis[y]; }); for (int i = 1; i &lt;= m; i++) { if (f[i]) { continue; } int l = 1, r = tot; while (l &lt;= r) { if (dis[a[l]] + dis[a[r]] &gt; q[i]) { r--; } else if (dis[a[l]] + dis[a[r]] &lt; q[i]) { l++; } else { if (b[a[l]] == b[a[r]]) { if (dis[a[r - 1]] == dis[a[r]]) { r--; } else { l++; } } else { f[i] = true; break; } } } } } void Solve(int u) { Calc(u); vis[u] = true; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v]) { continue; } SZ = sz[v]; root = 0; get_root(v, u); Solve(root); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) { int u, v, c; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; add(u, v, c); add(v, u, c); } for (int i = 1; i &lt;= m; i++) { std::cin &gt;&gt; q[i]; } SZ = n; get_root(1, 0); Solve(root); for (int i = 1; i &lt;= m; i++) { if (f[i]) { std::cout &lt;&lt; &quot;AYE\\n&quot;; } else { std::cout &lt;&lt; &quot;NAY\\n&quot;; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-dian-fen-zhi/"},{"title":"【模板】差分约束系统","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; struct edge { int to, nxt, cost; } e[10001]; int n, m, E, head[5001], dis[5001], ind[5001]; bool vis[5001]; void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } bool spfa() { memset(dis, 127 / 3, sizeof(dis)); queue&lt;int&gt; q; dis[0] = 1; q.push(0); vis[0] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (dis[v] &gt; dis[u] + e[i].cost) { dis[v] = dis[u] + e[i].cost; if (!vis[v]) { q.push(v); vis[v] = 1; ind[v]++; if (ind[v] == n) { return 0; } } } } } return 1; } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= n; i++) { add(0, i, 0); } for (int i = 1; i &lt;= m; i++) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); add(v, u, c); } if (!spfa()) { printf(&quot;NO&quot;); } else { for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, dis[i]); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-cha-fen-yue-shu-xi-tong/"},{"title":"【模板】Manacher","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, p[22000001]; char s[11000001], b[22000001]; void checkmax(int &amp;x, int y) { if (x &lt; y) { x = y; } } int main(int argc, char const *argv[]) { scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); b[0] = '#'; for (int i = 1; i &lt;= n; i++) { b[2 * i - 1] = s[i]; b[2 * i] = '#'; } int maxp = 0, maxlen = 0, ans = 0; for (int i = 1; i &lt;= 2 * n; i++) { p[i] = 1; if (maxlen &gt; i) { p[i] = min(p[2 * maxp - i], maxlen - i); } while (i + p[i] &lt;= 2 * n &amp;&amp; i - p[i] &gt;= 0 &amp;&amp; b[i + p[i]] == b[i - p[i]]) { p[i]++; } if (i + p[i] &gt; maxlen) { maxlen = i + p[i]; maxp = i; } checkmax(ans, p[i]); } printf(&quot;%d&quot;, ans - 1); return 0; } ","link":"http://xyf007.ml/post/mu-ban-manacher/"},{"title":"【模板】KMP","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, nxt[1000001]; char s1[1000001], s2[1000001]; int main(int argc, char const *argv[]) { scanf(&quot;%s%s&quot;, s1 + 1, s2 + 1); n = strlen(s1 + 1); m = strlen(s2 + 1); nxt[1] = 0; int j = 0; for (int i = 2; i &lt;= m; i++) { while (j &amp;&amp; s2[i] != s2[j + 1]) { j = nxt[j]; } if (s2[i] == s2[j + 1]) { j++; } nxt[i] = j; } j = 0; for (int i = 1; i &lt;= n; i++) { while (j &amp;&amp; s1[i] != s2[j + 1]) { j = nxt[j]; } if (s1[i] == s2[j + 1]) { j++; } if (j == m) { printf(&quot;%d\\n&quot;, i - m + 1); j = nxt[j]; } } for (int i = 1; i &lt;= m; i++) { printf(&quot;%d &quot;, nxt[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-kmp/"},{"title":"【模板】归并排序","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long n, a[500001], tmp[500001], ans; void merge_sort(long long l, long long r) { if (l == r) { return; } long long mid = (l + r) &gt;&gt; 1, i = l, j = mid + 1, k = l; merge_sort(l, mid); merge_sort(mid + 1, r); while (i &lt;= mid &amp;&amp; j &lt;= r) { if (a[i] &lt;= a[j]) { tmp[k++] = a[i++]; } else { ans += mid - i + 1; tmp[k++] = a[j++]; } } while (i &lt;= mid) { tmp[k++] = a[i++]; } while (j &lt;= r) { tmp[k++] = a[j++]; } for (int u = l; u &lt;= r; u++) { a[u] = tmp[u]; } } int main() { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } merge_sort(1LL, n); printf(&quot;%lld&quot;, ans); return 0; } ","link":"http://xyf007.ml/post/mu-ban-gui-bing-pai-xu/"},{"title":"【模板】快速排序","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, a[1000001]; void qsort(int l, int r) { int i = l, j = r, mid = a[(l + r) &gt;&gt; 1]; do { while (a[i] &lt; mid) { i++; } while (a[j] &gt; mid) { j--; } if (i &lt;= j) { swap(a[i], a[j]); i++; j--; } } while (i &lt;= j); if (i &lt; r) { qsort(i, r); } if (j &gt; l) { qsort(l, j); } } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } qsort(1, n); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, a[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuai-su-pai-xu/"},{"title":"【模板】三分","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const double eps = 1e-8; int n; double l, r, a[15]; double check(double x) { double s = 0; for (int i = 0; i &lt;= n; i++) { double tmp = 1; for (int j = 0; j &lt; i; j++) { tmp *= x; } s += tmp * a[i]; } return s; } int main(int argc, char const *argv[]) { scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;l, &amp;r); for (int i = n; i; i--) { scanf(&quot;%lf&quot;, &amp;a[i]); } while (r - l &gt; eps) { double mid1 = l + (r - l) / 3.0, mid2 = l + 2 * (r - l) / 3.0; if (check(mid1) &lt; check(mid2)) { l = mid1; } else { r = mid2; } } printf(&quot;%.5lf&quot;, l); return 0; } ","link":"http://xyf007.ml/post/mu-ban-san-fen/"},{"title":"【模板】线性求逆元","content":"首先 1≡1(modp)1 \\equiv 1 \\pmod p1≡1(modp) 然后我们设 p=k×i+r,r&lt;i,1&lt;i&lt;pp=k \\times i+r,r&lt;i,1&lt;i&lt;pp=k×i+r,r&lt;i,1&lt;i&lt;p 再将这个式子放到模 ppp 意义下就会得到 k×i+r≡0(modp)k \\times i + r \\equiv 0 \\pmod p k×i+r≡0(modp) 两边同时乘上 i−1×r−1i^{-1} \\times r^{-1}i−1×r−1 就会得到 k×r−1+i−1≡0(modp)i−1≡−k×r−1(modp)i−1≡−⌊pi⌋×(p mod i)−1(modp)\\begin{aligned} k \\times r^{-1} + i^{-1} &amp;\\equiv 0 &amp;\\pmod p\\\\ i^{-1} &amp;\\equiv -k \\times r^{-1} &amp;\\pmod p\\\\ i^{-1} &amp;\\equiv -\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor \\times (p \\bmod i)^{-1} &amp;\\pmod p \\end{aligned} k×r−1+i−1i−1i−1​≡0≡−k×r−1≡−⌊ip​⌋×(pmodi)−1​(modp)(modp)(modp)​ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long n, p, inv[3000001]; int main(int argc, char const *argv[]) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;p); inv[1] = 1; printf(&quot;1\\n&quot;); for (int i = 2; i &lt;= n; i++) { inv[i] = (p - p / i) * inv[p % i] % p; printf(&quot;%lld\\n&quot;, inv[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-xing-qiu-ni-yuan/"},{"title":"【模板】矩阵加速（数列）","content":"#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const long long MOD = 1e9 + 7; long long t, n; struct matrix { long long m[3][3]; matrix operator*(const matrix b) const { matrix c; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { c.m[i][j] = 0; } } for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { for (int k = 0; k &lt; 3; k++) { c.m[i][j] = (c.m[i][j] + m[i][k] * b.m[k][j]) % MOD; } } } return c; } } A, B; matrix ksm(matrix a, long long b) { matrix ans; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { ans.m[i][j] = 0; } } for (int i = 0; i &lt; 3; i++) { ans.m[i][i] = 1; } while (b) { if (b &amp; 1) { ans = ans * a; } a = a * a; b &gt;&gt;= 1; } return ans; } int main() { scanf(&quot;%lld&quot;, &amp;t); while (t--) { scanf(&quot;%lld&quot;, &amp;n); if (n &lt;= 3) { printf(&quot;1\\n&quot;); continue; } memset(A.m, 0, sizeof(A.m)); memset(B.m, 0, sizeof(B.m)); A.m[0][0] = 1; A.m[0][2] = 1; A.m[1][0] = 1; A.m[2][1] = 1; B.m[0][0] = 1; B.m[1][0] = 1; B.m[2][0] = 1; A = ksm(A, n - 3); B = A * B; printf(&quot;%lld\\n&quot;, B.m[0][0]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-ju-zhen-jia-su-shu-lie/"},{"title":"【模板】卢卡斯定理","content":"对于质数 ppp，有 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\dbinom{n}{m} \\bmod p=\\dbinom{\\lfloor n/p \\rfloor}{\\lfloor m/p \\rfloor}\\cdot\\dbinom{n \\bmod p}{m \\bmod p} \\bmod p (mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int t, n, m, p, sum[100001]; void init() { sum[0] = 1; for (int i = 1; i &lt;= p; i++) { sum[i] = 1LL * sum[i - 1] * i % p; } } int ksm(int a, int b) { int s = 1; a %= p; while (b) { if (b &amp; 1) { s = 1LL * s * a % p; } a = 1LL * a * a % p; b &gt;&gt;= 1; } return s; } int c(int x, int y) { if (y &gt; x) { return 0; } return 1LL * sum[x] * ksm(sum[y], p - 2) % p * ksm(sum[x - y] % p, p - 2) % p; } int lucas(int x, int y) { if (!y) { return 1; } return 1LL * c(x % p, y % p) * lucas(x / p, y / p) % p; } int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;p); init(); printf(&quot;%d\\n&quot;, lucas(m + n, m)); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-lu-kia-si-ding-li/"},{"title":"【模板】线性筛素数","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; int n, m, x; bool notprime[10000001]; vector&lt;int&gt; prime; int main() { notprime[1] = 1; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 2; i &lt;= n; i++) { if (!notprime[i]) { prime.push_back(i); } for (int j = 0; j &lt; (int)prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) { notprime[i * prime[j]] = 1; if (i % prime[j] == 0) { break; } } } for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d&quot;, &amp;x); if (notprime[x]) { printf(&quot;No\\n&quot;); } else { printf(&quot;Yes\\n&quot;); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-xing-shai-su-shu/"},{"title":"【模板】高斯消元","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; const double eps = 1e-6; int n; double a[101][101], ans[101]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { scanf(&quot;%lf&quot;, &amp;a[i][j]); } } for (int i = 1; i &lt;= n; i++) { int t = i; for (int j = i + 1; j &lt;= n; j++) { if (fabs(a[j][i]) &gt; fabs(a[t][i])) { t = j; } } if (fabs(a[t][i]) &lt; eps) { printf(&quot;No Solution&quot;); return 0; } if (i != t) { swap(a[i], a[t]); } double temp = a[i][i]; for (int j = i; j &lt;= n + 1; j++) { a[i][j] /= temp; } for (int j = i + 1; j &lt;= n; j++) { temp = a[j][i]; for (int k = i; k &lt;= n + 1; k++) { a[j][k] -= temp * a[i][k]; } } } ans[n] = a[n][n + 1]; for (int i = n - 1; i &gt;= 1; i--) { ans[i] = a[i][n + 1]; for (int j = n; j &gt; i; j--) { ans[i] -= a[i][j] * ans[j]; } } for (int i = 1; i &lt;= n; i++) { printf(&quot;%.2lf\\n&quot;, ans[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-gao-si-xiao-yuan/"},{"title":"【模板】快速幂","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long ksm(long long a, long long b, long long c) { long long s = 1; while (b) { if (b &amp; 1) { s = s * a % c; } a = a * a % c; b &gt;&gt;= 1; } return s; } int main() { long long a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); if (c == 1) { printf(&quot;%lld^%lld mod %lld=0&quot;, a, b, c); return 0; } printf(&quot;%lld^%lld mod %lld=%lld&quot;, a, b, c, ksm(a, b, c)); return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuai-su-mi/"},{"title":"【模板】矩阵快速幂","content":"#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const long long MOD = 1e9 + 7; long long n, k; struct matrix { long long m[100][100]; matrix operator*(const matrix b) const { matrix c; for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { c.m[i][j] = 0; } } for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { for (int k = 0; k &lt; 100; k++) { c.m[i][j] = (c.m[i][j] + m[i][k] * b.m[k][j]) % MOD; } } } return c; } } A, B; matrix ksm(matrix a, long long b) { matrix ans; for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { ans.m[i][j] = 0; } } for (int i = 0; i &lt; 100; i++) { ans.m[i][i] = 1; } while (b) { if (b &amp; 1) { ans = ans * a; } a = a * a; b &gt;&gt;= 1; } return ans; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { scanf(&quot;%lld&quot;, &amp;A.m[i][j]); } } A = ksm(A, k); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { printf(&quot;%lld &quot;, A.m[i][j]); } printf(&quot;\\n&quot;); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-ju-zhen-kuai-su-mi/"},{"title":"【模板】扩展欧几里得（exgcd）","content":"ax1+by1=bx2+(a mod b)y2=gcd⁡(a,b)ax_1+by_1=bx_2+(a \\bmod b)y_2=\\gcd(a,b) ax1​+by1​=bx2​+(amodb)y2​=gcd(a,b) 所以 ax1+by1=bx2+(a−⌊ab⌋×b)y2ax1+by1=ay2+b(x2−⌊ab⌋y2)\\begin{aligned} ax_1+by_1&amp;=bx_2+(a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor \\times b)y_2\\\\ ax_1+by_1&amp;=ay_2+b(x_2-\\left\\lfloor\\frac{a}{b}\\right\\rfloor y_2) \\end{aligned} ax1​+by1​ax1​+by1​​=bx2​+(a−⌊ba​⌋×b)y2​=ay2​+b(x2​−⌊ba​⌋y2​)​ 所以 x1=y2,y1=x2−⌊ab⌋y2x_1=y_2,y_1=x_2-\\left\\lfloor\\frac{a}{b}\\right\\rfloor y_2x1​=y2​,y1​=x2​−⌊ba​⌋y2​。 将 x2,y2x_2,y_2x2​,y2​ 不断代入递归求解直至 GCD 为 0，递归 x=1,y=0 回去求解。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; long long t, a, b, c; void exgcd(long long a, long long b, long long &amp;x, long long &amp;y) { if (!b) { x = 1; y = 0; return; } exgcd(b, a % b, x, y); long long tmp = x; x = y; y = tmp - a / b * y; } int main(int argc, char const *argv[]) { scanf(&quot;%lld&quot;, &amp;t); while (t--) { scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); long long GCD = __gcd(a, b), x, y; if (c % GCD) { printf(&quot;-1\\n&quot;); continue; } a /= GCD; b /= GCD; c /= GCD; exgcd(a, b, x, y); x *= c; y *= c; if (x &lt;= 0) { long long t = (-x) / b + 1; x = x % b + b; y -= t * a; if (y &lt;= 0) { printf(&quot;%lld %lld\\n&quot;, x, y % a + a); continue; } } if (y &lt;= 0) { long long t = (-y) / a + 1; y = y % a + a; x -= t * b; if (x &lt;= 0) { printf(&quot;%lld %lld\\n&quot;, x % b + b, y); continue; } } long long t1 = x / b - (!(x % b)), t2 = y / a - (!(y % a)); printf(&quot;%lld %lld %lld %lld %lld\\n&quot;, t1 + t2 + 1, x - b * t1, y - a * t2, x + b * t2, y + a * t1); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-kuo-zhan-ou-ji-li-de-exgcd/"},{"title":"【模板】康托展开","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int MOD = 998244353; int n, a[1000001], fact[1000001], sum[4000001]; void init() { fact[1] = 1; for (int i = 2; i &lt;= n; i++) { fact[i] = (1LL * fact[i - 1] * i) % MOD; } } void pushup(int x) { sum[x] = (sum[x + x] + sum[x + x + 1]) % MOD; } void build(int l, int r, int x) { if (l == r) { sum[x] = 1; return; } int mid = (l + r) &gt;&gt; 1; build(l, mid, x + x); build(mid + 1, r, x + x + 1); pushup(x); } void modify(int l ,int r, int val, int p, int x) { if (l == r) { sum[x] = val; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { modify(l, mid, val, p, x + x); } else { modify(mid + 1, r, val, p, x + x + 1); } pushup(x); } int query(int L, int R, int l, int r, int x) { if (L &lt;= l &amp;&amp; r &lt;= R) { return sum[x]; } int mid = (l + r) &gt;&gt; 1, ans = 0; if (L &lt;= mid) { ans = (ans + query(L, R, l, mid, x + x)) % MOD; } if (R &gt; mid) { ans = (ans + query(L, R, mid + 1, r, x + x + 1)) % MOD; } return ans; } int main(int argc, char const *argv[]) { scanf(&quot;%d&quot;, &amp;n); init(); build(1, n, 1); long long ans = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); modify(1, n, 0, a[i], 1); ans = (ans + 1LL * query(1, a[i], 1, n, 1) * fact[n - i] % MOD) % MOD; } printf(&quot;%lld&quot;, (ans + 1) % MOD); return 0; } ","link":"http://xyf007.ml/post/mu-ban-kang-tuo-zhan-kai/"},{"title":"【模板】裴蜀定理","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, a[21]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i] = a[i] &lt; 0 ? -a[i] : a[i]; } int GCD = __gcd(a[1], a[2]); for (int i = 3; i &lt;= n; i++) { GCD = __gcd(GCD, a[i]); } printf(&quot;%d&quot;, GCD); return 0; } ","link":"http://xyf007.ml/post/mu-ban-pei-shu-ding-li/"},{"title":"【模板】2–SAT","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct edge { int to, nxt; } e[2000001]; int n, m, head[2000001], E, dfn[2000001], low[2000001], dep, stack[2000001], top, col[2000001], color; bool vis[2000001]; void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void tarjan(int u) { dfn[u] = low[u] = ++dep; vis[u] = 1; stack[++top] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (!dfn[v]) { tarjan(v); checkmin(low[u], low[v]); } else { if (vis[v]) { checkmin(low[u], low[v]); } } } if (dfn[u] == low[u]) { col[u] = ++color; vis[u] = 0; while (stack[top] != u) { col[stack[top]] = color; vis[stack[top--]] = 0; } top--; } } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(head, -1, sizeof(head)); for (int i = 1; i &lt;= m; i++) { int u, v, a, b; scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;a, &amp;v, &amp;b); add(u + (a ^ 1) * n, v + (b &amp; 1) * n); add(v + (b ^ 1) * n, u + (a &amp; 1) * n); } for (int i = 1; i &lt;= 2 * n; i++) { if (!dfn[i]) { tarjan(i); } } for (int i = 1; i &lt;= n; i++) { if (col[i] == col[i + n]) { printf(&quot;IMPOSSIBLE&quot;); return 0; } } printf(&quot;POSSIBLE\\n&quot;); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, col[i] &gt; col[i + n]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-2-sat/"},{"title":"【模板】强连通分量","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct edge { int to, nxt; } e[50001]; int n, m, dfn[10001], low[10001], stack[10001], top, col[10001], color, E, head[10001], dep, ind[10001], sum[10001]; bool vis[10001]; void checkmin(int &amp;x, int y) { if (x &gt; y) { x = y; } } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void tarjan(int u) { dfn[u] = low[u] = ++dep; vis[u] = 1; stack[++top] = u; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (!dfn[v]) { tarjan(v); checkmin(low[u], low[v]); } else { if (vis[v]) { checkmin(low[u], dfn[v]); } } } if (dfn[u] == low[u]) { col[u] = ++color; vis[u] = 0; while (stack[top] != u) { col[stack[top]] = color; vis[stack[top--]] = 0; } top--; } } int main() { memset(head, -1, sizeof(head)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); } for (int i = 1; i &lt;= n; i++) { if (!dfn[i]) { tarjan(i); } } for (int i = 1; i &lt;= n; i++) { for (int j = head[i]; j != -1; j = e[j].nxt) { int v = e[j].to; if (col[i] != col[v]) { ind[col[i]]++; } } sum[col[i]]++; } int tmp = 0, ans = 0; for (int i = 1; i &lt;= color; i++) { if (!ind[i]) { tmp++; ans = sum[i]; } } if (tmp != 1) { printf(&quot;0&quot;); } else { printf(&quot;%d&quot;, ans); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-qiang-lian-tong-fen-liang/"},{"title":"【模板】最短路","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; struct edge { int to, nxt, cost; } e[200001]; int n, m, s, E, head[100001], dis[100001]; bool vis[100001]; void add(int f, int t, int c) { e[E].to = t; e[E].cost = c; e[E].nxt = head[f]; head[f] = E++; } void dijkstra(int s) { memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q; q.push(make_pair(0, s)); while (!q.empty()) { pair&lt;int, int&gt; tmp = q.top(); q.pop(); int u = tmp.second; if (vis[u]) { continue; } vis[u] = 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v]) { continue; } if (dis[u] + e[i].cost &lt; dis[v]) { dis[v] = dis[u] + e[i].cost; q.push(make_pair(dis[v], v)); } } } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); } dijkstra(s); for (int i = 1; i &lt;= n; i++) { printf(&quot;%d &quot;, dis[i]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-zui-duan-lu/"},{"title":"【模板】费用流","content":"#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; struct Edge { int to, nxt, cost, flow; } e[100001]; int n, m, s, t, E, head[5001], dis[5001], flow[5001], pre[5001], le[5001]; bool vis[5001]; void Add(int f, int t, int w, int c) { e[E].to = t; e[E].cost = c; e[E].flow = w; e[E].nxt = head[f]; head[f] = E++; } bool Spfa() { std::queue&lt;int&gt; q; memset(vis, false, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); memset(flow, 0x3f, sizeof(flow)); pre[t] = -1; dis[s] = 0; q.emplace(s); vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (e[i].flow &amp;&amp; dis[u] + e[i].cost &lt; dis[v]) { dis[v] = dis[u] + e[i].cost; le[v] = i; pre[v] = u; flow[v] = std::min(flow[u], e[i].flow); if (!vis[v]) { q.emplace(v); vis[v] = true; } } } } return pre[t] != -1; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1; i &lt;= m; i++) { int u, v, w, c; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c; Add(u, v, w, c); Add(v, u, 0, -c); } int max = 0, ans = 0; while (Spfa()) { max += flow[t]; ans += flow[t] * dis[t]; int p = t; while (p != s) { e[le[p]].flow -= flow[t]; e[le[p] ^ 1].flow += flow[t]; p = pre[p]; } } std::cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; ans; return 0; } ","link":"http://xyf007.ml/post/mu-ban-fei-yong-liu/"},{"title":"【模板】最大流","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; struct edge { int to, nxt, cost; } e[200001]; int n, m, s, t, E, head[10001], dep[10001], cur[10001]; void add(int u, int v, int c) { e[E].to = v; e[E].cost = c; e[E].nxt = head[u]; head[u] = E++; } bool bfs() { std::queue&lt;int&gt; q; memset(dep, 0, sizeof(dep)); for (int i = 1; i &lt;= n; i++) { cur[i] = head[i]; } q.push(s); dep[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (e[i].cost &amp;&amp; !dep[v]) { dep[v] = dep[u] + 1; q.push(v); } } } return dep[t]; } int dfs(int u, int sum) { if (u == t || !sum) { return sum; } int ans = 0; for (int i = cur[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (dep[v] == dep[u] + 1 &amp;&amp; e[i].cost) { int minn = dfs(v, std::min(sum, e[i].cost)); if (minn) { e[i].cost -= minn; e[i ^ 1].cost += minn; ans += minn; sum -= minn; if (!sum) { break; } } } cur[u] = e[i].nxt; } if (!ans) { dep[u] = -1; } return ans; } void dinic() { long long ans = 0; while (bfs()) { ans += dfs(s, 2e9); } std::cout &lt;&lt; ans; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1; i &lt;= m; i++) { int u, v, c; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; add(u, v, c); add(v, u, 0); } dinic(); return 0; } ","link":"http://xyf007.ml/post/mu-ban-zui-da-liu/"},{"title":"【模板】最小生成树","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int fa[5005], n, m; struct edge { int from, to, cost; bool operator &lt;(const edge x)const { return cost &lt; x.cost; } } e[200005]; inline int find(int x) { if (fa[x] == x) { return x; } return fa[x] = find(fa[x]); } inline void merge(int x, int y) { x = find(x); y = find(y); fa[y] = x; } inline bool judge(int x, int y) { return find(x) == find(y); } inline void init(int n) { for (int i = 1; i &lt;= n; i++) { fa[i] = i; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(n); memset(e, 0, sizeof(e)); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;e[i].from, &amp;e[i].to, &amp;e[i].cost); } int sum = 0; sort(e + 1, e + m + 1); for (int i = 1; i &lt;= m; i++) { if (!judge(e[i].from, e[i].to)) { sum += e[i].cost; merge(e[i].from, e[i].to); } } printf(&quot;%d\\n&quot;, sum); return 0; } ","link":"http://xyf007.ml/post/mu-ban-zui-xiao-sheng-cheng-shu/"},{"title":"【模板】最近公共祖先（LCA）","content":" 倍增 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct edge { int to, nxt; } e[1000001]; int T, n, m, s, E, head[500001], dep[500001], fa[500001][25], lg[500001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void dfs(int u, int f) { dep[u] = dep[f] + 1; fa[u][0] = f; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; i++) { fa[u][i] = fa[fa[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v != f) { dfs(v, u); } } } int lca(int u, int v) { if (dep[u] &lt; dep[v]) { swap(u, v); } while (dep[u] &gt; dep[v]) { u = fa[u][lg[dep[u] - dep[v]]]; } if (u == v) { return u; } for (int i = lg[dep[u]]; i &gt;= 0; i--) { if (fa[u][i] != fa[v][i]) { u = fa[u][i]; v = fa[v][i]; } } return fa[u][0]; } int main() { memset(head, -1, sizeof(head)); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) { int f, t; scanf(&quot;%d%d&quot;, &amp;f, &amp;t); add(f, t); add(t, f); } dfs(s, 0); for (int i = 2; i &lt;= n; i++) { lg[i] = lg[i &gt;&gt; 1] + 1; } while (m--) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); printf(&quot;%d\\n&quot;, lca(u, v)); } return 0; } dfs 序+ST 表 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; struct Edge { int to, nxt; } e[1000001]; int n, m, s, E, head[500001], dep[500001], first[500001], tot, f[1000001][21], lg[1000001]; void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int fa) { f[first[u] = ++tot][0] = u; dep[u] = dep[fa] + 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa) { continue; } Dfs(v, u); f[++tot][0] = u; } } int query(int l, int r) { if (l &gt; r) { std::swap(l, r); } int len = lg[r - l + 1]; return dep[f[l][len]] &lt; dep[f[r - (1 &lt;&lt; len) + 1][len]] ? f[l][len] : f[r - (1 &lt;&lt; len) + 1][len]; } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); memset(head, -1, sizeof(head)); std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt; n; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } Dfs(s, 0); for (int i = 2; i &lt;= tot; i++) { lg[i] = lg[i &gt;&gt; 1] + 1; } for (int i = 1; i &lt;= lg[tot]; i++) { for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= tot; j++) { f[j][i] = dep[f[j][i - 1]] &lt; dep[f[j + (1 &lt;&lt; (i - 1))][i - 1]] ? f[j][i - 1] : f[j + (1 &lt;&lt; (i - 1))][i - 1]; } } for (int i = 1; i &lt;= m; i++) { int u, v; std::cin &gt;&gt; u &gt;&gt; v; std::cout &lt;&lt; query(first[u], first[v]) &lt;&lt; '\\n'; } return 0; } 树链剖分 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; struct Edge { int to, nxt; } e[1000001]; int n, q, s, E, head[500001], sz[500001], son[500001], fa[500001], top[500001], dep[500001]; char gc() { static char now[1 &lt;&lt; 20], *S, *T; if (T == S) { T = (S = now) + fread(now, 1, 1 &lt;&lt; 20, stdin); if (T == S) { return EOF; } } return *S++; } int read() { int s = 0; char c = gc(); while (c &lt; '0' || c &gt; '9') { c = gc(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { s = s * 10 + c - '0'; c = gc(); } return s; } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void Dfs(int u, int f) { sz[u] = 1; fa[u] = f; dep[u] = dep[f] + 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == f) { continue; } Dfs(v, u); sz[u] += sz[v]; if (sz[v] &gt; sz[son[u]]) { son[u] = v; } } } void Dfs2(int u, int t) { top[u] = t; if (son[u]) { Dfs2(son[u], t); } for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (v == fa[u] || v == son[u]) { continue; } Dfs2(v, v); } } int GetLca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) { std::swap(u, v); } u = fa[top[u]]; } return dep[u] &lt; dep[v] ? u : v; } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); n = read(); q = read(); s = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add(u, v); add(v, u); } Dfs(s, 0); Dfs2(s, s); while (q--) { std::cout &lt;&lt; GetLca(read(), read()) &lt;&lt; '\\n'; } return 0; } Tarjan #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct edge { int to, nxt; edge(int to = 0, int nxt = -1) : to(to), nxt(nxt) {} } e[1000001]; struct question { int v, id, nxt; question(int v = 0, int id = 0, int nxt = -1) : v(v), id(id), nxt(nxt) {} } q[1000001]; int n, m, s, E, head[500001], tot, head2[500001], ans[1000001], f[500001]; bool vis[500001]; int find(int x) { if (x == f[x]) { return x; } return f[x] = find(f[x]); } void add(int f, int t) { e[E].to = t; e[E].nxt = head[f]; head[f] = E++; } void add2(int u, int v) { q[tot].v = v; q[tot].id = tot; q[tot].nxt = head2[u]; head2[u] = tot++; } void tarjan(int u) { f[u] = u; vis[u] = 1; for (int i = head[u]; i != -1; i = e[i].nxt) { int v = e[i].to; if (vis[v]) { continue; } tarjan(v); f[v] = u; } for (int i = head2[u]; i != -1; i = q[i].nxt) { int v = q[i].v, id = q[i].id; if (vis[v]) { ans[id] = ans[id &amp; 1 ? id - 1 : id + 1] = find(v); } } } int main(int argc, char const *argv[]) { memset(head, -1, sizeof(head)); memset(head2, -1, sizeof(head2)); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); add(v, u); } for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add2(u, v); add2(v, u); } tarjan(s); for (int i = 1; i &lt;= m; i++) { printf(&quot;%d\\n&quot;, ans[i * 2 - 1]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-zui-jin-gong-gong-zu-xian-lca/"},{"title":"【模板】二分图匹配","content":"#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, match[1001], e, ans; bool vis[1001], g[1001][1001]; bool dfs(int u) { for (int i = 1; i &lt;= m; i++) { if (g[u][i] &amp;&amp; !vis[i]) { vis[i] = 1; if (!match[i] || dfs(match[i])) { match[i] = u; return 1; } } } return 0; } void find() { for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof(vis)); if (dfs(i)) { ans++; } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e); for (int i = 1; i &lt;= e; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); if (u &lt;= n &amp;&amp; v &lt;= m) { g[u][v] = 1; } } find(); printf(&quot;%d\\n&quot;, ans); return 0; } ","link":"http://xyf007.ml/post/mu-ban-er-fen-tu-pi-pei/"},{"title":"【模板】Nim 游戏","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; int n, t, a[10000001]; int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } int sum = 0; for (int i = 1; i &lt;= n; i++) { sum ^= a[i]; } if (sum) { printf(&quot;Yes\\n&quot;); } else { printf(&quot;No\\n&quot;); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-nim-you-xi/"},{"title":"【模板】线段树","content":"#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const long long N = 100001; long long n, m, add[N &lt;&lt; 2], a[N], sum[N &lt;&lt; 2]; void pushup(long long x) { sum[x] = sum[x + x] + sum[x + x + 1]; } void pushdown(long long l, long long r, long long x) { long long mid = (l + r) &gt;&gt; 1; if (add[x]) { add[x + x] += add[x]; add[x + x + 1] += add[x]; sum[x + x] += add[x] * (mid - l + 1); sum[x + x + 1] += add[x] * (r - mid); add[x] = 0; } } void build(long long l, long long r, long long x) { add[x] = 0; if (l == r) { sum[x] = a[l]; return; } long long mid = (l + r) &gt;&gt; 1; build(l, mid, x + x); build(mid + 1, r, x + x + 1); pushup(x); } void modify(long long L, long long R, long long l, long long r, long long val, long long x) { if (L &lt;= l &amp;&amp; r &lt;= R) { sum[x] += val * (r - l + 1); add[x] += val; return; } pushdown(l, r, x); long long mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) { modify(L, R, l, mid, val, x + x); } if (R &gt; mid) { modify(L, R, mid + 1, r, val, x + x + 1); } pushup(x); } long long query(long long L, long long R, long long l, long long r, long long x) { if (L &lt;= l &amp;&amp; r &lt;= R) { return sum[x]; } pushdown(l, r, x); long long mid = (l + r) &gt;&gt; 1, ans = 0; if (L &lt;= mid) { ans += query(L, R, l, mid, x + x); } if (R &gt; mid) { ans += query(L, R, mid + 1, r, x + x + 1); } return ans; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); memset(a, 0, sizeof(a)); memset(sum, 0, sizeof(sum)); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } build(1, n, 1); for (int i = 1; i &lt;= m; i++) { long long ch, a, b, c; scanf(&quot;%lld%lld%lld&quot;, &amp;ch, &amp;a, &amp;b); if (ch == 2) { printf(&quot;%lld\\n&quot;, query(a, b, 1, n, 1)); } else { scanf(&quot;%lld&quot;, &amp;c); modify(a, b, 1, n, c, 1); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-xian-duan-shu/"},{"title":"【模板】ST 表","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int n, m, a[100001], st[100001][21]; void init() { for (int i = 1; i &lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; j &lt;= 21; j++) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } init(); for (int i = 1; i &lt;= m; i++) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); int len = log2(r - l + 1); printf(&quot;%d\\n&quot;, max(st[l][len], st[r - (1 &lt;&lt; len) + 1][len])); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-st-biao/"},{"title":"【模板】主席树（可持久化线段树）","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int l, r, sum; } t[6400001]; int n, m, a[200001], b[200001], root[200001], nn, tot; void build(int &amp;x, int l, int r) { x = ++tot; if (l == r) { return; } int mid = (l + r) &gt;&gt; 1; build(t[x].l, l, mid); build(t[x].r, mid + 1, r); } int modify(int x, int l, int r, int p) { int xx = ++tot; t[xx].l = t[x].l; t[xx].r = t[x].r; t[xx].sum = t[x].sum + 1; if (l == r) { return xx; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) { t[xx].l = modify(t[xx].l, l, mid, p); } else { t[xx].r = modify(t[xx].r, mid + 1, r, p); } return xx; } int query(int x, int y, int l, int r, int k) { if (l == r) { return l; } int mid = (l + r) &gt;&gt; 1, tmp = t[t[y].l].sum - t[t[x].l].sum; if (k &lt;= tmp) { return query(t[x].l, t[y].l, l, mid, k); } else { return query(t[x].r, t[y].r, mid + 1, r, k - tmp); } } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); b[i] = a[i]; } sort(b + 1, b + n + 1); nn = unique(b + 1, b + n + 1) - b - 1; build(root[0], 1, nn); for (int i = 1; i &lt;= n; i++) { int p = lower_bound(b + 1, b + nn + 1, a[i]) - b; root[i] = modify(root[i - 1], 1, nn, p); } for (int i = 1; i &lt;= m; i++) { int l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k); printf(&quot;%d\\n&quot;, b[query(root[l - 1], root[r], 1, nn, k)]); } return 0; } ","link":"http://xyf007.ml/post/mu-ban-zhu-xi-shu-ke-chi-jiu-hua-xian-duan-shu/"},{"title":"【模板】左偏树（可并堆）","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int l, r, val, dis, fa; } a[100001]; int n, m; int find(int x) { if (a[x].fa == x) { return x; } return a[x].fa = find(a[x].fa); } int merge(int x, int y) { if (!x || !y) { return x + y; } if (a[x].val &gt; a[y].val || (a[x].val == a[y].val &amp;&amp; x &gt; y)) { swap(x, y); } a[x].r = merge(a[x].r, y); if (a[a[x].l].dis &lt; a[a[x].r].dis) { swap(a[x].l, a[x].r); } a[x].dis = a[a[x].r].dis + 1; a[a[x].l].fa = a[a[x].r].fa = x; return x; } int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i].val); a[i].fa = i; } for (int i = 1; i &lt;= m; i++) { int op, x, y; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); if (op == 1) { scanf(&quot;%d&quot;, &amp;y); if (a[x].val == -1 || a[y].val == -1 || x == y) { continue; } x = find(x); y = find(y); merge(x, y); } else { if (a[x].val == -1) { printf(&quot;-1\\n&quot;); continue; } x = find(x); printf(&quot;%d\\n&quot;, a[x].val); a[x].val = -1; a[a[x].l].fa = a[x].l; a[a[x].r].fa = a[x].r; a[x].fa = merge(a[x].l, a[x].r); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-zuo-pian-shu-ke-bing-dui/"},{"title":"【模板】哈希","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; using namespace std; const long long base = 499, MOD = 1e9 + 7; long long n, a[10001]; string s; int main(int argc, char const *argv[]) { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; s; long long sum = 0; for (int j = 0; j &lt; (int)s.size(); j++) { sum = (sum * base + s[j]) % MOD; } a[i] = sum; } sort(a + 1, a + n + 1); int ans = 1; for (int i = 2; i &lt;= n; i++) { if (a[i] != a[i - 1]) { ans++; } } printf(&quot;%d&quot;, ans); return 0; } ","link":"http://xyf007.ml/post/mu-ban-ha-xi/"},{"title":"【模板】并查集","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, fa[100005], z, a, b; int find(int x) { if (x == fa[x]) { return x; } return fa[x] = find(fa[x]); } void merge(int x, int y) { x = find(x); y = find(y); fa[y] = x; } bool judge(int x, int y) { return find(x) == find(y); } void init() { for (int i = 1; i &lt;= n; i++) { fa[i] = i; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); init(); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;z, &amp;a, &amp;b); if (z == 1) { merge(a, b); } else { if (judge(a, b)) { printf(&quot;Y\\n&quot;); } else { printf(&quot;N\\n&quot;); } } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-bing-cha-ji/"},{"title":"【模板】莫队","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; struct query { long long id, l, r; bool operator&lt;(const query c) const { return id &lt; c.id; } } q[50001]; long long n, m, sz, c[50001], pos[50001], cnt[50001], tmp, ans[50001]; bool cmp(query c, query b) { if (pos[c.id] == pos[b.id]) { return c.r &lt; b.r; } return pos[c.id] &lt; pos[b.id]; } int main(int argc, char const *argv[]) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); sz = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;c[i]); } for (int i = 1; i &lt;= m; i++) { scanf(&quot;%lld%lld&quot;, &amp;q[i].l, &amp;q[i].r); q[i].id = i; pos[i] = (q[i].l - 1) / sz + 1; } sort(q + 1, q + m + 1, cmp); long long l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &lt; q[i].l) { tmp -= cnt[c[l]] * (cnt[c[l]] - 1) / 2; cnt[c[l]]--; tmp += cnt[c[l]] * (cnt[c[l]] - 1) / 2; l++; } while (l &gt; q[i].l) { l--; tmp -= cnt[c[l]] * (cnt[c[l]] - 1) / 2; cnt[c[l]]++; tmp += cnt[c[l]] * (cnt[c[l]] - 1) / 2; } while (r &lt; q[i].r) { r++; tmp -= cnt[c[r]] * (cnt[c[r]] - 1) / 2; cnt[c[r]]++; tmp += cnt[c[r]] * (cnt[c[r]] - 1) / 2; } while (r &gt; q[i].r) { tmp -= cnt[c[r]] * (cnt[c[r]] - 1) / 2; cnt[c[r]]--; tmp += cnt[c[r]] * (cnt[c[r]] - 1) / 2; r--; } ans[q[i].id] = tmp; } sort(q + 1, q + m + 1); for (int i = 1; i &lt;= m; i++) { long long GCD = __gcd(ans[i], (q[i].r - q[i].l + 1) * (q[i].r - q[i].l) / 2); if (q[i].l == q[i].r) { printf(&quot;0/1\\n&quot;); } else { printf(&quot;%lld/%lld\\n&quot;, ans[i] / GCD, ((q[i].r - q[i].l + 1) * (q[i].r - q[i].l) / 2) / GCD); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-mo-dui/"},{"title":"【模板】树状数组","content":"#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algoithm&gt; #include &lt;cstring&gt; using namespace std; int n, m, i, num[500001], t[500001], l, r; int lowbit(int x) { return x &amp; (-x); } void add(int x, int p) { while (x &lt;= n) { t[x] += p; x += lowbit(x); } } int sum(int k) { int ans = 0; while (k &gt; 0) { ans += t[k]; k -= lowbit(k); } return ans; } int ask(int l, int r) { return sum(r) - sum(l - 1); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (i = 1; i &lt;= n; i++) { int x; scanf(&quot;%d&quot;, &amp;x); add(i, x); } for (i = 1; i &lt;= m; i++) { int c, l, r; scanf(&quot;%d%d%d&quot;, &amp;c, &amp;l, &amp;r); if (c == 1) { add(l, r); } else { printf(&quot;%d\\n&quot;, ask(l, r)); } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-shu-zhuang-shu-zu/"},{"title":"【模板】平衡树","content":" treap #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; using namespace std; struct node { int size, val, sum, son[2], rd; } a[100001]; int n, root, num; void pushup(int p) { a[p].size = a[a[p].son[0]].size + a[a[p].son[1]].size + a[p].sum; } void rotate(int &amp;p, int d) { int temp = a[p].son[d ^ 1]; a[p].son[d ^ 1] = a[temp].son[d]; a[temp].son[d] = p; pushup(p); pushup(temp); p = temp; } void insert(int &amp;p, int x) { if (!p) { p = ++num; a[p].size = a[p].sum = 1; a[p].val = x; a[p].rd = rand(); return; } if (a[p].val == x) { a[p].sum++; a[p].size++; return; } int d = (x &gt; a[p].val); insert(a[p].son[d], x); if (a[p].rd &lt; a[a[p].son[d]].rd) { rotate(p, d ^ 1); } pushup(p); } void erase(int &amp;p, int x) { if (!p) { return; } if (x &lt; a[p].val) { erase(a[p].son[0], x); } else { if (x &gt; a[p].val) { erase(a[p].son[1], x); } else { if (!a[p].son[0] &amp;&amp; !a[p].son[1]) { a[p].size--; a[p].sum--; if (!a[p].sum) { p = 0; } } else { if (!a[p].son[0] &amp;&amp; a[p].son[1]) { rotate(p, 0); erase(a[p].son[0], x); } else { if (a[p].son[0] &amp;&amp; !a[p].son[1]) { rotate(p, 1); erase(a[p].son[1], x); } else { int d = (a[a[p].son[0]].rd &gt; a[a[p].son[1]].rd); rotate(p, d); erase(a[p].son[d], x); } } } } } pushup(p); } int rank(int p,int x) { if (!p) { return 0; } if (x &lt; a[p].val) { return rank(a[p].son[0], x); } if (x &gt; a[p].val) { return a[a[p].son[0]].size + a[p].sum + rank(a[p].son[1], x); } return a[a[p].son[0]].size + 1; } int find(int p, int x) { if (!p) { return 0; } if (a[a[p].son[0]].size &gt;= x) { return find(a[p].son[0], x); } if (a[a[p].son[0]].size + a[p].sum &lt; x) { return find(a[p].son[1], x - a[a[p].son[0]].size - a[p].sum); } return a[p].val; } int pre(int p, int x) { if (!p) { return -2147483647; } if (a[p].val &gt;= x) { return pre(a[p].son[0], x); } else { return max(a[p].val, pre(a[p].son[1], x)); } } int suf(int p, int x) { if (!p) { return 2147483647; } if (a[p].val &lt;= x) { return suf(a[p].son[1], x); } else { return min(a[p].val, suf(a[p].son[0], x)); } } int main() { srand(time(NULL)); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch (opt) { case 1: insert(root, x); break; case 2: erase(root, x); break; case 3: printf(&quot;%d\\n&quot;, rank(root, x)); break; case 4: printf(&quot;%d\\n&quot;, find(root, x)); break; case 5: printf(&quot;%d\\n&quot;, pre(root, x)); break; default: printf(&quot;%d\\n&quot;, suf(root,x)); break; } } return 0; } splay #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; struct node { int son[2], val, size, sum, fa; } a[100001]; int n, root, tot; int check(int x) { return a[a[x].fa].son[1] == x; } void pushup(int x) { a[x].size = a[a[x].son[0]].size + a[a[x].son[1]].size + a[x].sum; } void rotate(int x) { int y = a[x].fa, z = a[y].fa, d1 = check(x), d2 = check(y), son = a[x].son[d1 ^ 1]; a[y].son[d1] = son; a[son].fa = y; a[z].son[d2] = x; a[x].fa = z; a[x].son[d1 ^ 1] = y; a[y].fa = x; pushup(y); pushup(x); } void splay(int x, int goal) { while (a[x].fa != goal) { int y = a[x].fa, z = a[y].fa, d1 = check(x), d2 = check(y); if (z != goal) { if (d1 == d2) { rotate(y); } else { rotate(x); } } rotate(x); } if (!goal) { root = x; } } void search(int x) { int p = root; if (!p) { return; } while (a[p].son[a[p].val &lt; x] &amp;&amp; a[p].val != x) { p = a[p].son[a[p].val &lt; x]; } splay(p, 0); } void insert(int x) { int p = root, fa = 0; while (p &amp;&amp; a[p].val != x) { fa = p; p = a[p].son[a[p].val &lt; x]; } if (p) { a[p].sum++; } else { p = ++tot; if (fa) { a[fa].son[a[fa].val &lt; x] = p; } a[p].son[0] = a[p].son[1] = 0; a[p].val = x; a[p].sum = a[p].size = 1; a[p].fa = fa; } splay(p, 0); } int rank(int x) { search(x); return a[a[root].son[0]].size; } int find(int x) { int p = root; while (1) { if (a[p].son[0] &amp;&amp; x &lt;= a[a[p].son[0]].size) { p = a[p].son[0]; } else { if (x &gt; a[a[p].son[0]].size + a[p].sum) { x -= a[a[p].son[0]].size + a[p].sum; p = a[p].son[1]; } else { return p; } } } } int pre(int x) { search(x); if (a[root].val &lt; x) { return root; } int p = a[root].son[0]; while (a[p].son[1]) { p = a[p].son[1]; } return p; } int suf(int x) { search(x); if (a[root].val &gt; x) { return root; } int p = a[root].son[1]; while (a[p].son[0]) { p = a[p].son[0]; } return p; } void erase(int x) { int prefix = pre(x), suffix = suf(x); splay(prefix, 0); splay(suffix, prefix); int now = a[suffix].son[0]; if (a[now].sum &gt; 1) { a[now].sum--; splay(now, 0); } else { a[suffix].son[0] = 0; } } int main() { scanf(&quot;%d&quot;, &amp;n); insert(0x3f3f3f3f); insert(0xcfcfcfcf); for (int i = 1; i &lt;= n; i++) { int op, x; scanf(&quot;%d%d&quot;, &amp;op, &amp;x); switch (op) { case 1: insert(x); break; case 2: erase(x); break; case 3: printf(&quot;%d\\n&quot;, rank(x)); break; case 4: printf(&quot;%d\\n&quot;, a[find(x + 1)].val); break; case 5: printf(&quot;%d\\n&quot;, a[pre(x)].val); break; default: printf(&quot;%d\\n&quot;, a[suf(x)].val); break; } } return 0; } fhq_treap #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; using namespace std; int n, sz[100001], val[100001], ch[100001][2], rd[100001], root, tot; int newnode(int x) { sz[++tot] = 1; val[tot] = x; rd[tot] = rand(); return tot; } void pushup(int p) { sz[p] = sz[ch[p][0]] + sz[ch[p][1]] + 1; } void split(int p, int now, int &amp;x, int &amp;y) { if (!p) { x = y = 0; return; } if (now &gt;= val[p]) { x = p; split(ch[p][1], now, ch[p][1], y); } else { y = p; split(ch[p][0], now, x, ch[p][0]); } pushup(p); } int merge(int x, int y) { if (!x || !y) { return x + y; } if (rd[x] &lt; rd[y]) { ch[x][1] = merge(ch[x][1], y); pushup(x); return x; } else { ch[y][0] = merge(x, ch[y][0]); pushup(y); return y; } } int kth(int p, int k) { if (!p) { return 0; } if (sz[ch[p][0]] &gt;= k) { return kth(ch[p][0], k); } else { if (k == sz[ch[p][0]] + 1) { return p; } return kth(ch[p][1], k - sz[ch[p][0]] - 1); } } int main(int argc, char const *argv[]) { srand(time(0)); scanf(&quot;%d&quot;, &amp;n); int x, y, z; for (int i = 1; i &lt;= n; i++) { int op, k; scanf(&quot;%d%d&quot;, &amp;op, &amp;k); switch (op) { case 1: split(root, k, x, y); root = merge(merge(x, newnode(k)), y); break; case 2: split(root, k, x, y); split(x, k - 1, x, z); z = merge(ch[z][0], ch[z][1]); root = merge(merge(x, z), y); break; case 3: split(root, k - 1, x, y); printf(&quot;%d\\n&quot;, sz[x] + 1); root = merge(x, y); break; case 4: printf(&quot;%d\\n&quot;, val[kth(root, k)]); break; case 5: split(root, k - 1, x, y); printf(&quot;%d\\n&quot;, val[kth(x, sz[x])]); root = merge(x, y); break; default: split(root, k, x, y); printf(&quot;%d\\n&quot;, val[kth(y, 1)]); root = merge(x, y); break; } } return 0; } 替罪羊树 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;numeric&gt; #include &lt;cassert&gt; constexpr double kAlpha = 0.75; struct node { int ls, rs, sz, tot, val; bool exist; } t[2000001]; int n, tmp[2000001], cnt, root, pool[2000001], top; bool Check(int x) { return t[t[x].ls].sz &lt;= t[x].sz * kAlpha &amp;&amp; t[t[x].rs].sz &lt;= t[x].sz * kAlpha; } void pushup(int x) { t[x].sz = t[t[x].ls].sz + t[t[x].rs].sz + t[x].exist; t[x].tot = t[t[x].ls].tot + t[t[x].rs].tot + 1; } void Dfs(int x) { if (!x) { return; } Dfs(t[x].ls); if (t[x].exist) { tmp[++cnt] = x; } else { pool[++top] = x; } Dfs(t[x].rs); } int Build(int l, int r) { if (l &gt; r) { return 0; } if (l == r) { t[tmp[l]].ls = t[tmp[l]].rs = 0; t[tmp[l]].sz = t[tmp[l]].tot = 1; return tmp[l]; } int mid = (l + r) &gt;&gt; 1, x = tmp[mid]; t[x].ls = Build(l, mid - 1); t[x].rs = Build(mid + 1, r); pushup(x); return x; } void Rebuild(int &amp;x) { cnt = 0; Dfs(x); if (cnt) { x = Build(1, cnt); } else { x = 0; } } void Insert(int &amp;p, int x) { if (!p) { p = pool[top--]; t[p].val = x; t[p].ls = t[p].rs = 0; t[p].sz = t[p].tot = 1; t[p].exist = true; return; } t[p].sz++; t[p].tot++; if (t[p].val &gt;= x) { Insert(t[p].ls, x); } else { Insert(t[p].rs, x); } if (!Check(p)) { Rebuild(p); } } int calc_rank(int x) { int p = root, ans = 1; while (p) { if (t[p].val &gt;= x) { p = t[p].ls; } else { ans += t[t[p].ls].sz + t[p].exist; p = t[p].rs; } } return ans; } int kth(int x) { int p = root; while (p) { if (t[p].exist &amp;&amp; x == t[t[p].ls].sz + 1) { return t[p].val; } else if (t[t[p].ls].sz &gt;= x) { p = t[p].ls; } else { x -= t[t[p].ls].sz + t[p].exist; p = t[p].rs; } } return 0; } void Delete(int p, int x) { if (t[p].exist &amp;&amp; t[t[p].ls].sz + 1 == x) { t[p].exist = false; t[p].sz--; return; } t[p].sz--; if (t[t[p].ls].sz + t[p].exist &gt;= x) { Delete(t[p].ls, x); } else { Delete(t[p].rs, x - t[t[p].ls].sz - t[p].exist); } } int main(int argc, char const *argv[]) { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::iota(pool + 1, pool + 2000001, 1); top = 2000000; std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int op, x; std::cin &gt;&gt; op &gt;&gt; x; switch (op) { case 1: Insert(root, x); break; case 2: Delete(root, calc_rank(x)); if (t[root].sz &lt; t[root].tot * kAlpha) { Rebuild(root); } break; case 3: std::cout &lt;&lt; calc_rank(x) &lt;&lt; '\\n'; break; case 4: std::cout &lt;&lt; kth(x) &lt;&lt; '\\n'; break; case 5: std::cout &lt;&lt; kth(calc_rank(x) - 1) &lt;&lt; '\\n'; break; case 6: std::cout &lt;&lt; kth(calc_rank(x + 1)) &lt;&lt; '\\n'; break; default: assert(false); break; } } return 0; } ","link":"http://xyf007.ml/post/mu-ban-ping-heng-shu/"},{"title":"【模板】AC 自动机","content":"class AhoCorasickAutomaton { public: struct Node { int ch[26], fail; } t_[1000001]; int tot_; AhoCorasickAutomaton() {} void Insert(const char *); void Insert(const std::string &amp;s) { Insert(s.c_str()); } void Build(); int Query(const char *); int Query(const std::string &amp;t) { return Query(t.c_str()); } ~AhoCorasickAutomaton() {} } T; void AhoCorasickAutomaton::Insert(const char *s) { size_t n = std::strlen(s); int now = 0; for (size_t i = 0; i &lt; n; i++) { int id = s[i] - 'a'; if (!t_[now].ch[id]) { t_[now].ch[id] = ++tot_; } now = t_[now].ch[id]; } cnt[now]++; } void AhoCorasickAutomaton::Build() { std::queue&lt;int&gt; q; for (int i = 0; i &lt; 26; i++) { if (t_[0].ch[i]) { q.emplace(t_[0].ch[i]); } } while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) { if (t_[u].ch[i]) { t_[t_[u].ch[i]].fail = t_[t_[u].fail].ch[i]; q.emplace(t_[u].ch[i]); } else { t_[u].ch[i] = t_[t_[u].fail].ch[i]; } } } } int AhoCorasickAutomaton::Query(const char *t) { int now = 0, ans = 0; size_t n = std::strlen(t); for (size_t i = 0; i &lt; n; i++) { int id = t[i] - 'a'; now = t_[now].ch[id]; for (int j = now; cnt[j] != -1; j = t_[j].fail) { ans += cnt[j]; cnt[j] = -1; } } return ans; } ","link":"http://xyf007.ml/post/mu-ban-ac-zi-dong-ji/"}]}